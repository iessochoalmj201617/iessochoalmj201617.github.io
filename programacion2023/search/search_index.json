{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"00- Inicio","text":""},{"location":"#programacion","title":"Programaci\u00f3n","text":"<p>Aqu\u00ed puedes encontrar los apuntes del m\u00f3dulo de Programaci\u00f3n, que se imparte en el primer curso del ciclo formativo de grado superior de Desarrollo de Aplicaciones Multiplataforma.</p> <p>La duraci\u00f3n del m\u00f3dulo es de 256 horas lectivas, a raz\u00f3n de  8 horas semanales. Se ha planificado bas\u00e1ndose en 4 sesiones de 2 horas lectivas por semana.</p>"},{"location":"#resultados-de-aprendizaje-y-criterios-de-evaluacion","title":"Resultados de aprendizaje y criterios de evaluaci\u00f3n","text":"<ul> <li>Reconoce la estructura de un programa inform\u00e1tico, identificando y relacionando los elementos propios del lenguaje de programaci\u00f3n utilizado.</li> </ul> Criterios de evaluaci\u00f3n Se han identificado los bloques que componen la estructura de un programa inform\u00e1tico. Se han creado proyectos de desarrollo de aplicaciones Se han utilizado entornos integrados de desarrollo. Se han identificado los distintos tipos de variables y la utilidad espec\u00edfica de cada uno. Se ha modificado el c\u00f3digo de un programa para crear y utilizar variables. Se han creado y utilizado constantes y literales. Se han clasificado, reconocido y utilizado en expresiones los operadores del lenguaje. Se ha comprobado el funcionamiento de las conversiones de tipo expl\u00edcitas e impl\u00edcitas. Se han introducido comentarios en el c\u00f3digo. <ul> <li>Escribe y prueba programas sencillos, reconociendo y aplicando los fundamentos de la programaci\u00f3n orientada a objetos.</li> <li>Escribe y depura c\u00f3digo, analizando y utilizando las estructuras de control del lenguaje.</li> <li>Desarrolla programas organizados en clases analizando y aplicando los principios de la programaci\u00f3n orientada a objetos.</li> <li>Realiza operaciones de entrada y salida de informaci\u00f3n, utilizando procedimientos espec\u00edficos del lenguaje y librer\u00edas de clases.</li> <li>Escribe programas que manipulen informaci\u00f3n seleccionando y utilizando tipos avanzados de datos.</li> <li>Desarrolla programas aplicando caracter\u00edsticas avanzadas de los lenguajes orientados a objetos y del entorno de programaci\u00f3n.</li> <li>Utiliza bases de datos orientadas a objetos, analizando sus caracter\u00edsticas y aplicando t\u00e9cnicas para mantener la persistencia de la informaci\u00f3n.</li> <li>Gestiona informaci\u00f3n almacenada en bases de datos relacionales manteniendo la integridad y consistencia de los datos.</li> </ul>"},{"location":"#unidades-didacticas-temporalizacion","title":"Unidades did\u00e1cticas / Temporalizaci\u00f3n","text":"<p>A continuaci\u00f3n se muestran las unidades did\u00e1cticas y una estimaci\u00f3n temporal de cada una de ellas. El curso est\u00e1 dividido en 10 unidades did\u00e1cticas distribuidas en tres trimestres.</p>"},{"location":"#primera-evaluacion","title":"Primera evaluaci\u00f3n","text":"<p>Compuesta por las 5 primeras unidades, donde se estudiar\u00e1n los aspectos b\u00e1sicos de la programaci\u00f3n orientada a objetos usando el lenguaje de programaci\u00f3n Java.</p> Unidad T\u00edtulo Sesiones Horas 1 Elementos de un programa inform\u00e1tico 10 20 2 Estructuras b\u00e1sicas de control 13 26 3 Programaci\u00f3n orientada a objetos. Clases y Objetos 12 24 4 Arrays 9 18 5 Herencia y polimorfismo 14 28"},{"location":"#segunda-evaluacion","title":"Segunda evaluaci\u00f3n","text":"<p>Incluye 3 unidades y se profundizar\u00e1 en aspectos de codificaci\u00f3n como colecciones de Java, interfaces de usuario, reflections, expresiones regulares, etc.</p> Unidad T\u00edtulo Sesiones Horas 6 Colecciones 15 30 7 Programaci\u00f3n avanzada 10 20 8 Interfaces de usuario 16 32"},{"location":"#tercera-evaluacion","title":"Tercera evaluaci\u00f3n","text":"<p>Por \u00faltimo se aprender\u00e1n t\u00e9cnicas de lectura y escritura y persistencia de la informaci\u00f3n en ficheros y bases de datos.</p> Unidad T\u00edtulo Sesiones Horas 9 Persistencia de la informaci\u00f3n 13 26 10 Bases de datos 16 32"},{"location":"about/","title":"About","text":"<p>Patricia Mart\u00ed</p> <p>p.marti2@edu.gva.es</p>"},{"location":"about/#bibliografia-y-webgrafia","title":"Bibliograf\u00eda y webgraf\u00eda","text":"<p>https://docs.oracle.com/en/java/</p> <p>Java, Java, Java- Object-Oriented Problem Solving - Third Edition R. Morelli and R. Walde</p>"},{"location":"index%20copy/","title":"Programaci\u00f3n","text":"<p>Aqu\u00ed puedes encontrar los apuntes del m\u00f3dulo de Programaci\u00f3n, que se imparte en el primer curso del ciclo formativo de grado superior de Desarrollo de Aplicaciones Multiplataforma.</p> <p>La duraci\u00f3n del m\u00f3dulo es de 256 horas lectivas, a raz\u00f3n de  8 horas semanales. Se ha planificado bas\u00e1ndose en 4 sesiones de 2 horas lectivas por semana.</p>"},{"location":"index%20copy/#resultados-de-aprendizaje-y-criterios-de-evaluacion","title":"Resultados de aprendizaje y criterios de evaluaci\u00f3n","text":"<ul> <li>Reconoce la estructura de un programa inform\u00e1tico, identificando y relacionando los elementos propios del lenguaje de programaci\u00f3n utilizado.</li> </ul> Criterios de evaluaci\u00f3n Se han identificado los bloques que componen la estructura de un programa inform\u00e1tico. Se han creado proyectos de desarrollo de aplicaciones Se han utilizado entornos integrados de desarrollo. Se han identificado los distintos tipos de variables y la utilidad espec\u00edfica de cada uno. Se ha modificado el c\u00f3digo de un programa para crear y utilizar variables. Se han creado y utilizado constantes y literales. Se han clasificado, reconocido y utilizado en expresiones los operadores del lenguaje. Se ha comprobado el funcionamiento de las conversiones de tipo expl\u00edcitas e impl\u00edcitas. Se han introducido comentarios en el c\u00f3digo. <ul> <li>Escribe y prueba programas sencillos, reconociendo y aplicando los fundamentos de la programaci\u00f3n orientada a objetos.</li> <li>Escribe y depura c\u00f3digo, analizando y utilizando las estructuras de control del lenguaje.</li> <li>Desarrolla programas organizados en clases analizando y aplicando los principios de la programaci\u00f3n orientada a objetos.</li> <li>Realiza operaciones de entrada y salida de informaci\u00f3n, utilizando procedimientos espec\u00edficos del lenguaje y librer\u00edas de clases.</li> <li>Escribe programas que manipulen informaci\u00f3n seleccionando y utilizando tipos avanzados de datos.</li> <li>Desarrolla programas aplicando caracter\u00edsticas avanzadas de los lenguajes orientados a objetos y del entorno de programaci\u00f3n.</li> <li>Utiliza bases de datos orientadas a objetos, analizando sus caracter\u00edsticas y aplicando t\u00e9cnicas para mantener la persistencia de la informaci\u00f3n.</li> <li>Gestiona informaci\u00f3n almacenada en bases de datos relacionales manteniendo la integridad y consistencia de los datos.</li> </ul>"},{"location":"index%20copy/#unidades-didacticas-temporalizacion","title":"Unidades did\u00e1cticas / Temporalizaci\u00f3n","text":"<p>A continuaci\u00f3n se muestran las unidades did\u00e1cticas y una estimaci\u00f3n temporal de cada una de ellas. El curso est\u00e1 dividido en 10 unidades did\u00e1cticas distribuidas en tres trimestres.</p>"},{"location":"index%20copy/#primera-evaluacion","title":"Primera evaluaci\u00f3n","text":"<p>Compuesta por las 5 primeras unidades, donde se estudiar\u00e1n los aspectos b\u00e1sicos de la programaci\u00f3n orientada a objetos usando el lenguaje de programaci\u00f3n Java.</p> Unidad T\u00edtulo Sesiones Horas 1 Elementos de un programa inform\u00e1tico 10 20 2 Estructuras b\u00e1sicas de control 13 26 3 Programaci\u00f3n orientada a objetos. Clases y Objetos 12 24 4 Arrays 9 18 5 Herencia y polimorfismo 14 28"},{"location":"index%20copy/#segunda-evaluacion","title":"Segunda evaluaci\u00f3n","text":"<p>Incluye 3 unidades y se profundizar\u00e1 en aspectos de codificaci\u00f3n como colecciones de Java, interfaces de usuario, reflections, expresiones regulares, etc.</p> Unidad T\u00edtulo Sesiones Horas 6 Colecciones 15 30 7 Programaci\u00f3n avanzada 10 20 8 Interfaces de usuario 16 32"},{"location":"index%20copy/#tercera-evaluacion","title":"Tercera evaluaci\u00f3n","text":"<p>Por \u00faltimo se aprender\u00e1n t\u00e9cnicas de lectura y escritura y persistencia de la informaci\u00f3n en ficheros y bases de datos.</p> Unidad T\u00edtulo Sesiones Horas 9 Persistencia de la informaci\u00f3n 13 26 10 Bases de datos 16 32"},{"location":"shortcuts/","title":"Atajos de teclado para IntelliJ","text":""},{"location":"shortcuts/#codigo","title":"C\u00f3digo","text":""},{"location":"shortcuts/#eliminar-imports-que-no-se-usan-ctrl-alt-o","title":"Eliminar imports que no se usan \u2192 CTRL + ALT + o","text":""},{"location":"shortcuts/#formatear-el-codigo-ctrl-alt-l","title":"Formatear el c\u00f3digo \u2192 CTRL + ALT + l","text":""},{"location":"ud1/121conceptosbasicos/","title":"\ud83d\udcbe JAVA","text":"<p>Java es un lenguaje de programaci\u00f3n orientado a objetos. Fue creado por James Gosling en 1995. Oracle lo compr\u00f3. Es un lenguaje indepediente de la plataforma donde va a ser ejecutado, esto significa, que una vez que se compila (.class tambi\u00e9n llamado bytecode) puede ser transportado a diferentes plataformas (Windows, MacOS, Linux) para ser ejecutado. \u00bfC\u00f3mo se hace esto? Utilizando la JVM (Java Virtual Machine). La JVM coge los bytecode compilados y los interpreta dependiendo del OS para poder ser ejecutado. Por tanto, el bytecode siempre es el mismo, pero lo que genera la JVM cambiar\u00e1 para cada SO. Tambi\u00e9n existen otros t\u00e9rminos muy famosos relacionados con Java como JRE y JDK. </p> <p></p>"},{"location":"ud1/121conceptosbasicos/#jre","title":"JRE","text":"<p>Java Runtime Environment. La m\u00e1quina virtual de Java est\u00e1 incluida en el JRE. Se utiliza para ejecutar aplicaciones Java en el SO, por tanto si queremos desplegar una aplicaci\u00f3n en Java, necesitamos tener instalado previamente el JRE para esa m\u00e1quina y plataforma.</p>"},{"location":"ud1/121conceptosbasicos/#jdk","title":"JDK","text":"<p>Java Development Kit. Es m\u00e1s pesado que el JRE, contiene todas las herramientas para programar y compilar las clases Java en bytecode, por tanto cuando desarrollamos clases Java necesitamos el JDK. El JDK incluye el JRE.</p> <p></p>"},{"location":"ud1/121conceptosbasicos/#jdk-vs-jre","title":"JDK vs JRE","text":"<p>El JDK contiene las herramientas que permiten al programador compilar programas escritos en lenguaje Java y transformarlo en bytecodes de la m\u00e1quina virtual de Java(JVM). Incluye tambi\u00e9n el JRE que permiten ejecutar un programa Java.</p> <p>Para ejecutar en una m\u00e1quina con un sistema operativo en concreto, necesitamos tener instalado el JRE para ese sistema operativo</p> <p></p>"},{"location":"ud1/121conceptosbasicos/#versiones-java","title":"Versiones Java","text":"<p>Aparece una versi\u00f3n de Java cada 6 meses, pero solamente las versiones LTS Release (Long Term Support) tienen un largo soporte en el tiempo. Cada versi\u00f3n tiene nuevas funcionalidades, pero si no vamos a probar nuevas funcionalidades, para nuestros proyectos debemos utilizar versiones LTS.</p> <p></p> <p>La \u00faltima versi\u00f3n de Java LTS Release (Long Term Support),  es JAVA 21 LTS. Nosotros para el prop\u00f3sito de este curso usaremos Java 17 aunque no hay problema en utilizar la 21 para nuestro prop\u00f3sito.</p>"},{"location":"ud1/121conceptosbasicos/#por-que-java","title":"\u00bfPor qu\u00e9 Java?","text":"<ul> <li>Naci\u00f3 en 1995 y todav\u00eda sigue siendo uno de los lenguajes m\u00e1s usados a nivel mundial.</li> <li>Su capacidad de escribirlo y ejecutarlo en cualquier plataforma: \"Write once, run anywhere\".</li> <li>Desde que naci\u00f3 han salido muchas releases de gran importancia, el lenguaje sigue evolucionando con nuevas funcionalidades.</li> <li>Tiene un comunidad muy grande de c\u00f3digo abierto, documentaci\u00f3n y tutoriales. Es usado por muchas compa\u00f1\u00edas de software, por tanto, se ofertan muchos empleos de desarrolladores Java.</li> </ul> <p>Ampl\u00eda conocimientos</p> <p>El siguiente art\u00edculo, nos explica el proceso de compilaci\u00f3n de un programa Java. Vamos a echarle un vistazo</p> <p>Proceso de ejecuci\u00f3n en Java</p>"},{"location":"ud1/122setup/","title":"\ud83d\udcbe \u00bfQu\u00e9 se necesita para programar en Java?","text":"<ul> <li> <p>Instalar el JDK versi\u00f3n 17. Lo podemos descarga desde la p\u00e1gina oficial de Oracle.</p> </li> <li> <p>Instalar un IDE (Integrated Development Environment), es un programa que te ayudar a desarrollar aplicaciones. Hay muchas opciones disponibles de IDEs.</p> </li> </ul> <p></p>"},{"location":"ud1/122setup/#setup-java-17-y-intellij-en-windows","title":"Setup Java 17 y IntelliJ en Windows","text":"<ol> <li> <p>Vamos a descargar la versi\u00f3n de Eclipse Temurin y descargamos JDK 17.</p> <p>https://adoptium.net/es/temurin/releases/</p> </li> </ol> <p>En el siguiente v\u00eddeo pod\u00e9is conocer las diferencias entre las  versiones de jdk</p> <p>https://youtu.be/aYWZvbUWwjo</p> <ol> <li> <p>Instalamos el JDK.</p> <p>En linux usamos el siguiente comando para instalar el jdk: sudo apt-get install openjdk-17-jdk</p> </li> <li> <p>Windows: A\u00f1adimos en las variables de entorno del sistema dentro de la variable Path, la ruta donde se ha instalado java en nuestra m\u00e1quina (C:\\Program Files\\Eclipse Adoptium\\jdk-17.0.7.7-hotspot\\bin)</p> </li> </ol> <p>Ten\u00e9is un tutorial en </p> <p>https://youtu.be/oAin-q1oTDw</p> <ol> <li> <p>Windows: Agregamos tambi\u00e9n una nueva variable llamada JAVA_HOME \u2192 C:\\Program Files\\Eclipse Adoptium\\jdk-17.0.7.7-hotspot\\bin (Ruta de nuestra m\u00e1quina).Depende de la versi\u00f3n jdk que hab\u00e9is instalado.</p> </li> <li> <p>Verificamos que se ha instalado java, ejecutando desde l\u00ednea de comandos:</p> <pre><code>java --version\n</code></pre> </li> <li> <p>Descargamos e instalamos. No descargues la versi\u00f3n Ultimate</p> <p>IntelliJ Community</p> </li> </ol> <p></p> <ol> <li>En File -&gt; Settings, modificamos las siguientes opciones:</li> </ol> <p> </p>"},{"location":"ud1/123holamundo/","title":"\ud83d\udcbe Proyecto \"Hola Mundo\". Estructura de un programa","text":"<p>Cada vez que est\u00e1s aprendiendo un nuevo lenguaje de programaci\u00f3n es una tradici\u00f3n crear un nuevo programa muy simple que genera el texto Hola mundo. Veamos como podemos hacer esto en IntelliJ.</p> <ol> <li>Hacemos click en crear nuevo proyecto  </li> <li>elegimos el JDK 17 que hemos instalado y el nombre del proyecto </li> <li>Le damos a create.</li> <li>Creamos una nueva clase Java llamada Hello.java  </li> <li>Vamos a crear un m\u00e9todo para imprimir el mensaje Hola mundo. Usaremos un m\u00e9todo especial llamado main. El main es el primer m\u00e9todo que Java busca y ejecuta en el proyecto. Es el punto de entrada. </li> <li>Ejecutamos el programa mediante </li> <li>A\u00f1adimos y ejecutamos la siguiente sentencia dentro del m\u00e9todo main: System.out.println(\"Hello World\"); </li> </ol>"},{"location":"ud1/123holamundo/#desafio","title":"Desaf\u00edo","text":"<p>Ejercicio 1</p> <p>Modifica el programa para que imprima por pantalla \"Hola mundo. Me gusta programar\".</p> <p>Ejercicio 2</p> <p>Realizar las actividades 1 y 2.</p>"},{"location":"ud1/131variables/","title":"\ud83d\udcbe Variables","text":"<p>Las variables en Java es una forma de almacenar informaci\u00f3n en nuestro ordenador. Definimos variables asign\u00e1ndoles un nombre. De igual manera se puede acceder a la informaci\u00f3n que guardar las variable, simplemente accediendo por el nombre que le hemos dado. Es el ordenador el que se encarga de averiguar d\u00f3nde se almacena internamente en la memoria RAM del ordenador.</p> <p></p> <p>Como su nombre indica \"variable\", se puede modificar el contenido que \u00e9sta almacena. Tenemos que  decirle qu\u00e9 tipo de informaci\u00f3n queremos guardar en nuestra variable y darle un nombre.</p> <p></p> <p>Existe diferentes tipos de informaci\u00f3n que podemos utilizar para definir nuestras variables. Se les conoce como tipos de datos o data types.</p> <p>Para definir una variable necesitamos:</p> <ul> <li>Tipo: especificar el tipo de datos(entero, real, letra, texto, booleano...)</li> <li>Identificador de variable: un nombre a nuestra variable </li> <li>Iniciar variable: opcionalmente, podemos agregar una expresi\u00f3n para inicializar la variable con un valor.</li> </ul>"},{"location":"ud1/131variables/#identificador-de-variable-o-nombre-reglas-para-el-nombrado-de-variables","title":"Identificador de variable o nombre. Reglas para el nombrado de variables","text":"<ul> <li> <p>Tiene que comenzar con una letra o '_', nunca con n\u00fameros.</p> </li> <li> <p>Puede contener n\u00fameros. No debe contener espacios en blanco.</p> </li> <li> <p>No debe ser muy largo y debe expresar algo en el contexto.</p> </li> <li> <p>No se pueden usar palabras reservadas.</p> </li> <li> <p>May\u00fasculas y min\u00fasculas se tratan diferente.</p> </li> </ul> <p></p> <p>Definimos nuestra primera variable en el programa de la siguiente forma:</p> <p></p> <p>La l\u00ednea que acabamos de escribir se conoce como sentencia de declaraci\u00f3n.</p>"},{"location":"ud1/131variables/#keywords-o-palabras-reservadas","title":"Keywords o Palabras reservadas","text":"<p>Son palabras reservadas del lenguaje. Es decir, son palabras que tienen un significado especial en Java y no puedes usarlas fuera de ese contexto. Ejemplos: public, class, void, static, etc. Existen 61 keywords en Java.</p> <p></p>"},{"location":"ud1/131variables/#vida-de-las-variables","title":"Vida de las variables","text":"<p>Las variables son memorias reservadas para almacenar valores en RAM. Estas posiciones de memoria se liberan tan pronto como termina la vida de la variable. Seg\u00fan la vida de las variables, hay tres tipos de Variables.</p> <p>1. Variables locales: La vida permanece dentro de un bloque donde se ha declarado.</p> <p>2. Variables de instancia: Declaradas dentro de la clase pero fuera de los m\u00e9todos. No deber\u00eda ser est\u00e1tico.</p> <p>3. Variables est\u00e1ticas: es como una variable global. Declarado como est\u00e1tico en la clase pero fuera de los m\u00e9todos.</p> <pre><code>    static int pi = 3.14;\n</code></pre>"},{"location":"ud1/131variables/#visibilidad","title":"Visibilidad","text":"<p>En las variables locales, su \u00e1mbito y uso se encuentra dentro del m\u00e9todo o bloque en el que se defini\u00f3 y se destruyen despu\u00e9s de la ejecuci\u00f3n del m\u00e9todo. Es decir, no se puede usar una variable local fuera del m\u00e9todo actual.</p> <p>A las variables de instancia se puede acceder solo a trav\u00e9s de objetos de la clase para la que se defini\u00f3.</p> <p>Un campo / variable est\u00e1tico pertenece a la clase y se cargar\u00e1 en la memoria junto con la clase. Se invocan sin crear un objeto. (Usando el nombre de la clase como referencia). Solo hay una copia de la variable est\u00e1tica disponible en toda la clase, es decir, el valor de la variable est\u00e1tica ser\u00e1 el mismo en todos los objetos. Puede definir una variable est\u00e1tica utilizando la palabra clave static.</p>"},{"location":"ud1/131variables/#mutacion-de-las-variables","title":"Mutaci\u00f3n de las variables","text":"<p>Supongamos que hemos ejecutado la siguiente l\u00ednea de c\u00f3digo:</p> <pre><code>int x = 5;\n</code></pre> <p>\u00bfC\u00f3mo podr\u00edamos sumar 6 al valor actualmente almacenado en <code>x</code>? Un enfoque ingenuo podr\u00eda ser probar esta l\u00ednea de c\u00f3digo:</p> <pre><code>    x + 6;\n</code></pre> <p>Sin embargo, esta l\u00ednea de c\u00f3digo es una expresi\u00f3n que da como resultado un valor: no hemos alterado el valor de x.</p> <pre><code>// Recuerda, x es una variable que contiene el valor 5\nx + 6; // se eval\u00faa como:\n5 + 6; // y luego da como resultado:\n11;\n\n// Pero 11; no es una declaraci\u00f3n que Java entienda,\n// entonces el compilador lanza un error cuando ve: x + 6;\n</code></pre> <p>Para aumentar el valor de <code>x</code> en 6, necesitamos reasignar el valor de <code>x</code> para que sea el resultado de <code>x + 6</code>:</p> <pre><code>x = x + 6; // se eval\u00faa como:\nx = 5 + 6; // y luego se suman los valores\nx = 11;// como resultado se asigna el valor 11 a x\n</code></pre> <p>Aqu\u00ed, hemos usado el valor de <code>x</code> para calcular y almacenar un nuevo valor en la variable <code>x</code>; en este caso, 11.</p>"},{"location":"ud1/131variables/#scope-ambito","title":"Scope - \u00c1mbito","text":"<p>El alcance o \u00e1mbito (scope) de una variable es la parte de un programa en la que existe. En Java, el alcance de una variable comienza donde se declara y termina cuando se alcanza la llave de cierre del bloque que la contiene.</p> <pre><code>public static void main(String[] args) {\n     int x = 5;\n     for (int i = 1; i &lt;= 5; i++) {\n        int y = 10;\n        System.out.println(x) // \u00a1x todav\u00eda est\u00e1 dentro del alcance aqu\u00ed!\n     }\n     System.out.println(x) // \u00a1x todav\u00eda est\u00e1 dentro del alcance aqu\u00ed tambi\u00e9n!\n}\n</code></pre> <ul> <li><code>x</code> est\u00e1 dentro del alcance entre su declaraci\u00f3n en la l\u00ednea 2 y la llave que la encierra en la l\u00ednea 8.</li> <li><code>y</code> est\u00e1 dentro del alcance entre su declaraci\u00f3n en la l\u00ednea 4 y la llave que la encierra en la l\u00ednea 6.</li> <li>Las variables de bucle est\u00e1n dentro del alcance entre sus bucles <code>for</code> { }. Entonces, <code>i</code> est\u00e1 dentro del alcance entre las l\u00edneas 3 - 6. Nota: Dos variables con el mismo nombre no pueden existir dentro del mismo \u00e1mbito (scope).</li> </ul>"},{"location":"ud1/131variables/#camelcase-nombrado-de-variables","title":"CamelCase: Nombrado de variables","text":"<p>CamelCase</p> <p>La nomenclatura camelCase es un estilo de escritura utilizado principalmente en programaci\u00f3n para nombrar variables, funciones, m\u00e9todos o propiedades. En este formato, las palabras se escriben juntas sin espacios, pero cada palabra (excepto la primera) comienza con una letra may\u00fascula, lo que facilita la lectura del nombre.</p> <p></p> <p>Por convenci\u00f3n, en Java se utiliza el nombrado de variables al estilo Camelcase</p> <p>Caracter\u00edsticas de CamelCase:</p> <ol> <li>Primera letra en min\u00fascula: La primera palabra siempre comienza con una letra min\u00fascula.</li> <li>Primera letra de las palabras subsecuentes en may\u00fascula: Todas las palabras siguientes empiezan con una letra may\u00fascula.</li> <li>No se usan espacios, guiones o subrayados: Las palabras se unen sin separadores.</li> </ol>"},{"location":"ud1/131variables/#ejemplos","title":"Ejemplos","text":"<ul> <li>nombreCompleto</li> <li>contadorDeClicks</li> <li>cantidadTotalDeItems</li> <li>esActivo</li> <li>notaMediaTercerTrimestre</li> </ul>"},{"location":"ud1/132sentencias/","title":"\ud83d\udcbe Sentencias","text":"<p>Hemos comentado que un programa es un conjunto de instrucciones. Estas instrucciones se llaman sentencias o statements en ingl\u00e9s. Una sentencia es un segmento de c\u00f3digo que realiza una acci\u00f3n en el programa. A medida que se ejecuta un programa, decimos que ejecuta sentencias, lo que significa que lleva a cabo las acciones especificadas por esas sentencias. En nuestro programa Hello World, tenemos un statement en la l\u00ednea 4 y 6. La regla en Java es que las sentencias deben terminar con un punto y coma. Si se olvida, se producir\u00eda un error de sintaxis. </p>"},{"location":"ud1/132sentencias/#sentencias-de-declaracion","title":"Sentencias de declaraci\u00f3n","text":"<p>Se usan para definir una variable de un tipo de dato en particular. En Java, una variable debe declararse antes de que pueda usarse en un programa. De no hacerlo, se producir\u00eda un error de sintaxis. En su forma m\u00e1s simple una declaraci\u00f3n incluye el tipo de datos y el nombre de la variable. Opcionalmente se puede establecer la variable a cierto valor. Es decir, se dice que se ha inicializado.</p> <pre><code>Ejemplos:\n   int numero;\n   int a = 3; //se crea la variable a y se le asigna el valor 3\n   int dia;\n</code></pre>"},{"location":"ud1/132sentencias/#sentencias-de-asignacion","title":"Sentencias de asignaci\u00f3n","text":"<p>Una sentencia de asignaci\u00f3n es una sentencia que almacena (asigna) un valor en una variable. Una sentencia de asignaci\u00f3n utiliza el signo igual (=) como operador de asignaci\u00f3n. En su forma m\u00e1s simple, tiene una variable en el lado izquierdo del signo igual y alg\u00fan tipo de valor en el lado derecho.</p> <pre><code>Ejemplos:\n    numero = 6; //asigno el valor 6 a la variable numero\n    a = 0;\n    dia = 22;\n</code></pre> <p>En el siguiente ejemplo, hay variables tanto a la izquierda como a la derecha del operador de asignaci\u00f3n (=). Pero tienen un significado muy diferente. La variable de la derecha (num2) se trata como un valor. Si esa variable almacena 20, entonces ese es su valor. De hecho, cualquier cosa que ocurra en el lado derecho de un operador de asignaci\u00f3n se trata como un valor. La variable de la izquierda (num1) se trata como una ubicaci\u00f3n de memoria. Es donde se almacenar\u00e1 el valor 20 como resultado de la ejecuci\u00f3n de esta declaraci\u00f3n. El efecto de esta declaraci\u00f3n es copia el valor almacenado en num2 en num1, como se ilustra en la siguiente imagen.</p> <pre><code>Ejemplo\n    //se crean las variables\n    int num1 = 10;\n    int num2 = 20;\n\n    num1 = num2; //se copia el valor de num2 a la variable num1\n</code></pre> <p></p>"},{"location":"ud1/132sentencias/#challenge","title":"Challenge","text":"<p>Question</p> <p>En el programa Hello World, imprime por pantalla la variable miPrimerEntero que hemos creado.</p>"},{"location":"ud1/132sentencias/#challenge2","title":"Challenge2","text":"<p>Question</p> <p>En el programa Hello World, crea las siguientes variables adicionales justo debajo de la declaraci\u00f3n \"int miPrimerEntero = 7;\" en el programa:</p> <ul> <li>num1 de tipo int y con un valor de 10.</li> <li>num2 de tipo int y con un valor de 8.</li> <li>y una tercera total que sea la suma de las anteriores.</li> <li>imprime por pantalla la variable total.</li> </ul>"},{"location":"ud1/132sentencias/#paquetes-en-java-java-packages","title":"Paquetes en Java - Java Packages","text":"<p>Un paquete es una forma de organizar nuestros proyectos Java. Se pueden ver como carpetas dentro de la estructuraci\u00f3n interna del proyecto.</p> <p></p> <p>Los paquetes son el mecanismo que usa Java para facilitar la modularidad del c\u00f3digo. Un paquete puede contener una o m\u00e1s definiciones de interfaces y clases, distribuy\u00e9ndose habitualmente como un archivo. Para utilizar los elementos de un paquete es necesario importar este en el m\u00f3dulo de c\u00f3digo en curso, usando para ello la sentencia import.</p> <p>IntelliJ nos ofrece la opci\u00f3n de automatizar esto cuando creamos un proyecto, simplemente seleccionando la opci\u00f3n: </p>"},{"location":"ud1/142noprimitive/","title":"\ud83d\udcbe No primitivos u objetos","text":"<p>En Java, los tipos de datos no primitivos son los tipos de datos de referencia. </p> <p>Los datos primitivos, la variable y el datos se almacenan en la memoria en la pila(stack), sin embargo, los datos no primitivos, la variable de un tipo no primitivo o es null(ausencia de valor) o apunta al dato en la parte de la memoria Heap(mont\u00f3n)</p> <p></p> <p>Todos los tipos de datos no primitivos se implementan utilizando conceptos de objeto. Cada variable del tipo de datos no primitivo es un objeto. </p> <p>Los tipos de datos no primitivos pueden utilizar m\u00e9todos adicionales para realizar determinadas operaciones. </p> <p>El valor predeterminado de la variable de tipo de datos no primitivos es nulo(null).</p> <p>Es importante comprender que los tipos no primitivos guardan la direcci\u00f3n a la posici\u00f3n de memoria donde se encuentra el objeto</p>"},{"location":"ud1/142noprimitive/#valor-null","title":"Valor null","text":"<p>En Java, null es un valor especial que representa la ausencia de un valor o la no inicializaci\u00f3n de un objeto. Es un literal que se puede asignar a una variable de tipo referencia (como clases y arrays) para indicar que esa variable no apunta a ning\u00fan objeto en la memoria</p> <pre><code>//la variable s1 apunta a un objeto, pero la variable s2 no apunta a ning\u00fan contenido\nString s1=\"Hola mundo\";\nString s2=null;\n</code></pre> <p></p>"},{"location":"ud1/142noprimitive/#enum-en-java","title":"Enum en Java","text":"<p>El tipo enumerado es un tipo de datos especial que permite que una variable sea un conjunto de constantes predefinidas. Sirven para definir grupos de constantes como valores posibles de una variable. La variable debe ser igual a uno de los valores que se han predefinido para ella.</p> <p>Debido a que son constantes, los nombres de los campos del tipo enum deber\u00edan estar en letras may\u00fasculas.</p> <p>En Java, se define un enumerado utilizando la palabra clave enum seguido del nombre siguiendo la convenci\u00f3n del nombrado de clases. Primera letra en may\u00fascula y CamelCase.</p> <p>El objetivo principal es la acotaci\u00f3n de datos y la claridad de lectura del c\u00f3digo</p> <p>Para crear un enum en Java, bot\u00f3n derecho en el paquete \u2192 new Java class y seleccionamos enum.</p> <p>Ejemplo de enumerado:</p> <pre><code>  public enum PuntosCardinales {\n    NORTE, SUR, ESTE, OESTE\n  }\n\n  public class Main {\n\n    public static void main(String[] args) {\n      PuntosCardinales myVar = PuntosCardinales.ESTE;\n      System.out.println(myVar);//Imprime \"ESTE\"\n    }\n\n  }\n</code></pre> <p>Otro ejemplo</p> <pre><code>public enum DiaSemana {\n        LUNES, MARTES,MIERCOLES,JUEVES,VIERNES,SABADO,DOMINGO\n    }\n\npublic static void main(String[] args) {\n\n    DiaSemana diaFavorito=DiaSemana.SABADO;\n\n    System.out.println(diaFavorito.name());//SABADO\n    System.out.println(diaFavorito);//SABADO\n    System.out.println(diaFavorito.ordinal());//5\n    DiaSemana peorDia=DiaSemana.LUNES;\n    System.out.println(diaFavorito==peorDia);//podemos hacer comparaciones\n\n    }\n</code></pre> <p>En los switch permiten una mejor legibilidad del c\u00f3digo</p> <pre><code>public static void main(String[] args) {\n  DiaSemana dia = DiaSemana.MARTES;\n\n  switch (dia) {\n      case LUNES:\n      case MARTES:\n      case MIERCOLES:\n      case JUEVES:\n      case VIERNES:\n          System.out.println(\"A trabajar...\");\n          break;\n      case SABADO:\n      case DOMINGO:\n          System.out.println(\"A descansar...\");\n  }\n}\n</code></pre>"},{"location":"ud1/143string/","title":"\ud83d\udcbe String en Java","text":"<p>Un String es un tipo de dato no primitvo que, en Java representa una cadena de caracteres no modificable. Todos los literales de la forma \"cualquier texto\", es decir, literales entre comillas dobles, que aparecen en un programa java se implementan como objetos de la clase String.</p> <p>A diferencia de muchos objetos vimos que un String se puede crear sin la palabra new.</p> <p>String text = \"hola\";</p>"},{"location":"ud1/143string/#creacion-de-string","title":"Creaci\u00f3n de String","text":"<p>Se puede crear un String de varias formas.</p> <pre><code>    String texto = \"Severo Ochoa\";\n\n    //Utilizando new\n    String texto2 = new String(\"Severo Ochoa\");\n\n    //Utilizando el operador concatenaci\u00f3n +\n    String s2 = text + \" 2021\";      //s2 contiene \"Severo Ochoa 2021\"\n</code></pre>"},{"location":"ud1/143string/#string-cadena-de-caracteres","title":"String - Cadena de caracteres","text":"<p>String es una clase integrada en el lenguaje Java ampliamente utilizada y definido en el paquete java.lang. Representa cadenas de caracteres y se utilizan para almacenar varios atributos como nombre de usuario, contrase\u00f1a, etc. Los String son inmutables; es decir, no se pueden modificar una vez creados. Siempre que se modifica un objeto String, en realidad se crea uno nuevo String.</p> <p>Existen varias formas para crear un String:</p> <pre><code>    String texto = \"Severo Ochoa\";\n    String texto2 = new String(\"Severo Ochoa\");\n</code></pre>"},{"location":"ud1/143string/#asignacion-de-memoria-de-objetos-string","title":"Asignaci\u00f3n de memoria de objetos String","text":"<p>La memoria se divide en dos partes, el String Pool y la memoria Heap.</p> <p></p> <p>Veamos como funcionar\u00eda para la imagen anterior.</p> <ol> <li> <p>Siempre que creamos un String con comillas dobles, se almacenan en String Pool. String Pool almacena el \u00fanico valor en \u00e9l. Es por eso que, String s1 = \"blogs\" se almacenan como el primer valor en el String Pool.</p> </li> <li> <p>Siempre que creamos un objeto usando la palabra clave new, se almacena en la memoria Heap pero fuera del String Pool. Aqu\u00ed se puede almacenar valores duplicados ya que pertenece a diferentes objetos. Entonces, para la declaraci\u00f3n String s2 = new String(\u201cblogs\u201d), aunque el valor de s1 y s2 es el mismo, s2 se almacenar\u00e1 fuera del String Pool.</p> </li> <li> <p>Cuando creamos otro String usando comillas dobles, primero verifica todos los valores en el String Pool y si coincide con alguno se asigna la misma ubicaci\u00f3n asignada a otro objeto de referencia. Por lo tanto, String s3 = \u201dblogs\u201d no agregar\u00e1 una nueva entrada en el String Pool.</p> </li> <li> <p>Pero si creamos otro objeto con un valor existente usando la palabra clave new. Asignar\u00e1 nueva memoria al nuevo objeto en el Heap. Por lo tanto, a String s4 = new String (\"blogs\") se le asignar\u00e1 nueva memoria.</p> </li> <li> <p>Ahora, si manipulamos el valor en s1 usando s1 = \u201dNew\u201c + s1, no actualizar\u00e1 la entrada o referencia existente de s1. Este proceso crear\u00e1 una nueva entrada en el String Pool con el valor \"New blogs\" y la referencia de memoria cambiar\u00eda para el objeto s1.</p> </li> </ol>"},{"location":"ud1/143string/#java-string-class-methods","title":"Java String Class Methods","text":"<p>La clase java.lang.String proporciona muchos m\u00e9todos \u00fatiles para realizar operaciones en la secuencia de valores char.</p>"},{"location":"ud1/143string/#el-operador-concatenacion","title":"El operador concatenaci\u00f3n","text":"<p>La clase proporciona el operador + (concatenaci\u00f3n) para unir dos o m\u00e1s String. El resultado de aplicar este operador es un nuevo String concatenaci\u00f3n de los otros. Por ejemplo, si tenemos dos String b y c:</p> <pre><code>String b = \"Ordenador\";\nString c = \" Port\u00e1til\";\n</code></pre> <p></p> <p>La operaci\u00f3n</p> <pre><code>b = b + c;\n</code></pre> <p>Crea un nuevo String que se incluye en el String Pool:</p> <p></p>"},{"location":"ud1/143string/#concatenacion-con-otros-tipos-de-datos","title":"Concatenaci\u00f3n con otros tipos de datos","text":"<p>Cuando concatenas una cadena con otros tipos de datos, Java convierte autom\u00e1ticamente los tipos no cadena a su representaci\u00f3n de cadena.</p> <p>Cuando concatenas un n\u00famero con una cadena, Java convierte el n\u00famero a una cadena de caracteres y luego lo une a la cadena original.</p> <pre><code>int numero = 10;\ndouble decimal = 5.5;\nString texto = \"El resultado es: \";\n\nString resultado = texto + numero + \" y \" + decimal;\nSystem.out.println(resultado);\n//imprime  \"El resultado es: 10 y 5.5\"\n</code></pre> <p></p>"},{"location":"ud1/143string/#operador-suma-vs-operador-concatenacion","title":"Operador suma vs Operador concatenaci\u00f3n","text":"<p>En Java, cuando se mezcla la suma con la concatenaci\u00f3n (operador +), el comportamiento depende del orden de las operaciones. El operador + puede funcionar tanto como un operador de suma para n\u00fameros como un operador de concatenaci\u00f3n para cadenas.</p> <p>El compilador, si no hay par\u00e9ntesis, opera de izquierda a derecha, y el resultado puede variar de nuestras intenciones. Si se encuentra con un String, los elementos de la derecha los transforma a String, pero si los n\u00fameros est\u00e1n a la izquierda, realiza primero las operaciones de suma</p> <pre><code>//Muestra \"suma = 23\"\nSystem.out.println(\"Suma = \"+2+3);\n\n//Muestra \"suma = 5\". Primero opera el contenido entre par\u00e9ntesis\nSystem.out.println(\"Suma = \"+(2+3));\n\n//Muestra \"5 es la suma\"\nSystem.out.println(2+3+\" es la suma\");\n</code></pre>"},{"location":"ud1/143string/#indices","title":"\u00cdndices","text":"<p>Cada uno de los caracteres que forman un String son del tipo primitivo char. Los caracteres de un string est\u00e1n numerados internamente con \u00edndices empezando desde el cero:</p> <p></p> <p>El primer car\u00e1cter tiene \u00edndice 0 y el \u00faltimo tiene la longitud del string menos 1.</p>"},{"location":"ud1/143string/#metodos-de-la-clase-string","title":"M\u00e9todos de la clase String","text":"<p>La clase String proporciona m\u00e9todos para el tratamiento de las cadenas de caracteres: acceso a caracteres individuales, buscar y extraer una subcadena, copiar cadenas, convertir cadenas a may\u00fasculas o min\u00fasculas, etc.</p> <p></p> <p>Para acceder a alguno de los m\u00e9todos siguientes utilizamos la notaci\u00f3n \".\"</p> <pre><code>  String texto = \"Clase\";\n  int longitud = texto.length(); //devuelve 5\n</code></pre> <p></p> <p>Tip</p> <p>Para m\u00e1s informaci\u00f3n consulta la documentaci\u00f3n oficial de la clase String</p>"},{"location":"ud1/143string/#comparar-strings","title":"Comparar Strings","text":"<p>Los operadores relacionales como == o &lt; &gt; NO se utilizan para comparar Strings, aunque el c\u00f3digo compile no es correcto, ya que == compara objetos, y devolver\u00eda falso aunque dos strings tuvieran el mismo texto puesto que son objetos diferentes.</p> <p>Para comparar strings utilizamos el m\u00e9todo equals.</p> <pre><code>  String name = \"Patri\";\n\n  if (name.equals(\"Patri\")) {\n    System.out.println(\"Coincide.\");\n  }\n</code></pre> <p>La siguiente tabla muestra los m\u00e9todos que se utilizan para comparar Strings.</p> <p></p>"},{"location":"ud1/143string/#char-dentro-de-string","title":"char dentro de String","text":"<p>Como se ha comentado, un String est\u00e1 compuesto de caracteres tipo char.</p> <p>Para acceder a los caracteres dentro de un String usamos el m\u00e9todo charAt.</p> <p>Se puede usar la concatenaci\u00f3n + para concatenar char con String.</p> <pre><code>String food = \"cookie\";\nchar firstLetter = food.charAt(0); // 'c'\nSystem.out.println(firstLetter + \" is for \" + food); \n</code></pre> <p>Tambi\u00e9n podemos recorrer el String con un bucle for e imprimir cada uno de los caracteres que lo forman.</p> <pre><code>String major = \"CSE\";\nfor (int i = 0; i &lt; major.length(); i++) {\n  char c = major.charAt(i);\n  System.out.println(c);\n}\n</code></pre> <pre><code>OUTPUT\nC\nS\nE\n</code></pre>"},{"location":"ud1/143string/#char","title":"char","text":"<p>A todos los valores char se les asigna un n\u00famero internamente por el ordenador, son los llamados valores ASCII. Por ejemplo:</p> <p>el car\u00e1cter 'A' es 65 en c\u00f3digo ASCII</p> <p>el car\u00e1cter 'a' es 97 en c\u00f3digo ASCII</p> <p>Mezclar tipos de datos char e int autom\u00e1ticamente cause una conversi\u00f3n en entero. Por ejemplo:</p> <p>'a' + 10 \u2192 devuelve 107.</p> <p>Para convertir un entero en su equivalente a car\u00e1cter (char) har\u00edamos:</p> <p>(char) ('a' + 2) \u2192 devuelve 'c'.</p>"},{"location":"ud1/143string/#diferencias-entre-char-y-string","title":"Diferencias entre char y String","text":"<ul> <li>String es un objeto, por tanto, contiene m\u00e9todos.</li> <li>char es un tipo de dato primitivo, no puedes llamar a m\u00e9todos con \u00e9l.</li> <li>String utiliza comillas dobles.</li> <li>char utiliza comillas simples.</li> <li>No se puede comparar un String usando operadores relacionales.</li> <li>Si se puede comparar un char usando operadores relacionales: 'a' &lt; 'b', 'X' == 'X', ...</li> </ul>"},{"location":"ud1/143string/#secuencia-de-escape","title":"Secuencia de escape","text":"<p>Un car\u00e1cter precedido por una barra invertida () es una secuencia de escape y tiene un significado especial para el compilador. La siguiente tabla muestra las secuencias de escape de Java:</p> <p></p> <p>Nos permiten representar tabulaciones, saltos de l\u00ednea, el propio caracter <code>\\</code> o <code>\"</code></p> <pre><code>/*imprime:\nJava\nEs un lenguaje \"Incre\u00edble\"\nTengo que trabajar duro para aprenderlo\n  */        \nString miTexto=\"Java\\nEs un lenguaje \\\"Incre\u00edble\\\"\\nTengo que trabajar duro para aprenderlo\";\nSystem.out.println(miTexto);\n</code></pre> <p>Las versiones actuales de Java, nos permiten definir texto sin necesidad de los caracteres scape utilizando <code>\"\"\"</code> <pre><code>/*imprime:\nJava\nEs un lenguaje \"Incre\u00edble\"\nTengo que trabajar duro para aprenderlo\n  */        \nString miTexto= \"\"\"\n        Java\n        Es un lenguaje \"Incre\u00edble\"\n        Tengo que trabajar duro para aprenderlo\n        \"\"\";\nSystem.out.println(miTexto);\n</code></pre></p>"},{"location":"ud1/14datatypejava/","title":"\ud83d\udcbe Tipos de datos","text":""},{"location":"ud1/14datatypejava/#introduccion","title":"Introducci\u00f3n","text":"<p>Un   ordenador  est\u00e1  compuesto  fundamentalmente  por  circuitos  electr\u00f3nicos  digitales.Los datos circulan por estos circuitos en forma de impulsos el\u00e9ctricos.</p> <p>De forma muy simplificada podemos decir que por un circuito pasa o no pasa corrientey esto lo podemos representar con dos d\u00edgitos: 0 y 1.</p> <p>Todos los datos e informaci\u00f3n que contiene un ordenador, est\u00e1n representados de forma interna mediante secuencias de ceros y unos. Un sistema de representaci\u00f3n que utiliza solamente dos s\u00edmbolos ( 0 , 1 ) se llama sistema binario. Por tanto, los datos tal y como los expresamos de forma natural se deben codificar de forma interna en binario para que puedan ser tratados por el ordenador.</p> <p>El sistema binario utiliza solamente dos d\u00edgitos ( 0 y 1 ) llamados bits. </p> <p>Utilizando 2 bits podemos representar 4 valores: 00, 01, 10, 11.</p> <p>Utilizando 3 bits podemos representar 8 valores: 000, 001, 010, 011, 100, 101, 110, 111.</p> <p>Utilizando 4 bits podemos representar 16 valores: 0000, 0001, 0010, 0011, 0100, 0101, 0110, 0111...</p> <p>En general, utilizandon bits podremos representar 2n valores. Ocho bits forman un byte. El byte es la unidad b\u00e1sica de medida de la informaci\u00f3n. Un byte es la cantidad m\u00e1s peque\u00f1a de informaci\u00f3n que el ordenador puede manejar. </p> <p>Con un byte se pueden representar 28= 256 caracteres.En el interior del ordenador los datos se transmiten y almacenan en grupos de bytes llamados palabras.La longitud de palabra depende de cada tipo de ordenador: 8, 16, 32, 64.</p> <p></p> <p>Un tipo de datos es un conjunto de valores y un conjunto de operaciones definidas en ellos.</p> <p></p> <p>Para que los datos formen parte del procesamiento de la informaci\u00f3n, deben encontrarse en la memoria principal o memoria RAM. Y ah\u00ed se representan de forma l\u00f3gica a trav\u00e9s de una estructura de datos, la cual define un contenedor para el dato </p> <p>Se pueden clasificar en primitivos y objetos. </p>"},{"location":"ud1/14datatypejava/#primitivos","title":"Primitivos","text":"<p>Los primitivos son los m\u00e1s b\u00e1sicos y fundamentales, vienen integrados en Java. Especifican el tipo de valor almacenado en una variable y el tama\u00f1o de la memoria. Hay 8 tipos primitivos de datos integrados en el lenguaje Java. Estos incluyen: int, byte, short, long, float, double, boolean y char.</p> <p></p> <p>Notaci\u00f3n cient\u00edfica</p> <ul> <li>La notaci\u00f3n cient\u00edfica es una forma compacta de expresar n\u00fameros grandes o peque\u00f1os. Est\u00e1 escrita en la forma N\u00d710^e donde <code>N</code> es la mantisa y <code>e</code> el exponente</li> <li>Los n\u00fameros grandes tienen exponentes positivos, y los peque\u00f1os, exponentes negativos.</li> </ul> <p></p> <p>en Java se representan de la siguiente forma</p> <pre><code>double numeroGrande = 1.23e5;  // 1.23 x 10^5 = 123000.0\ndouble numeroPequeno = 4.56e-4; // 4.56 x 10^-4 = 0.000456\n</code></pre>"},{"location":"ud1/14datatypejava/#byte","title":"byte","text":"<p>Como su propio nombre denota, emplea un solo byte (8 bits) de almacenamiento. Esto permite almacenar valores en el rango [-128, 127]. Raramente se usa. Ocupa menos memoria y puede ser m\u00e1s r\u00e1pido accedido.</p> <pre><code>  byte b = 2;\n</code></pre>"},{"location":"ud1/14datatypejava/#short","title":"short","text":"<p>Usa el doble de almacenamiento que el anterior, es decir, ocupa 16 bits [-32.768, 32.767].</p> <pre><code>  short s = 3467;\n</code></pre>"},{"location":"ud1/14datatypejava/#int","title":"int","text":"<p>Emplea 4 bytes (32 bits) de almacenamiento y es el tipo de dato entero m\u00e1s empleado. Necesita cuatro veces el espacio que ocupa un byte. Es el entero predeterminado usado en Java.</p> <pre><code>        int maxValor = 2147483647;\n        // after java 7 and higher\n        int maxValue = 2_147_483_647;\n</code></pre>"},{"location":"ud1/14datatypejava/#long","title":"long","text":"<p>Es el tipo entero de mayor tama\u00f1o, 8 bytes (64 bits). Para definir un long, tenemos que hacerlo de la siguiente forma:</p> <pre><code>  long myLongNumber = 500L;\n</code></pre>"},{"location":"ud1/14datatypejava/#float","title":"float","text":"<p>Tiene una parte flotante que sirve para expresar n\u00fameros decimales. Es de simple precisi\u00f3n (formato y cantidad de espacio que ocupa) porque ocupa 32 bits. No se recomienda mucho su uso.</p> <pre><code>  float f = 4;\n  float f = 4f; //tambi\u00e9n v\u00e1lida\n</code></pre>"},{"location":"ud1/14datatypejava/#double","title":"double","text":"<p>Es un n\u00famero de precisi\u00f3n doble y ocupa 64 bits. Es el flotante predeterminado en Java. Se recomienda su uso. Muchas librer\u00edas internas de Java, relacionadas con operaciones matem\u00e1ticas, usan double.</p> <pre><code>  double d = 5;\n  double d = 5d; //tambi\u00e9n v\u00e1lida\n  //en notaci\u00f3n cient\u00edfica\n  double numeroGrande = 1.23e5;  // 1.23 x 10^5 = 123000.0\n  double numeroPequeno = 4.56e-4; // 4.56 x 10^-4 = 0.000456\n</code></pre>"},{"location":"ud1/14datatypejava/#char","title":"char","text":"<p>Se utiliza para almacenar caracteres (letras, n\u00fameros, signos, etc.) individuales. Ocupa 2 bytes en memoria (16 bits). Permite almacenar caracteres Unicode. Unicode es un est\u00e1ndar de codificaci\u00f3n internacional que nos permite representar diferentes idiomas; y la forma en que funciona es usando una combinaci\u00f3n de los dos bytes que un char ocupa en la memoria, que puede representar hasta 65535 diferentes tipos de caracteres. Unicode table.</p> <pre><code>char c = 'P';\nchar u = '\\u00A2';//print unicode character\nSystem.out.println(u);\nchar sonrie='\\u263A';//emoticono sonriente \u263a\nSystem.out.println(\"Emoji: \" + sonrie);\n//combinaci\u00f3n Unicode\nString emojiModerno = \"\\uD83D\\uDE0A\";  // \ud83d\ude0a\nSystem.out.println(\"Emoji moderno: \" + emojiModerno);\n</code></pre> <p>el par de sustitutos (surrogate pair) Unicode</p> <p>Java utiliza la codificaci\u00f3n UTF-16, por lo que algunos caracteres como los emojis modernos necesitan dos caracteres Unicode (surrogate pairs) para representarse.</p> <p>\\uD83D\\uDE0A es el par de sustitutos (surrogate pair) que representan el c\u00f3digo Unicode U+1F60A (\ud83d\ude0a)</p>"},{"location":"ud1/14datatypejava/#secuencia-de-escape","title":"Secuencia de escape","text":"<p>Un car\u00e1cter precedido por una barra invertida () es una secuencia de escape y tiene un significado especial para el compilador. La siguiente tabla muestra las secuencias de escape de Java:</p> <p></p> <p>Nos permiten representar tabulaciones, saltos de l\u00ednea, el propio caracter <code>\\</code> o <code>\"</code></p> <pre><code>/*imprime:\nJava\nEs un lenguaje \"Incre\u00edble\"\nTengo que trabajar duro para aprenderlo\n  */        \nString miTexto=\"Java\\nEs un lenguaje \\\"Incre\u00edble\\\"\\nTengo que trabajar duro para aprenderlo\";\nSystem.out.println(miTexto);\n</code></pre> <p>Las versiones actuales de Java, nos permiten definir texto sin necesidad de los caracteres scape utilizando <code>\"\"\"</code> <pre><code>/*imprime:\nJava\nEs un lenguaje \"Incre\u00edble\"\nTengo que trabajar duro para aprenderlo\n  */        \nString miTexto= \"\"\"\n        Java\n        Es un lenguaje \"Incre\u00edble\"\n        Tengo que trabajar duro para aprenderlo\n        \"\"\";\nSystem.out.println(miTexto);\n</code></pre></p>"},{"location":"ud1/14datatypejava/#boolean","title":"boolean","text":"<p>En Java, el tipo de dato boolean es un tipo primitivo que puede almacenar uno de dos valores: true o false. Este tipo de dato es utilizado principalmente en decisiones de control de flujo</p> <p></p> <p><pre><code>boolean esVerdadero = true;\nboolean esFalso = false;\n\nSystem.out.println(\"Valor de esVerdadero: \" + esVerdadero);\nSystem.out.println(\"Valor de esFalso: \" + esFalso);\n/*imprime:\nValor de esVerdadero: true\nValor de esFalso: false\n*/\n</code></pre> En los lenguajes de programaci\u00f3n tenemos el tipo de datos boolean que nos permite tomar diferentes caminos en el algoritmo. Es necesario dominar las expresiones con resultado booleano para saber el camino que toma el algoritmo.</p> <p>Un ejemplo puede ser un videojuego en el que tenemos que mostrar el enemigo cuando muere de una forma o si est\u00e1 vivo de otra. Podemos tener una variable booleana asociada al enemigo llamada estaMuerto y en cada fotograma ir comparando la variable para saber la  imagen a mostrar</p> <p></p>"},{"location":"ud1/14datatypejava/#wrapper-classes-clases-contenedores-o-envolventes","title":"Wrapper classes (clases contenedores o envolventes)","text":"<p>Las clases contenedoras proporcionan una forma de utilizar tipos de datos primitivos como objetos. </p> <p></p> <p>En Java, tenemos una Wrapper class para cada uno de los 8 tipos de datos primitivos. </p> Primitive data type Wrapper class byte Byte short Short int Integer long Long float Float double Double boolean Boolean char Character <p>Las clases contenedoras tienen gran n\u00famero de m\u00e9todos que nos ayudar\u00e1n en nuestros programas:</p> <pre><code>//minimo valor de un entero\nint minimoValorInt = Integer.MIN_VALUE;\n//transforma el string al tipo correspondiente\nint edad=Integer.parseInt(\"12\");\nfloat nota=Float.parseFloat(\"5.5\");\n</code></pre> <p>Consulta la Api de Java</p> <p>Busca  la clase Integer y comienza a habituarte a la documentaci\u00f3n t\u00e9cnica viendo sus m\u00e9todos y propiedades</p> <p>https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html</p>"},{"location":"ud1/14datatypejava/#conversion-de-tipos","title":"Conversi\u00f3n de tipos","text":"<p>La conversi\u00f3n de tipos en Java se refiere al proceso de cambiar el tipo de datos de una variable o expresi\u00f3n a otro tipo compatible. Esto es \u00fatil cuando necesitas realizar operaciones con variables de diferentes tipos o cuando deseas asignar el valor de una variable a otra de un tipo diferente.</p> <p></p> <p>Java ofrece dos tipos principales de conversi\u00f3n de tipos:</p>"},{"location":"ud1/14datatypejava/#conversion-implicita-casting-implicito","title":"Conversi\u00f3n impl\u00edcita (Casting impl\u00edcito)","text":"<ul> <li>Ocurre autom\u00e1ticamente cuando no hay p\u00e9rdida de datos y no se requiere intervenci\u00f3n del programador.</li> <li>Sucede cuando est\u00e1s convirtiendo un tipo de dato \"m\u00e1s peque\u00f1o\" en un tipo \"m\u00e1s grande\"</li> </ul> <p>Por ejemplo, convertir un int a double:</p> <pre><code>    int entero = 42;\n    double decimal = entero; // Conversi\u00f3n impl\u00edcita\n</code></pre>"},{"location":"ud1/14datatypejava/#conversion-explicita-casting-explicito","title":"Conversi\u00f3n expl\u00edcita (Casting expl\u00edcito)","text":"<ul> <li>El casting expl\u00edcito es necesario cuando intentas convertir un tipo m\u00e1s grande a un tipo m\u00e1s peque\u00f1o, o cuando est\u00e1s trabajando con tipos que no son directamente compatibles. En estos casos, debes decirle expl\u00edcitamente a Java que realice la conversi\u00f3n. El casting expl\u00edcito puede resultar en p\u00e9rdida de datos si no se tiene cuidado.</li> <li>Puedes realizar una conversi\u00f3n expl\u00edcita colocando el tipo de destino entre par\u00e9ntesis antes de la variable o expresi\u00f3n que deseas convertir.</li> </ul> <p><pre><code>   double decimal = 9.75;\n   int entero = (int) decimal; // Conversi\u00f3n expl\u00edcita\n</code></pre> Aqu\u00ed se est\u00e1 forzando la conversi\u00f3n de un double a un int. El resultado es que el valor 9.75 se convierte en 9, perdiendo la parte decimal.</p> <p>Tambi\u00e9n es crucial asegurarse de que las conversiones sean seguras y no generen excepciones en tiempo de ejecuci\u00f3n.</p>"},{"location":"ud1/14datatypejava/#que-sucede-internamente","title":"\u00bfQu\u00e9 sucede internamente?","text":"<p>Truncado decimal: Cuando se convierte un n\u00famero decimal a un entero, Java simplemente elimina la parte decimal sin redondear. Solo queda la parte entera del n\u00famero.</p> <pre><code>float valorDecimal = 9.35f;\nint valorEntero = (int) valorDecimal; //trunca la parte decimal\nSystem.out.println(valorEntero);//imprime 9\n</code></pre> <p>Desbordamiento de bits: Si el valor de un tipo m\u00e1s grande no cabe en el tipo m\u00e1s peque\u00f1o, Java utiliza solo los bits que puede manejar el tipo m\u00e1s peque\u00f1o, y el resto se descarta, lo que puede cambiar completamente el valor final. Esto sucede porque los tipos num\u00e9ricos en Java est\u00e1n representados en binario y se utilizan los bits que encajan en el tama\u00f1o del nuevo tipo. </p> <p>Esto puede llevar a errores inesperados</p> <pre><code>int valorEntero = 130; // En binario(32bits): 0000 0000 0000 0000 0000 0000 1000 0010\nbyte valorByte = (byte) valorEntero; // Solo caben 8 bits en un byte\nSystem.out.println(valorByte); // Imprime -126\n</code></pre> <p>La representaci\u00f3n en binario de 130 es 1000 0010. Un byte solo puede almacenar 8 bits, por lo que Java toma los \u00faltimos 8 bits, que corresponden a 1000 0010, lo cual equivale a -126 en la representaci\u00f3n de complemento a dos.</p> <p>Complemento a 2</p> <p>El complemento a 2 es un sistema de representaci\u00f3n de n\u00fameros enteros en binario que permite manejar tanto n\u00fameros positivos como negativos de manera eficiente en los sistemas digitales</p> <p>\u00bfC\u00f3mo funciona el complemento a 2?</p> <p>En el sistema de complemento a 2:</p> <p>N\u00fameros positivos: Se representan de la misma manera que en binario normal. N\u00fameros negativos: Se obtienen tomando el complemento a 2 del n\u00famero positivo correspondiente. Esto implica invertir todos los bits (complemento a 1) y luego sumarle 1 al resultado.</p> <p>Ejemplo para -126</p> <ul> <li>Escribe el n\u00famero positivo equivalente (126) en binario usando 8 bits.</li> </ul> <p>0111 1110</p> <ul> <li>Invierte los bits (complemento a 1).</li> </ul> <p>1000 0001</p> <ul> <li>Suma 1 al resultado para obtener el complemento a 2.</li> </ul> <p>1000 0001 + 1 = 1000 0010</p>"},{"location":"ud1/14datatypejava/#overflow-y-underflow","title":"Overflow y Underflow","text":""},{"location":"ud1/14datatypejava/#overflow","title":"Overflow","text":"<p>En Java, un overflow en un tipo de dato ocurre cuando un valor excede el rango m\u00e1ximo o m\u00ednimo que puede almacenar una variable de ese tipo. En el caso de un int en Java, que utiliza 32 bits, su rango es de:</p> <p>Valor m\u00ednimo: = -2,147,483,648</p> <p>Valor m\u00e1ximo:= 2,147,483,647</p> <p>Cuando se produce un overflow, el valor \"rebota\" y se convierte en el valor m\u00ednimo o m\u00e1ximo del tipo de dato, dependiendo de si el valor supera el rango superior o inferior.</p> <pre><code>int valorMaximo = Integer.MAX_VALUE; // 2,147,483,647\nSystem.out.println(\"Valor m\u00e1ximo: \" + valorMaximo);\n\n// Provocamos el overflow\nint overflow = valorMaximo + 1;\nSystem.out.println(\"Valor despu\u00e9s del overflow: \" + overflow);\n//imprime \"Valor despu\u00e9s del overflow: -2147483648\"\n</code></pre> <p>Pero los resultados pueden ser inesperados aparentemente aleatorio. Si multiplicamos dos n\u00fameros muy grandes y guardamos en un int</p> <pre><code>int valor = 1_000_000;\nSystem.out.println(\"Valor original: \" + valor);\n\n// Multiplicamos por un valor grande para provocar overflow\nint resultado = valor * valor;\nSystem.out.println(\"Resultado despu\u00e9s del overflow: \" + resultado);\n//imprime \"Resultado despu\u00e9s del overflow: -727379968\"\n</code></pre>"},{"location":"ud1/14datatypejava/#underflow","title":"Underflow","text":"<p>El underflow en Java ocurre cuando un valor es m\u00e1s bajo que el valor m\u00ednimo que un tipo de dato puede representar. Al igual que el overflow, el underflow causa que el valor \"rebote\", pero en este caso desde el valor m\u00ednimo hacia el valor m\u00e1ximo del rango permitido.</p> <pre><code> int valorMinimo = Integer.MIN_VALUE; // -2,147,483,648\nSystem.out.println(\"Valor m\u00ednimo: \" + valorMinimo);\n\n// Provocamos el underflow\nint underflow = valorMinimo - 1;\nSystem.out.println(\"Valor despu\u00e9s del underflow: \" + underflow);\n//imprime \"Valor despu\u00e9s del underflow: 2147483647\"\n</code></pre>"},{"location":"ud1/15operators/","title":"\ud83d\udcbe Operadores","text":"<p>Los operadores son s\u00edmbolos especiales en Java que realizan operaciones entre uno o varios operandos y devuelve un resultado. Uno de los m\u00e1s usados es el operador suma (+) como hemos visto en clases anteriores.</p>"},{"location":"ud1/15operators/#operando","title":"Operando","text":"<p>Es cualquier t\u00e9rmino, que puede ser una variable o valor y que es manipulado por un operador.</p> <pre><code>   int valor = 8;\n   int numero = valor + 12;\n</code></pre> <p>En el ejemplo anterior, + es el operador y valor y 12 son los operandos. valor + 12 es una expresi\u00f3n que devuelve el resultado de 20.</p>"},{"location":"ud1/15operators/#expresiones","title":"Expresiones","text":"<p>Una expresi\u00f3n es una combinaci\u00f3n de literales, operadores, nombres de variables y par\u00e9ntesis que se utilizan para calcular un valor.</p> <pre><code>  int miPrimerEntero = 7 + 5;\n  int resultado = 0;\n\n  resultado = (miPrimerEntero * 10) / (32 + 12);\n</code></pre> <p>Java examina la expresi\u00f3n de la derecha del signo igual y realiza el c\u00e1lculo de una expresi\u00f3n matem\u00e1tica. Despu\u00e9s asigna ese valor a la variable resultado. Podr\u00edamos complicar m\u00e1s la expresi\u00f3n utilizando operadores como par\u00e9ntesis, multiplicaciones, divisiones, etc.</p> <p>Las partes de una expresi\u00f3n deben estar ordenadas correctamente. Las reglas para las expresiones Java correctas son casi las mismas que las del \u00e1lgebra:</p> <ol> <li> <p>Cada operador debe tener el n\u00famero correcto de operandos.</p> <ul> <li>Multiplicaci\u00f3n *, Divisi\u00f3n /, Suma +, Resta: debe tener dos operandos, uno en cada lado.</li> <li>La negaci\u00f3n - y unario m\u00e1s + deben ir seguidos de un operando.</li> </ul> </li> <li> <p>Los par\u00e9ntesis () pueden rodear una expresi\u00f3n legal para convertirla en operando.</p> </li> </ol> <p></p>"},{"location":"ud1/15operators/#expresiones-mixtas-con-int-y-double","title":"Expresiones mixtas con int y double","text":"<p>Si ambos operandos de un operador aritm\u00e9tico son de tipo int, entonces la operaci\u00f3n es una operaci\u00f3n entera. Si alg\u00fan operando es de punto flotante, entonces la operaci\u00f3n es de punto flotante.</p>"},{"location":"ud1/15operators/#tipos-de-operadores-en-java","title":"Tipos de operadores en Java","text":"<p>Java proporciona muchos tipos de operadores que se pueden usar seg\u00fan la necesidad. Se clasifican seg\u00fan la funcionalidad que brindan. Algunos de los tipos son los siguientes:</p> <p>Operadores aritm\u00e9ticos, unarios, de asignaci\u00f3n, relacionales, l\u00f3gicos, etc.</p>"},{"location":"ud1/15operators/#operador-de-asignacion","title":"Operador de asignaci\u00f3n (=)","text":"<p>Es uno de los operadores m\u00e1s usados. Se usa para asignar un valor a cualquier variable. Tiene una asociaci\u00f3n de derecha a izquierda, es decir, el valor dado en el lado derecho del operador se asigna a la variable de la izquierda y, por lo tanto, el valor del lado derecho debe declararse antes de usarlo o debe ser una constante.</p>"},{"location":"ud1/15operators/#operadores-aritmeticos","title":"Operadores aritm\u00e9ticos","text":"<p>Se utilizan para realizar operaciones aritm\u00e9ticas simples.</p> S\u00edmbolo Operaci\u00f3n Descripci\u00f3n + Suma Realiza la suma de los operandos. - Resta Realiza la resta de los operandos. * Producto Multiplica los operandos. / Divisi\u00f3n Realiza la divisi\u00f3n. % M\u00f3dulo Calcula el resto. <pre><code>int a = 10, b = 5;\nint suma = a + b;        // 15\nint division = a / b;    // 2\nint modulo = a % b;      // 0\n</code></pre>"},{"location":"ud1/15operators/#operadores-unarios","title":"Operadores unarios","text":"<p>Los operadores unarios solo necesitan un operando. Se usan para incrementar, disminuir o negar un valor.</p> S\u00edmbolo Operaci\u00f3n Descripci\u00f3n ++ Incremento Incrementa el valor en 1 unidad. -- Decremento El valor disminuye en 1 unidad. ! NOT l\u00f3gico Invierte un valor booleano. <p>Existen dos versiones de estos operadores:</p> <ul> <li>Pre-incremento y pre-decremento. El valor se aumenta/disminuye primero y luego se calcula el resultado.</li> </ul> <p></p> <pre><code> int a = 8, b = 1;\n b = ++a; //b=9, a=9\n</code></pre> <ul> <li>Post-Incremento y post-decremento: el valor se usa por primera vez para calcular el resultado y luego se incrementa/decrementa.</li> </ul> <pre><code> int a = 8, b = 1;\n b = a++;//b = 8, a = 9\n</code></pre> <p></p>"},{"location":"ud1/15operators/#operadores-relacionales","title":"Operadores relacionales","text":"<p>Estos operadores se utilizan para verificar relaciones como igualdad, mayor que, menor que. Devuelven el resultado booleano(true o false) despu\u00e9s de la comparaci\u00f3n.</p> Operador Descripci\u00f3n Ejemplo <code>==</code> Igual a <code>a == b</code> <code>!=</code> No igual a <code>a != b</code> <code>&gt;</code> Mayor que <code>a &gt; b</code> <code>&lt;</code> Menor que <code>a &lt; b</code> <code>&gt;=</code> Mayor o igual que <code>a &gt;= b</code> <code>&lt;=</code> Menor o igual que <code>a &lt;= b</code> <pre><code>int a = 20, b = 10;\n\n\nboolean esIgual = a == b;      // false\nboolean esMayor = a &gt; b;       // true\nboolean esMenorOIgual = a &lt;= b; // false\n</code></pre>"},{"location":"ud1/15operators/#operadores-logicos","title":"Operadores l\u00f3gicos","text":"<p>Estos operadores se utilizan para realizar operaciones l\u00f3gicas AND y OR. Se usa ampliamente en sentencias if-then o bucles para verificar condiciones, establecer un punto de salida de un bucle o la toma de  decisiones. Los operadores condicionales son:</p> S\u00edmbolo Operaci\u00f3n Descripci\u00f3n &amp;&amp; AND l\u00f3gico Devuelve verdadero cuando ambas condiciones son ciertas. || OR l\u00f3gico Devuelve verdadero si al menos una condici\u00f3n es cierta. ! NOT l\u00f3gico Invierte el valor l\u00f3gico de la expresi\u00f3n l\u00f3gica <p></p> <pre><code>    int a = 20, b = 10, c= 10;\n    System.out.println((b == c &amp;&amp; a == c)); //False\n    System.out.println((a == c &amp;&amp; b == c)); //False\n    System.out.println(!(a == c &amp;&amp; b == c)); //True\n    System.out.println((a == b || b == c)); //True\n    System.out.println(!(a == b || b == c)); //False\n</code></pre>"},{"location":"ud1/15operators/#operadores-de-bits","title":"Operadores de bits","text":"S\u00edmbolo Operaci\u00f3n Descripci\u00f3n &amp; AND Si ambos bits de entrada son 1, establece como resultado 1. De lo contrario 0. | OR Si por lo menos uno de los bits de entrada es 1, establece como resultado 1. De lo contrario 0. ^ XOR Si uno de los bits de entrada es 1 y el otro 0, establece como resultado 1. Si los bits son iguales establece 0. ~ NOT Invierte todos los bits y devuelve el resultado en complemento a 2."},{"location":"ud1/15operators/#abreviaciones","title":"Abreviaciones","text":"<p>En muchos casos, el operador de asignaci\u00f3n se puede combinar con otros operadores para construir una versi\u00f3n m\u00e1s corta de la declaraci\u00f3n llamada Declaraci\u00f3n Compuesta (Compound Statement).</p> <ul> <li>+= , para sumar el operando izquierdo con el operando derecho y luego asignarlo a la variable de la izquierda.</li> </ul> <pre><code>  int a = 5;\n  a += 5; // a = a + 5;\n</code></pre> <ul> <li>\u2013 = , para restar el operando izquierdo con el operando derecho y luego asignarlo a la variable de la izquierda.</li> </ul> <pre><code>  int a = 5;\n  a -= 5; // a = a - 5;\n</code></pre> <ul> <li>*= , para multiplicar el operando izquierdo con el operando derecho y luego asign\u00e1ndolo a la variable de la izquierda.</li> </ul> <pre><code>  int a = 5;\n  a *= 5; // a = a * 5;\n</code></pre> <ul> <li>/ = , para dividir el operando izquierdo con el operando derecho y luego asignarlo a la variable de la izquierda.</li> </ul> <pre><code>  int a = 5;\n  a /= 5; // a = a / 5;\n</code></pre> <ul> <li>% = , para asignar el m\u00f3dulo del operando izquierdo con el operando derecho y luego asignarlo a la variable de la izquierda.</li> </ul> <pre><code>  int a = 5;\n  a %= 5; // a = a % 5;\n</code></pre>"},{"location":"ud1/15operators/#operador-ternario","title":"Operador ternario","text":"<p>El operador ternario es un operador condicional que eval\u00faa una expresi\u00f3n y devuelve un valor basado en si la condici\u00f3n es verdadera o falsa.</p> Operador Descripci\u00f3n Ejemplo <code>?:</code> Operador ternario (condicional) <code>condici\u00f3n ? valor1 : valor2</code> <pre><code>int a = 10, b = 5;\nint max = (a &gt; b) ? a : b;  \n// max=10 ya que a&gt;b=true\n\nint num = 15;\nString resultado = (num % 2 == 0) ? \"Par\" : \"Impar\";  // Si el n\u00famero es divisible por 2, es par\n//resultado=\"Par\"\n\nint edad=8;\nString mensaje = (edad&gt;=18) ? \"Es mayor de edad\" : \"Es menor de edad\";\n//mensaje=\"Es menor de edad\"\n</code></pre>"},{"location":"ud1/15operators/#precedencia-de-operadores","title":"Precedencia de operadores","text":"<p>La prioridad de operadores en Java define el orden en que las operaciones son evaluadas cuando hay m\u00faltiples operadores en una expresi\u00f3n. Algunos operadores tienen mayor prioridad que otros, lo que significa que se evaluar\u00e1n antes a menos que el orden sea alterado expl\u00edcitamente mediante el uso de par\u00e9ntesis.</p> <p>Reglas generales:</p> <ul> <li>Los operadores con mayor prioridad se eval\u00faan antes que los de menor prioridad.</li> <li>Los operadores con la misma prioridad se eval\u00faan de acuerdo a su asociatividad, que puede ser de izquierda a derecha o de derecha a izquierda.</li> </ul> <p>Las prioridades en Java son:</p> <p></p> <p><pre><code>int resultado = 10 + 3 * 2;\n//16\n</code></pre> Explicaci\u00f3n:</p> <ol> <li>El operador * (multiplicaci\u00f3n) tiene mayor prioridad que + (suma).</li> <li>Por lo tanto, la multiplicaci\u00f3n 3 * 2 se eval\u00faa primero, dando 6.</li> <li>Luego se eval\u00faa la suma: 10 + 6, que da 16.</li> </ol>"},{"location":"ud1/15operators/#uso-de-parentesis-para-alterar-la-prioridad","title":"Uso de par\u00e9ntesis para alterar la prioridad:","text":"<p>Si deseas cambiar el orden de evaluaci\u00f3n, puedes utilizar par\u00e9ntesis:</p> <pre><code>int resultado = (10 + 3) * 2;\n//26\n</code></pre> <p>Entender la prioridad de operadores es crucial para evitar errores sutiles y mejorar la legibilidad del c\u00f3digo. Aunque Java sigue un conjunto de reglas predefinidas, es recomendable usar par\u00e9ntesis para aclarar la intenci\u00f3n en expresiones complejas. Esto facilita tanto el entendimiento del c\u00f3digo como su mantenimiento.</p>"},{"location":"ud1/15operators/#conversiones-de-tipo","title":"Conversiones de tipo","text":""},{"location":"ud1/15operators/#conversiones-por-defecto","title":"Conversiones por defecto","text":"<p>Las reglas de Java para saber el tipo de datos resultante de una expresi\u00f3n se siguen las siguientes reglas:</p> Si alg\u00fan operando es El otro operando se transforma a double double float float long long byte or short int <p>Si se aplican dos regla, se elige la que aparece primero en la tabla.</p> <pre><code>    //imprime 5, es decir un int\n    System.out.println((34 + 1) / 7);\n    //imprime 5.0, es decir un float, ya que 1.0 es un float\n    System.out.println((34 + 1.0) / 7);\n</code></pre>"},{"location":"ud1/15operators/#conversiones-forzosas-casting-entre-tipos-nativos","title":"Conversiones forzosas (casting entre tipos nativos)","text":"<p>Es una forma de convertir un n\u00famero de un tipo a otro tipo de dato. Para hacerlo ponemos en par\u00e9ntesis el tipo de dato al que queremos convertirlo.</p> <pre><code>    byte miByte = (byte) (14 / 2); //conviero la operaci\u00f3n divisi\u00f3n que devuelve un int a byte\n\n    //Otra forma\n    float a = 8.0f;\n    int b = 10;\n    b = (int) a;//convierto el tipo float a int\n</code></pre> <p>Otros operadores</p> <p>Existen m\u00e1s operadores que no se han mencionado en el curso. Si se desea consultar todos los operadores de Java se pueden ver en su documentaci\u00f3n oficial. More information</p>"},{"location":"ud1/15operators/#api-de-java","title":"API de Java","text":"<p>Una de las ventajas de los lenguajes modernos es que se dispone de herramientas que resuelve muchos de los algoritmos necesarios para solucionar un problema. En Java, a estas herramientas disponibles para el programador se les llama API de Java y se encuentran organizadas en paquetes, donde cada paquete contiene un conjunto de clases relacionadas.</p> <p>La API de Java es extensa y diversa, lo que permite a los desarrolladores aprovechar una amplia gama de funcionalidades sin tener que implementar todo desde cero. Los programadores pueden importar los paquetes y clases necesarios en sus programas y utilizar los m\u00e9todos y atributos proporcionados por la API para realizar tareas espec\u00edficas.</p> <p>Por ejmplo, ya hemos utilizado la clase System para la salida por teclado.  <pre><code>    System.out.println(\"Hola mundo\");\n</code></pre></p> <p>Iremos aprendiendo la API de Java poco a poco. En la siguiente secci\u00f3n podemos ver la clase Math del paquete java.lang</p>"},{"location":"ud1/15operators/#sintaxis-de-las-expresiones-matematicas","title":"Sintaxis de las expresiones matem\u00e1ticas","text":"M\u00e9todo Returns Ejemplo Math.abs valor absoluto Math.abs(-308) returns 308 Math.ceil redondeo hacia arriba Math.ceil(2.13) returns 3.0 Math.floor redondeo hacia abajo Math.floor(2.93) returns 2.0 Math.max valor m\u00e1x. de dos valores Math.max(45, 207) returns 207 Math.min valor min. de dos valores Math.min(3.8, 2.75) returns 2.75 Math.pow potencia Math.pow(3, 4) returns 81.0 Math.round redondear al entero m\u00e1s cercano Math.round(2.718) returns 3 Math.sqrt ra\u00edz cuadrada Math.sqrt(81) returns 9.0 <p>Algunos ejemplos</p> <pre><code>public class EjemploMath {\n    public static void main(String[] args) {\n        // Calcular el valor absoluto de un n\u00famero\n        double numeroNegativo = -10.5;\n        double valorAbsoluto = Math.abs(numeroNegativo);\n        System.out.println(\"Valor absoluto de \" + numeroNegativo + \" es \" + valorAbsoluto);\n\n        // Calcular la ra\u00edz cuadrada de un n\u00famero\n        double numero = 25.0;\n        double raizCuadrada = Math.sqrt(numero);\n        System.out.println(\"La ra\u00edz cuadrada de \" + numero + \" es \" + raizCuadrada);\n\n        // Calcular el valor m\u00e1ximo entre dos n\u00fameros\n        int num1 = 30;\n        int num2 = 45;\n        int maximo = Math.max(num1, num2);\n        System.out.println(\"El valor m\u00e1ximo entre \" + num1 + \" y \" + num2 + \" es \" + maximo);\n\n        // Calcular el valor m\u00ednimo entre dos n\u00fameros\n        int minimo = Math.min(num1, num2);\n        System.out.println(\"El valor m\u00ednimo entre \" + num1 + \" y \" + num2 + \" es \" + minimo);\n\n        // Calcular un n\u00famero elevado a una potencia\n        double base = 2.0;\n        double exponente = 3.0;\n        double resultadoPotencia = Math.pow(base, exponente);\n        System.out.println(base + \" elevado a la \" + exponente + \" es igual a \" + resultadoPotencia);\n\n        // Generar un n\u00famero aleatorio entre 0.0 (inclusive) y 1.0 (exclusivo)\n        double numeroAleatorio = Math.random();\n        System.out.println(\"N\u00famero aleatorio: \" + numeroAleatorio);\n    }\n}\n</code></pre> <p>La clase Math es parte del paquete java.lang, que se importa autom\u00e1ticamente en todos los programas de Java sin necesidad de una declaraci\u00f3n de importaci\u00f3n expl\u00edcita</p>"},{"location":"ud1/16comments/","title":"\ud83d\udcbe Comentarios en Java","text":"<p>Los comentarios son ignorados por el ordenador y se usan en el programa para ayudar a describir alguna funcionalidad o explicaci\u00f3n del c\u00f3digo fuente. Existen dos tipos de comentarios.</p>"},{"location":"ud1/16comments/#comentarios-de-una-linea","title":"Comentarios de una l\u00ednea","text":"<p>Usamos la doble barra // para realizar un comentario de una sola l\u00ednea. Lo podemos usar en una l\u00ednea en blanco o detr\u00e1s del c\u00f3digo.</p> <pre><code>   int gravity; //variable para calcular la gravedad\n</code></pre>"},{"location":"ud1/16comments/#comentarios-multilinea","title":"Comentarios multil\u00ednea","text":"<p>Usamos la barra con asterisco doble para realizar comentarios que afecten a m\u00e1s de una l\u00ednea. De forma que cuando abramos un comentario usaremos /*, para cerrarlo */.</p> <pre><code>   /*\n      Clase que almacena en la base de datos\n      los datos de una persona.\n   */\n   public class Persona {\n      ...\n   }\n</code></pre>"},{"location":"ud1/17constantesliterales/","title":"\ud83d\udcbe Constantes y literales","text":""},{"location":"ud1/17constantesliterales/#las-constantes","title":"Las constantes","text":"<p>Un programa puede contener ciertos valores que no deben cambiar durante su ejecuci\u00f3n. Estos valores se llaman constantes. Definici\u00f3n: Una constante es una zona de memoria que se referencia con un identificador, conocido como nombre de la constante, donde se almacena un valor que no puede cambiar durante la ejecuci\u00f3n del programa.</p> <p>La nomenclatura para definiar las constantes es la siguiente:</p> <ul> <li>Todas las letras de cada palabra deben estar en may\u00fasculas</li> <li>Se separa cada palabra con un _</li> <li>Se declaran similar a las variables, con la diferencia de que el tipo de dato va despu\u00e9s de la palabra reservada final</li> </ul> <pre><code>    final double PI = 3.141591;\n    final int MIN_WIDTH = 4;\n    final double TASAS = 0.045;\n</code></pre> <p>Las constantes hacen que el programa sea m\u00e1s f\u00e1cil de leer y verificar que sea correcto. Si es necesario cambiar una constante (por ejemplo, si cambian las tasas), todo lo que tendremos que hacer es cambiar la declaraci\u00f3n de la constante. No ser\u00e1 necesario buscar en todo el programa cada aparici\u00f3n de ese n\u00famero espec\u00edfico.</p>"},{"location":"ud1/17constantesliterales/#los-literales","title":"Los literales","text":"<p>Un literal Java es un valor de tipo entero, real, l\u00f3gico, car\u00e1cter, cadena de caracteres o un valor nulo (null) que puede aparecer dentro de un programa. Por ejemplo: 150, 12.4, \u201cANA\u201d, null, \u2018t\u2019. Los literales suelen aparecer en la asignaci\u00f3n de valores a las variables o formando parte de expresiones aritm\u00e9ticas o l\u00f3gicas.</p> <p></p>"},{"location":"ud1/18inputoutputconsole/","title":"\ud83d\udcbe Programaci\u00f3n de la consola: entrada y salida de informaci\u00f3n (I/O input/output)","text":"<p>Java viene con una biblioteca de clases que se puede usar para realizar tareas comunes. La biblioteca de clases de Java est\u00e1 organizada en un conjunto de paquetes, donde cada paquete contiene una colecci\u00f3n de clases relacionadas.</p> <p>En esta secci\u00f3n presentamos las clases System y Scanner que se utilizan para imprimir la salida y leer la entrada de un programa.</p> <p>El tipo m\u00e1s simple de interfaz de usuario es la interfaz de l\u00ednea de comandos, en la que la entrada se toma de la l\u00ednea de comandos a trav\u00e9s del teclado y la salida se muestra en la consola. Algunas aplicaciones Java utilizan este tipo de interfaz, otros usan interfaz gr\u00e1fica como veremos m\u00e1s adelante.</p> <p></p> <p>En Java, la I/O se maneja a trav\u00e9s de m\u00e9todos que pertenecen a clases contenidas en el paquete <code>java.io</code>. </p> <p></p> <p>Java ofrece tres flujos est\u00e1ndar o predeterminados que podemos utilizar</p> <p>System.in : este es el flujo de entrada est\u00e1ndar que se utiliza para leer caracteres desde el teclado o cualquier otro dispositivo de entrada est\u00e1ndar.</p> <p>System.out : este es el flujo de salida est\u00e1ndar que se utiliza para producir el resultado de un programa en un dispositivo de salida como la pantalla de la computadora.</p> <p>System.err : este es el flujo de error est\u00e1ndar que se utiliza para generar todos los datos de error que un programa pueda generar en una pantalla de computadora o en cualquier dispositivo de salida est\u00e1ndar. Por defecto, es la misma salida que System.out.</p> <p></p>"},{"location":"ud1/18inputoutputconsole/#salida-de-la-informacion","title":"Salida de la informaci\u00f3n","text":"<p>En Java, cualquier origen o destino de I/O se considera un flujo de bytes o caracteres. Para realizar la salida, insertamos bytes o caracteres en la secuencia. </p> <p>Para realizar la entrada, extraemos bytes o caracteres del flujo (stream).Incluso los caracteres introducidos en un teclado, si se consideran como una secuencia de pulsaciones de teclas, se pueden representar como un stream.</p> <p>Ya hemos visto c\u00f3mo se usa el m\u00e9todo de salida <code>println()</code> para enviar una cadena a la consola. Por ejemplo:</p> <pre><code>   System.out.println(\"Hola mundo\");\n</code></pre> <p>imprime el texto Hola mundo por la consola.</p> <pre><code>   System.err.println(\"Fallo al abrir el fichero\");\n</code></pre>"},{"location":"ud1/18inputoutputconsole/#systemout","title":"System.out","text":"<p>Ya hemos visto <code>print()</code> y <code>println</code>. </p> <p>La \u00fanica diferencia entre los m\u00e9todos print() y println() es que println() tambi\u00e9n imprimir\u00e1 un retorno de carro y un avance de l\u00ednea despu\u00e9s de imprimir sus datos, lo que permitir\u00e1 que la salida posterior se imprima en una nueva l\u00ednea. Por ejemplo:</p> <pre><code>   System.out.print(\"Hola\");\n   System.out.print(\"mundo\"):\n   System.out.println(\"Texto con salto de l\u00ednea\");\n   System.out.println(\"adi\u00f3s\");\n</code></pre> <pre><code>   HolamundoTexto con salto de l\u00ednea\n   adi\u00f3s\n</code></pre>"},{"location":"ud1/18inputoutputconsole/#entrada-de-la-informacion-javautilscanner","title":"Entrada de la informaci\u00f3n java.util.Scanner","text":"<p>Se ha agregado la clase Scanner al paquete java.util que permite la entrada de teclado sin forzar el programador para manejar las excepciones.</p> <p>La clase Scanner est\u00e1 dise\u00f1ada para ser una forma muy flexible de reconocer fragmentos de datos que se ajustan a patrones espec\u00edficos de cualquier flujo de entrada.</p> <p>Para usar la clase Scanner para la entrada de teclado, debemos crear una instancia de Scanner y asociarla con System.in. </p> <p>La clase tiene un constructor para este prop\u00f3sito</p> <pre><code>   Scanner sc = new Scanner(System.in);\n</code></pre> <p>Declara y crea una instancia de un objeto que se puede utilizar para la entrada del teclado. Despu\u00e9s de crear un objeto Scanner, podemos hacer una llamada a:</p> <ul> <li>nextByte()  para leer un dato de tipo byte.</li> <li>nextShort()  para leer un dato de tipo short.</li> <li>nextInt()  para leer un dato de tipo int.</li> <li>nextLong()  para leer un dato de tipo long. </li> <li>nextFloat()  para leer un dato de tipo float. </li> <li>nextDouble()  para leer un dato de tipo double. </li> <li>nextBoolean()  para leer un dato de tipo boolean.</li> <li>nextLine()  para leer un String hasta encontrar un salto de l\u00ednea.</li> <li>next()  para leer un String hasta el primer delimitador, generalmente hasta un espacio en blanco o hasta un salto de l\u00ednea.  </li> </ul> <pre><code>   public static void main(String[] args) {\n       // Crear un objeto Scanner para leer desde la entrada est\u00e1ndar (teclado)\n        Scanner scanner = new Scanner(System.in);\n\n        // Leer un string (texto)\n        System.out.print(\"Ingresa tu nombre: \");\n        String nombre = scanner.nextLine();\n\n        // Leer un entero\n        System.out.print(\"Ingresa tu edad: \");\n        int edad = scanner.nextInt();\n\n        // Leer un n\u00famero decimal (double)\n        System.out.print(\"Ingresa tu salario: \");\n        double salario = scanner.nextDouble();\n\n        // Mostrar los datos ingresados\n        System.out.println(\"Nombre: \" + nombre);\n        System.out.println(\"Edad: \" + edad);\n        System.out.println(\"Salario: \" + salario);\n\n        // Cerrar el Scanner para liberar recursos\n        scanner.close();\n   }\n</code></pre> <p>Cuando se ejecuta el m\u00e9todo nextInt(), no se ejecutan m\u00e1s declaraciones hasta que el m\u00e9todo devuelve un valor int. </p> <p>Normalmente, esto no sucede hasta que el usuario ha escrito los d\u00edgitos de un n\u00famero entero y presiona la tecla Intro.</p> <p>Para leer un String utilizamos el m\u00e9todo next(). Pero lee hasta el primer espacio o salto de l\u00ednea.</p> <pre><code>   public static void main(String[] args) {\n      Scanner sc = new Scanner (System.in);\n      System.out.println(\"Introduce una palabra: \");\n      String str = sc.next();\n      System.out.println(str);\n   }\n</code></pre> <p>Lectura varios valores</p> <p>Un objeto Scanner tiene un conjunto de cadenas de caracteres que separan o delimitan los fragmentos de datos que est\u00e1 buscando. De forma predeterminada, este conjunto de delimitadores consta de cualquier secuencia no vac\u00eda de caracteres en blanco, es decir, los caracteres de espacio, tabulaci\u00f3n, retorno y nueva l\u00ednea. </p> <p>Esto permitir\u00e1 al usuario ingresar varios n\u00fameros enteros separados por espacios antes de presionar la tecla <code>Enter</code>. </p> <p>En c\u00f3digo ser\u00eda:</p> <p><pre><code>   System.out.print(\"Introduce dos n\u00fameros: \");\n   int num = sc.nextInt();\n   int num2 = sc.nextInt();\n</code></pre> </p> <p>Error</p> <p>Si el dato encontrado no es del tipo esperado o de un tipo compatible se produce un error. En este caso se lanza la excepci\u00f3n <code>InputMismatchException</code>. </p> <p>Esto se produce, por ejemplo, cuando se est\u00e1 ejecutando el m\u00e9todo <code>nextInt()</code> para extraer un entero del buffer y se introduce por ejemplo un <code>double o un char</code>.</p> <p></p> <p>Espacios en blanco al leer un String con <code>next()</code></p> <p>Los espacios en blanco como delimitadores tambi\u00e9n significan que el m\u00e9todo next() no puede devolver una cadena vac\u00eda ni puede devolver una cadena que contenga espacios. Por ejemplo, considere el c\u00f3digo:</p> <pre><code>   System.out.println(\"Introduce un texto separado por espacio en blanco: \");\n   String str = sc.next();\n   System.out.println(\"Usted introdujo: \"+str);\n</code></pre> <p>Si se escribe <code>\"Hola mundo\"</code> y se presiona la tecla <code>Enter</code>, la cadena str almacenar\u00e1 s\u00f3lo \"Hola\".</p> <p></p> <p>Leer una l\u00ednea completa con <code>nextLine()</code></p> <p>Para que un objeto Scanner lea cadenas que contienen espacios, debemos usar el m\u00e9todo nextLine():</p> <pre><code>   System.out.println(\"Introduce un texto separado por espacio en blanco: \");\n   String str = sc.nextLine();\n   System.out.println(\"Usted introdujo: \"+str);   \n</code></pre> <p></p>"},{"location":"ud1/18inputoutputconsole/#limpiar-el-buffer-de-entrada","title":"Limpiar el buffer de entrada","text":"<p>Cuando el usuario introduce un dato, scanner lee hasta que encuentra un espacio o un intro('/n'), pero este intro queda en el buffer, por lo que en una segunda lectura de datos por scanner se lo encontrar\u00e1 como primer car\u00e1cter por lo que no leer\u00e1 los datos del usuario correctamente</p> <pre><code>        Scanner sc = new Scanner(System.in);\n        System.out.print(\"Introduce tu edad: \");\n        //el usuario introduce el numero pero queda '/n' en el buffer\n        int edad = sc.nextInt(); \n        System.out.println(\"Introduce tu nombre:\");\n        //El programa no para ya que scanner encuentra datos en el buffer\n        //En nuestro caso el caracter '/n', por lo que no lee el nombre\n        String nombre = sc.nextLine();\n        System.out.println(\"Tu nombre es \" + nombre + \" y tienes \" + edad + \" a\u00f1os\");\n</code></pre> <p></p> <p>La soluci\u00f3n radica en limpiar el buffer de entrada mediante nextLine despu\u00e9s de leer el n\u00famero.</p> <pre><code>        Scanner sc = new Scanner(System.in);\n        System.out.print(\"Introduce tu edad: \");\n        int edad = sc.nextInt();\n        //limpiamos el buffer\n        sc.nextLine();\n        System.out.println(\"Introduce tu nombre:\");\n        String nombre = sc.nextLine();\n        System.out.println(\"Tu nombre es \" + nombre + \" y tienes \" + edad + \" a\u00f1os\");\n</code></pre> <p></p> <p>Nota</p> <p>Es posible que este \u00faltimo ejemplo no sea correcto. Es necesario probarlo para el jdk y sistema operativo que est\u00e9is utilizando</p>"},{"location":"ud1/1elementos/","title":"\ud83d\udcbe Elementos de un programa inform\u00e1tico","text":"<p> Un programa es una secuencia de instrucciones que un ordenador ejecuta para realizar alguna tarea. Parece una idea bastante simple, pero para que el ordenador pueda hacer uso de las instrucciones, deben estar escritas de forma que las pueda usar. Esto significa que los programas deben estar escritos en lenguajes de programaci\u00f3n. Los lenguajes de programaci\u00f3n se diferencian de los lenguajes humanos ordinarios en que son completamente inequ\u00edvocos y muy estrictos sobre lo que est\u00e1 y no est\u00e1 permitido en un programa. Las reglas que determinan lo que est\u00e1 permitido se denominan sintaxis del lenguaje. Las reglas de sintaxis especifican el vocabulario b\u00e1sico del lenguaje y c\u00f3mo se pueden construir los programas. </p>"},{"location":"ud1/1elementos/#lenguajes-de-programacion","title":"Lenguajes de programaci\u00f3n","text":"<p>Se trata de un conjunto de instrucciones que permite la comunicaci\u00f3n de los humanos con los ordenadores.</p> <p></p> <ol> <li>C \u2192 bases de datos, videojuegos, kernel linux, IoT, dispositivos inteligentes, etc.</li> <li>Python \u2192 inteligencia artificial, big data, Web etc.</li> <li>Java \u2192 puntos de ventas, aplicaciones de escritorio, cajeros autom\u00e1ticos, dispositivos m\u00f3viles, aplicaciones de servidor ...</li> </ol> <p></p>"},{"location":"ud1/1elementos/#con-que-lenguaje-de-programacion-debo-empezar","title":"\u00bfCon qu\u00e9 lenguaje de programaci\u00f3n debo empezar?","text":"<p>En realidad, no existe el mejor lenguaje de programaci\u00f3n para empezar, y el lenguaje que elijas pr\u00e1cticamente no tendr\u00e1 un efecto duradero en tu carrera. Los lenguajes de programaci\u00f3n pueden verse muy diferentes en la superficie, pero la mayor\u00eda de los conceptos fundamentales se transferir\u00e1n de un lenguaje a otro. Aprender un nuevo idioma tambi\u00e9n ser\u00e1 m\u00e1s f\u00e1cil con el tiempo; un principiante puede tardar meses antes de que se sienta c\u00f3modo con su primer lenguaje; un programador experimentado puede familiarizarse con un nuevo idioma en cuesti\u00f3n de d\u00edas.</p>"},{"location":"ud1/1elementos/#consejos-para-aprender-a-programar-con-exito","title":"Consejos para aprender a programar con \u00e9xito","text":"<p>No olvides</p> <ol> <li>Encuentra tu motivaci\u00f3n. Inter\u00e9s por la tecnolog\u00eda, mejorar profesionalmente y enfrentar nuevos retos de aprendizaje son los principales est\u00edmulos</li> <li>Comienza desde la base y usa la l\u00f3gica. Antes de estudiar cualquier lenguaje de programaci\u00f3n, es necesario adquirir las capacidades de razonamiento l\u00f3gico</li> <li>\u00a1A practicar! La programaci\u00f3n es un continuo ensayo y error y el ejercicio pr\u00e1ctico es el \u00fanico camino para mejorar.</li> <li>El trabajo en equipo es clave. Si al lado tienes a gente que tambi\u00e9n quiere aprender, es mucho m\u00e1s ameno y sencillo</li> <li>Ordena tu trabajo y tu mente. La capacidad de resoluci\u00f3n de problemas, el pensamiento lateral y la autogesti\u00f3n son tres de las competencias transversales m\u00e1s importantes para empezar a programar</li> <li>No intentes correr. Esquematiza con diagramas de flujo o pseudoc\u00f3digo todo aquello que vayas a interpretar</li> <li>Aprende a lidiar con la frustraci\u00f3n. Nadie dijo que el camino fuera f\u00e1cil</li> <li>\u00a1No te rindas! La perseverancia es el mejor motor para continuar aprendiendo c\u00f3digo. La satisfacci\u00f3n de haber logrado el objetivo compensar\u00e1 con creces esos malos momentos</li> </ol> <p>Fuente: Fundaci\u00f3n Telef\u00f3nica</p>"},{"location":"ud10/1persistence/","title":"Persistencia de la informaci\u00f3n","text":"<p>La persistencia es la capacidad de guardar el estado de un objeto en alg\u00fan tipo de almacenamiento, para poder restaurarlo en alg\u00fan momento posteriormente.</p> <p></p> <p>Hoy en d\u00eda, la mayor\u00eda de aplicaciones inform\u00e1ticas necesitan almacenar y gestionar gran cantidad de datos.</p> <p>Esos datos, se suelen guardar en bases de datos relacionales, ya que \u00e9stas son las m\u00e1s extendidas actualmente.</p>"},{"location":"ud10/1persistence/#tipos-de-bases-de-datos","title":"Tipos de bases de datos","text":"<p>Una base de datos es una herramienta que recopila datos, los organiza y los relaciona para que se pueda hacer una r\u00e1pida b\u00fasqueda y recuperar con ayuda de un ordenador. Hoy en d\u00eda, las bases de datos tambi\u00e9n sirven para desarrollar an\u00e1lisis. Las bases de datos m\u00e1s modernas tienen motores espec\u00edficos para sacar informes de datos complejos.</p> <p>Adem\u00e1s, es importante saber que hay varios tipos de base de datos: la relacional; la distribuida; NoSQL; orientada a objetos; y, gr\u00e1ficas. La existencia de estas diversas bases de datos se debe a la variedad de forma de trabajo que se requiere de ellas.</p> <p>Las bases de datos relacionales representan la informaci\u00f3n en forma de tablas, con filas y columnas que se relacionan mediante campos clave. Adem\u00e1s se trabaja con el lenguaje est\u00e1ndar conocido como SQL, para poder realizar las consultas que deseemos a la base de datos.</p> <p>El sistema gestor de bases de datos, en ingl\u00e9s conocido como: Database Management System (DBMS), gestiona el modo en que los datos se almacenan, mantienen y recuperan.</p> <p>En el caso de una base de datos relacional, el sistema gestor de base de datos se denomina: Relational Database Management System (RDBMS).</p> <p></p> <p>Tradicionalmente, la programaci\u00f3n de bases de datos ha sido un caos debido a la gran cantidad de productos de bases de datos en el mercado, cada uno con sus caracter\u00edsticas y lenguaje diferente.</p>"},{"location":"ud10/2mapeo/","title":"\u26d3\ufe0f Desfase objeto - relacional","text":"<p>Las bases de datos relacionales no est\u00e1n dise\u00f1adas para almacenar objetos, ya que existe un desfase entre las construcciones t\u00edpicas que proporciona el modelo relacional y las proporcionadas por la programaci\u00f3n basada en objetos.</p> <p>El desfase objeto-relacional consiste en la diferencia de aspectos que existen entre la programaci\u00f3n orientada a objetos y la base de datos.</p> <p>Hay que recordar que el modelo relacional trata con relaciones y conjuntos y que, en las BD relacionales tenemos reglas de integridad:</p> <ul> <li>Todas las tablas deben tener una clave primaria</li> <li>La clave primaria tiene que ser \u00fanica y no puede ser NULL</li> <li>Para relacionar dos tablas usamos una foreign key</li> </ul> <p>Sin embargo, el modelo de Programaci\u00f3n Orientada a Objetos trata con objetos y las asociaciones entre ellos. Por esta raz\u00f3n, el problema entre estos dos modelos surge en el momento de querer persistir los objetos.</p>"},{"location":"ud10/2mapeo/#mapeo-objeto-relacional","title":"Mapeo objeto - relacional","text":"<p>Al trabajar con POO y BDR tenemos que estar continuamente gestionando los objetos para escribir la sentencia SQL, o recolectar todos los atributos para componer un objeto cuando leemos informaci\u00f3n desde la base de datos.</p> <p>A este conjunto de t\u00e9cnicas se le conoce como mapeo objeto-relacional. Y puede hacerse ayud\u00e1ndose de alguna herramienta o bien manualmente por el programador.</p> <p></p>"},{"location":"ud10/3conectores/","title":"\u2699\ufe0f Conectores o drivers","text":"<p>Un conector o driver es un mecanismo que permite a un lenguaje de programaci\u00f3n conectarse, y trabajar, contra una base de datos. Se encarga de mantener el di\u00e1logo con la base de datos, para poder llevar a cabo el acceso y manipulaci\u00f3n de los datos.</p> <p>Algunos de los m\u00e1s conocidos son:</p> <ul> <li> <p>ODBC (Open Database Connectivity). Es un est\u00e1ndar viejo. Esta tecnolog\u00eda proporciona una interfaz com\u00fan para tener acceso a bases de datos SQL heterog\u00e9neas. ODBC est\u00e1 basado en SQL (Structured Query Language) como un est\u00e1ndar para tener acceso a datos. ODBC permite la conexi\u00f3n f\u00e1cil desde varios lenguajes de programaci\u00f3n y se utiliza mucho en el entorno Windows.</p> </li> <li> <p>JDBC (Java Data Base Connectivity).</p> </li> </ul> <p>En este curso, nos vamos a centrar en JDBC, puesto que, desde el punto de vista de Java, es una de las tecnolog\u00edas m\u00e1s importantes de conectividad a la base de datos. Y, adem\u00e1s, Java 8 ha eliminado el puente JDBC-ODBC, lo que significa que los controladores ODBC de Microsoft ya no funcionan.</p>"},{"location":"ud10/3conectores/#jdbc","title":"JDBC","text":"<p>Casi de forma simult\u00e1nea a ODBC, la empresa Sun Microsystems, en 1997 sac\u00f3 a la luz JDBC, un API conector de bases de datos, implementado espec\u00edficamente para usar con el lenguaje Java. Se trata de un API bastante similar a ODBC en cuanto a funcionalidad, pero adaptado a las especificidades de Java. Es decir, la funcionalidad se encuentra capsulada en clases (ya que Java es un lenguaje totalmente orientado a objetos) y, adem\u00e1s, no depende de ninguna plataforma espec\u00edfica, de acuerdo con la caracter\u00edstica multiplataforma defendida por Java.</p> <p>Es una API que permite la ejecuci\u00f3n de operaciones contra una base de datos desde Java independientemente del sistema operativo donde se ejecute o de la base de datos a la cual se acceda.</p> <p></p> <p>Es importante destacar tambi\u00e9n que JDBC no exige ninguna instalaci\u00f3n, ni ning\u00fan cambio sustancial en el c\u00f3digo a la hora de utilizar uno u otro controlador. Esta caracter\u00edstica se sustenta, en primer lugar, en la utilidad de Java que permite cargar program\u00e1ticamente cualquier clase a partir de su nombre; en segundo lugar, en la funcionalidad de la clase DriverManager (de la API JDBC), que sin necesidad de indicarle el driver espec\u00edfico que hay que utilizar es capaz de encontrarlo y seleccionarlo de entre todos los que el sistema tenga cargados en memoria.</p> <p>A pesar de eso tampoco es mucho problema ya que actualmente podemos encontrar un driver JDBC para pr\u00e1cticamente cualquier SGBDR existente. El conector lo proporciona el fabricante de la base de datos o bien un tercero.</p>"},{"location":"ud10/3conectores/#conexion-con-la-bbdd-desde-jdbc","title":"Conexi\u00f3n con la BBDD desde JDBC","text":"<p>Antes de empezar a desarrollar aplicaciones JDBC es necesario aseguramos que tenemos instalado el SGBD, y adem\u00e1s que tenemos acceso desde el lugar donde estemos desarrollando la aplicaci\u00f3n. Una vez verificado el sistema gestor de base de datos, ser\u00e1 necesario obtener el controlador JDBC del sistema gestor. Generalmente, cada fabricante pondr\u00e1 a disposici\u00f3n de sus usuarios los diferentes tipos de controladores que tenga para sus productos. Sea cual sea el tipo de controlador que finalmente necesita, \u00e9ste tendr\u00e1 como m\u00ednimo una biblioteca en formato .jar con todas las clases de la API JDBC. Habr\u00e1 que a\u00f1adir el archivo .jar como biblioteca de nuestra aplicaci\u00f3n.</p> <p>Para descargar el driver JDBC para MySQL podemos hacerlo desde el repositorio de Maven:</p> <p>MySQL JDBC</p> <p>Podemos a\u00f1adirlo f\u00e1cilmente en IntelliJ a nuestro proyecto</p> <p></p>"},{"location":"ud10/3conectores/#establecimiento-y-cierre-de-conexion","title":"Establecimiento y cierre de conexi\u00f3n","text":"<p>Las clases que afectan a la gesti\u00f3n de la conexi\u00f3n con la BBDD son:</p> <ul> <li> <p><code>DriverManager</code>: esta clase se utiliza para registrar el controlador para un tipo de base de datos espec\u00edfico (por ejemplo, MySQL en este tutorial) y para establecer una conexi\u00f3n de base de datos con el servidor a trav\u00e9s de su m\u00e9todo <code>getConnection()</code>.</p> </li> <li> <p><code>Connection</code>, es una interfaz que representa una conexi\u00f3n a la base de datos establecida (sesi\u00f3n) desde la cual podemos crear declaraciones para ejecutar consultas y recuperar resultados, obtener metadatos sobre la base de datos, cerrar conexi\u00f3n, etc.Los objetos <code>Connection</code> mantendr\u00e1n la capacidad de comunicarse con el sistema gestor mientras permanezcan abiertos. Esto es, desde que se crean hasta que se cierran utilizando el m\u00e9todo close.</p> </li> </ul> <p>El objeto <code>Connection</code> est\u00e1 totalmente vinculado a una fuente de datos, por eso en pedir la conexi\u00f3n hay que especificar de qu\u00e9 fuente se trata siguiendo el protocolo JDBC e indicando la url de los datos, y en su caso el usuario y password.</p> <p>Example \ud83e\udd13</p> <ul> <li>jdbc:bbdd://server:port/schema</li> <li>jdbc:postgresql://localhost:5432/severo</li> </ul> <p>La url seguir\u00e1 el protocolo JDBC, comenzar\u00e1 siempre por la palabra jdbc seguida de dos puntos. El resto depender\u00e1 del tipo de controlador utilizado, del host donde se aloje el SGBD, del puerto que este use para escuchar las peticiones y del nombre de la base de datos o esquema con el que queremos trabajar.</p> <pre><code>import java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\n\n...\n\npublic static void main(String[] args) {\n    String user = \"patricia\";\n    String password = \"marti\";\n    String url = \"jdbc:mysql://localhost/severo_ad\";\n\n    try (final Connection connection = DriverManager.getConnection(url, user, password)) {\n        System.out.println(connection.getCatalog());\n    } catch (SQLException ex) {\n        System.out.println(\"SQLException: \" + ex.getMessage());\n        System.out.println(\"SQLState: \" + ex.getSQLState());\n        System.out.println(\"VendorError: \" + ex.getErrorCode());\n    }\n}\n</code></pre>"},{"location":"ud10/3conectores/#crudcrear-leer-actualizar-eliminar","title":"CRUD(Crear, Leer, Actualizar, Eliminar)","text":"<p>CRUD es un acr\u00f3nimo que se refiere a las operaciones b\u00e1sicas que se pueden realizar en una base de datos o sistema de gesti\u00f3n de bases de datos relacionales. Cada letra en CRUD representa una de estas operaciones</p> <ul> <li>Create (Crear): La operaci\u00f3n de crear implica agregar nuevos registros o filas a una tabla en la base de datos.</li> <li>Read (Leer): La operaci\u00f3n de leer implica recuperar informaci\u00f3n de la base de datos. Esto generalmente implica realizar consultas SELECT para recuperar datos de una o m\u00e1s tablas en la base de datos.</li> <li>Update (Actualizar): La operaci\u00f3n de actualizar implica modificar los datos existentes en la base de datos. Esto se hace mediante la ejecuci\u00f3n de consultas UPDATE que modifican los valores de uno o m\u00e1s registros en una tabla.</li> <li>Delete (Eliminar): La operaci\u00f3n de eliminar implica eliminar registros o filas de una tabla en la base de datos. Esto se hace mediante la ejecuci\u00f3n de consultas DELETE.</li> </ul> <p>El CRUD en un programa define las operaciones b\u00e1sicas sobre la base de datos</p> <p>El API JDBC distingue dos tipos de consultas:</p> <ul> <li>Consultas: SELECT</li> <li>Actualizaciones: INSERT, UPDATE, DELETE, sentencias DDL.</li> </ul>"},{"location":"ud10/3conectores/#interfaces-y-clases-principales-de-jdbc","title":"Interfaces y clases principales de JDBC","text":"<ul> <li> <p><code>Statement</code> y <code>PreparedStatement</code>: estas interfaces se utilizan para ejecutar consultas SQL est\u00e1ticas y consultas SQL parametrizadas, respectivamente. <code>Statement</code> es la superinterfaz de la interfaz <code>PreparedStatement</code>, que se utiliza para consultas parametrizadas. Sus m\u00e9todos com\u00fanmente utilizados son:</p> <ul> <li><code>boolean execute(String sql)</code>: ejecuta una sentencia SQL general. Devuelve verdadero si la consulta devuelve un <code>ResultSet</code>, falso si la consulta devuelve un recuento de actualizaciones o no devuelve nada. Este m\u00e9todo solo se puede utilizar con una sentencia.</li> <li> <p><code>int executeUpdate(String sql)</code>: ejecuta una sentencia INSERT, UPDATE o DELETE y devuelve un conteo actualizado que indica el n\u00famero de filas afectadas (por ejemplo, 1 fila insertada, 2 filas actualizadas o 0 filas afectadas).</p> <pre><code>Statement stmt = con.createStatement();\nString q1 = \"INSERT INTO user VALUES (1,root,Patricia Marti)\";\nint x = stmt.executeUpdate(q1);\n</code></pre> </li> </ul> </li> <li> <p><code>ResultSet executeQuery(String sql)</code>: ejecuta una sentencia SELECT y devuelve un objeto <code>ResultSet</code> que contiene los resultados devueltos por la consulta.</p> <pre><code>Statement stmt = con.createStatement();\nString q1 = \"SELECT * FROM USER WHERE id = '\" \n            + id + \"' AND pwd = '\" + pwd + \"'\";\nResultSet rs = stmt.executeQuery(q1);\n</code></pre> </li> <li> <p><code>ResultSet</code>: contiene los datos de la tabla devueltos por una consulta SELECT. Este objeto se usa para iterar sobre las filas en el conjunto de resultados usando el m\u00e9todo <code>next()</code>.</p> </li> </ul> <p>\ud83e\udd13 SQLException: Es la excepci\u00f3n que se lanza cuando hay alg\u00fan problema entre la base de datos y el programa Java JDBC. Contiene los siguientes m\u00e9todos:</p> <ul> <li><code>.getMessage()</code>, nos indica la descripci\u00f3n del mensaje de error.</li> <li><code>.getSQLState()</code>, devuelve un c\u00f3digo SQL est\u00e1ndar definido por ISO/ANSI y el Open Group que identifica de forma un\u00edvoca el error que se ha producido. SQLState Official</li> <li><code>.getErrorCode(</code>), es un c\u00f3digo de error que lanza la base de datos. En este caso el c\u00f3digo de error es diferente dependiendo del proveedor de base de datos que estemos utilizando.</li> <li><code>.getCause()</code>, nos devuelve una lista de objetos que han provocado el error.</li> <li><code>.getNextException()</code>, devuelve la cadena de excepciones que se ha producido. De tal manera que podemos navegar sobre ella para ver en detalle de esas excepciones.</li> </ul>"},{"location":"ud10/3conectores/#liberacion-de-recursos","title":"Liberaci\u00f3n de recursos","text":"<p>Danger \ud83d\ude2c</p> <p>Se debe cerrar expl\u00edcitamente <code>Statement</code>, <code>ResultSet</code> y <code>Connection</code> cuando ya no se necesiten, a menos que se declaren con un try-catch-with-resources.</p> <p>Las instancias de <code>Connection</code> y las de <code>Statement</code> almacenan, en memoria, mucha informaci\u00f3n relacionada con las ejecuciones realizadas. Adem\u00e1s, mientras permanecen activas mantienen en el SGBD un conjunto importante de recursos abiertos, destinados a servir de forma eficiente las peticiones de los clientes. El cierre de estos objetos permite liberar recursos tanto del cliente como del servidor.</p> <p>Aunque se haya cerrado la conexi\u00f3n, los objetos <code>Statements</code> que no se hab\u00edan cerrado expresamente permanecen m\u00e1s tiempo en memoria que los objetos cerrados previamente, ya que el garbage collector de Java deber\u00e1 hacer m\u00e1s comprobaciones para asegurar que ya no dispone de dependencias ni internas ni externas y se puede eliminar. Es por ello que se recomienda proceder siempre a cerrarlo manualmente utilizando el m\u00e9todo <code>close()</code>. El cierre de los objetos <code>Statement</code> asegura la liberaci\u00f3n inmediata de los recursos y la anulaci\u00f3n de las dependencias.</p> <p>Importante \ud83d\ude35\u200d\ud83d\udcab</p> <p>Si en un mismo m\u00e9todo queremos cerrar un objeto <code>Statement</code> y <code>Connection</code>, lo haremos siguiendo estos pasos:</p> <ol> <li> <p>Cerramos el <code>Statement</code></p> </li> <li> <p>Cerramos la instancia <code>Connection</code>.</p> </li> </ol> <p>Si lo hici\u00e9ramos al rev\u00e9s, cuando intent\u00e1ramos cerrar el <code>Statement</code> nos saltar\u00eda una excepci\u00f3n de tipo <code>SQLException</code>, ya que el cierre de la conexi\u00f3n lo habr\u00eda dejado inaccesible.</p> <p>Cuando se cierra un objeto <code>Statement</code>, su objeto <code>ResultSet</code> actual, si existe, tambi\u00e9n se cierra. Pero eso no ocurre cuando se cierra la conexi\u00f3n.</p> <pre><code>try (Connection connection = dataSource.getConnection();\n    Statement statement = connection.createStatement()) {\n\n    try (ResultSet resultSet = statement.executeQuery(\"SELECT * FROM ....\")) {\n        // Do actions.\n    }\n}\n</code></pre>"},{"location":"ud10/3conectores/#ejemplo-crud-en-sqlite","title":"Ejemplo CRUD en SQLite","text":"<p>SQLite es un motor de base de datos relacional de c\u00f3digo abierto que se especializa en ser ligero, eficiente y f\u00e1cil de usar. A diferencia de los sistemas de gesti\u00f3n de bases de datos tradicionales que funcionan como servidores independientes y manejan m\u00faltiples conexiones de cliente, SQLite es una biblioteca de base de datos sin servidor que se incorpora directamente en la aplicaci\u00f3n que la utiliza. </p> <p>Vamos a ver como crear un aplicaci\u00f3n simple con las operaciones b\u00e1sicas CRUD sobre una tabla Alumnos</p>"},{"location":"ud10/3conectores/#agregar-jdbc-de-sqlite-al-proyecto","title":"Agregar jdbc de SQLite al proyecto","text":"<p>Agregamos al proyecto las librer\u00edas que manejan SQLite.Necesitamos las librer\u00edas. </p> <ul> <li> <p>sqlite-jdbc-x.x.x.jar</p> </li> <li> <p>slf4j-api-x.x.x.jar</p> </li> </ul> <p></p>"},{"location":"ud10/3conectores/#conexion-jdbc","title":"Conexi\u00f3n JDBC","text":"<p>SQLite no se conecta a ning\u00fan servidor, lo \u00fanico que necesita el JDBC de SQLite es el nombre del fichero que contiene la base de datos.</p> <pre><code>static final String URL = \"jdbc:sqlite:alumnos.db\";\n</code></pre>"},{"location":"ud10/3conectores/#crear-una-tabla-si-no-existe-en-la-base-de-datos","title":"Crear una tabla si no existe en la Base de datos","text":"<p>Crearemos la tabla de Alumnos si no existe. Esto puede ocurrir la primera vez que se ejecuta el programa</p> <pre><code>private static void crearTabla(Connection conexion) throws SQLException {\n    try (Statement statement = conexion.createStatement()) {\n        statement.executeUpdate(\n                \"CREATE TABLE IF NOT EXISTS Alumno (\" +\n                        \"id INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                        \"nombre TEXT NOT NULL,\" +\n                        \"email TEXT,\" +\n                        \"telefono TEXT)\"\n        );\n        System.out.println(\"Tabla Alumno creada correctamente.\");\n    }\n}\n</code></pre>"},{"location":"ud10/3conectores/#insert-insertar-en-la-tabla","title":"Insert: Insertar en la tabla","text":"<p>Podemos crear sentencias SQL parametrizada que nos permiten generalizarlas y reutilizarlas. En aquellos lugares donde incluiremos un par\u00e1metro, colocamos un <code>?</code></p> <pre><code>private static void insertarAlumno(Connection conexion, String nombre, String email, String telefono) throws SQLException {\n    //Indicamos los par\u00e1metros mediante ?\n    String sqlInsert = \"INSERT INTO Alumno (nombre, email, telefono) VALUES (?, ?, ?)\";\n    try (PreparedStatement statement = conexion.prepareStatement(sqlInsert)) {\n        //Indicamos los valores a insertar\n        statement.setString(1, nombre);\n        statement.setString(2, email);\n        statement.setString(3, telefono);\n        //Lanzamos la sentencia SQL\n        statement.executeUpdate();\n        System.out.println(\"Alumno '\" + nombre + \"' insertado correctamente.\");\n    }\n}\n</code></pre>"},{"location":"ud10/3conectores/#update-actualizar-en-la-tabla","title":"Update: Actualizar en la tabla","text":"<p>Al igual que el anterior, parametrizamos la sentencia SQL</p> <pre><code>private static void actualizarAlumno(Connection conexion, int id, String nombre, String email, String telefono) throws SQLException {\n    String query = \"UPDATE Alumno SET nombre = ?, email = ?, telefono = ? WHERE id = ?\";\n\n    try (PreparedStatement statement = conexion.prepareStatement(query)) {\n        //incluimos los par\u00e1metros\n        statement.setString(1, nombre);\n        statement.setString(2, email);\n        statement.setString(3, telefono);\n        statement.setInt(4, id);\n        //lanzamos la sentencia\n        int rowsAffected = statement.executeUpdate();\n        //podemos saber las tuplas afectadas\n        if (rowsAffected &gt; 0) {\n            System.out.println(\"Registro de alumno actualizado correctamente.\");\n        } else {\n            System.out.println(\"No se encontr\u00f3 ning\u00fan registro de alumno con el ID proporcionado.\");\n        }\n    }\n}\n</code></pre>"},{"location":"ud10/3conectores/#delete-borrar-en-la-tabla","title":"Delete: Borrar en la tabla","text":"<p>Seguimos creando sentencias SQL parametrizada</p> <pre><code>private static void borrarAlumno(Connection conexion, int id) throws SQLException {\n    String query = \"DELETE FROM Alumno WHERE id = ?\";\n    try (PreparedStatement statement = conexion.prepareStatement(query)) {\n        statement.setInt(1, id);\n        statement.executeUpdate();\n        System.out.println(\"Alumno con ID \" + id + \" eliminado correctamente.\");\n    }\n}\n</code></pre>"},{"location":"ud10/3conectores/#select-consultas-sql-mediante-resultset","title":"Select: Consultas SQL mediante ResultSet","text":"<p>Podemos crear las sentencias que deseemos y parametrizadas. Estas nos devuelven un objeto de tipo <code>ResultSet</code>.</p> <p>El <code>ResultSet</code> nos permite recorrer las tuplas devueltas por el resultado de la sentencia SQL mediante el m\u00e9todo <code>next()</code></p> <p></p> <p>ResultSet nos permite extraer los campos de la tupla actual ya sea por nombre o por posici\u00f3n</p> <pre><code>//nombre de la columna\nint id=resultSet.getInt(\"id\")\nString  nombre = resultSet.getString(\"nombre\");\n//posici\u00f3n de la columna\nString  email = resultSet.getString(3);\n</code></pre> <p>La estructura suele tener el siguiente esquema</p> <pre><code>try (Connection conexion = getConnection();\n    Statement sentencia = conexion.createStatement();\n    ResultSet resultSet = sentencia.executeQuery(sql)) {\n    //mientras tengamos tublas\n    while (resultSet.next()) {\n    //gestionar resultset\n    }\n} catch (SQLException e) {\n\n}\n</code></pre>"},{"location":"ud10/3conectores/#ejemplos-de-su-uso-sobre-la-tabla-alumno","title":"Ejemplos de su uso sobre la tabla Alumno","text":"<p>Mostrar todos los alumnos </p> <p><pre><code>private static void consultarAlumnos(Connection conexion) throws SQLException {\n    try (Statement statement = conexion.createStatement();\n            ResultSet resultSet = statement.executeQuery(\"SELECT * FROM Alumno\")) {\n        while (resultSet.next()) {\n            System.out.println(\"ID: \" + resultSet.getInt(\"id\") +\n                    \", Nombre: \" + resultSet.getString(\"nombre\") +\n                    \", Email: \" + resultSet.getString(\"email\") +\n                    \", Tel\u00e9fono: \" + resultSet.getString(\"telefono\"));\n        }\n    }\n}\n</code></pre> Mostrar aquellos alumnos que su nombre contenga el par\u00e1metro indicado </p> <pre><code> private static void consultarAlumnosPorNombre(Connection conexion, String parteNombre) throws SQLException {\n    //sentencia parametrizada\n    String  query = \"SELECT * FROM Alumno WHERE nombre LIKE ?\";\n    try (PreparedStatement statement = conexion.prepareStatement(query)) {\n        //a\u00f1adimos el par\u00e1metro\n        statement.setString(1, \"%\" + parteNombre + \"%\");\n        try (ResultSet resultSet = statement.executeQuery()) {\n            while (resultSet.next()) {\n                System.out.println(\"ID: \" + resultSet.getInt(\"id\") +\n                        \", Nombre: \" + resultSet.getString(\"nombre\") +\n                        \", Email: \" + resultSet.getString(\"email\") +\n                        \", Tel\u00e9fono: \" + resultSet.getString(\"telefono\"));\n            }\n        }\n    }\n}\n</code></pre> <p>Devolver un ArrayList de Alumnos</p> <p>Suponiendo que tenemos la clase Alumno</p> <pre><code>public class Alumno {\n    private int id;\n    private String nombre;\n    private String email;\n    private String telefono;\n\n    // Constructor\n    public Alumno(int id, String nombre, String email, String telefono) {\n        this.id = id;\n        this.nombre = nombre;\n        this.email = email;\n        this.telefono = telefono;\n    }\n}\n</code></pre> <p>Una de las acciones m\u00e1s habituales es devolver una lista de Alumnos a partir de la consulta realizada</p> <pre><code>private static List&lt;Alumno&gt; listaAlumnos(Connection conexion) throws SQLException {\n    List&lt;Alumno&gt; listaAlumnos = new ArrayList&lt;&gt;();\n\n    try (Statement statement = conexion.createStatement();\n            ResultSet resultSet = statement.executeQuery(\"SELECT * FROM Alumno\")) {\n        while (resultSet.next()) {\n            int id = resultSet.getInt(\"id\");\n            String nombre = resultSet.getString(\"nombre\");\n            String email = resultSet.getString(\"email\");\n            String telefono = resultSet.getString(\"telefono\");\n\n            // Creamos un objeto Alumno y lo agregamos a la lista\n            Alumno alumno = new Alumno(id, nombre, email, telefono);\n            listaAlumnos.add(alumno);\n        }\n    }\n    return listaAlumnos;\n}\n</code></pre> <p>Un ejemplo de uso de los m\u00e9todos anteriores</p> <pre><code>public static void main(String[] args) {\n    Connection conexion = null;\n\n    try {\n        conexion = DriverManager.getConnection(URL);\n        //creamos la tabla si no existe\n        crearTabla(conexion);\n        // Insertamos algunos alumnos\n        insertarAlumno(conexion, \"Juan P\u00e9rez\", \"juan@example.com\", \"123456789\");\n        insertarAlumno(conexion, \"Mar\u00eda L\u00f3pez\", \"maria@example.com\", \"987654321\");\n        insertarAlumno(conexion, \"Carlos Garc\u00eda\", \"carlos@example.com\", \"555555555\");\n        insertarAlumno(conexion, \"Laura Mart\u00ednez\", \"laura@example.com\", \"777777777\");\n        insertarAlumno(conexion, \"Andrea P\u00e9rez\", \"andrea@example.com\", \"999999999\");\n\n        //Buscamos los alumnos actuales\n        System.out.println(\"Alumnos:\");\n        consultarAlumnos(conexion);\n\n        //Buscamos los alumnos con nombre que contiene 'Alumno'\n        System.out.println(\"Alumnos con nombre que contiene P\u00e9rez:\");\n        consultarAlumnosPorNombre(conexion, \"P\u00e9rez\");\n\n        //Actualizamos el alumno con id 1\n        System.out.println(\"Actualizar 1\");\n        int idAlumno = 1;\n        String nuevoNombre = \"Juanito P\u00e9rez\";\n        String nuevoEmail = \"juan@example.com\";\n        String nuevoTelefono = \"555-1234\";\n\n        // Llamamos al m\u00e9todo para actualizar el alumno\n        actualizarAlumno(conexion, idAlumno, nuevoNombre, nuevoEmail, nuevoTelefono);\n        consultarAlumnosPorNombre(conexion,\"Juan\");\n\n        //Recuperamos los alumnos en una Lista\n        System.out.println(\"Lista de alumnos:\");\n        List&lt;Alumno&gt; alumnos = listaAlumnos(conexion);\n        alumnos.forEach(System.out::println);\n    } catch (SQLException e) {\n        e.printStackTrace();\n    } finally {\n        try {\n            if (conexion != null) {\n                conexion.close();\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre>"},{"location":"ud10/3conectores/#ataque-por-inyeccion-sql","title":"Ataque por Inyecci\u00f3n SQL","text":"<p>La inyecci\u00f3n SQL es un tipo de ataque en el que un atacante inserta c\u00f3digo SQL malicioso en las consultas SQL de una aplicaci\u00f3n. Un ejemplo simplificado de c\u00f3mo podr\u00eda ocurrir una inyecci\u00f3n SQL en Java:</p> <p>Si tenemos un m\u00e9todo para autenticar el usuario en el que construimos la sentencia SQL por concatenaci\u00f3n</p> <pre><code>// M\u00e9todo para autenticar usuarios\npublic boolean autenticarUsuario(Connection conexion, String nombreUsuario, String contrase\u00f1a) throws SQLException {\n    String consulta = \"SELECT * FROM Usuarios WHERE nombre = '\" \n            + nombreUsuario\n            +\"' AND contrase\u00f1a = '\"\n            + contrase\u00f1a + \"'\";\n    PreparedStatement statement = conexion.prepareStatement(consulta);\n    ResultSet resultado = statement.executeQuery();\n\n    return resultado.next();\n}\n</code></pre> <p>Un atacante podr\u00eda explotar esta vulnerabilidad ingresando un nombre de usuario malicioso, como \" ' OR '1'='1\" y una contrase\u00f1a arbitraria. Esto alterar\u00eda la consulta SQL de la siguiente manera:</p> <p><pre><code>SELECT * FROM Usuarios WHERE nombre = '' OR '1'='1' AND contrase\u00f1a = 'contrase\u00f1a';\n</code></pre> El <code>OR '1'='1'</code> siempre eval\u00faa como verdadero, por lo que la consulta devolver\u00eda todos los registros de la tabla Usuarios, permitiendo que el atacante acceda a la cuenta de cualquier usuario sin necesidad de una contrase\u00f1a v\u00e1lida</p> <p>Para prevenir la inyecci\u00f3n SQL, se recomienda utilizar consultas parametrizadas o consultas preparadas, que permiten pasar los par\u00e1metros de forma segura sin concatenaci\u00f3n directa en la cadena SQL. Por ejemplo:</p> <pre><code>public boolean autenticarUsuario(Connection conexion, String nombreUsuario, String contrase\u00f1a) throws SQLException {\n    String consulta = \"SELECT * FROM Usuarios WHERE nombre = ? AND contrase\u00f1a = ?\";\n    PreparedStatement statement = conexion.prepareStatement(consulta);\n    statement.setString(1, nombreUsuario);\n    statement.setString(2, contrase\u00f1a);\n    ResultSet resultado = statement.executeQuery();\n\n    return resultado.next();\n}\n</code></pre>"},{"location":"ud10/4transactions/","title":"\u26a1Transacciones","text":"<p>En el \u00e1mbito de las Bases de Datos, una transacci\u00f3n es cualquier conjunto de sentencias SQL que se ejecutan como si de una sola se tratara. La idea principal es poder ejecutar varias sentencias, que est\u00e1n relacionadas de alguna manera, de forma que, si cualquiera de ellas fallara o produjera un error, no se ejecutara ninguna m\u00e1s e incluso se deshicieran todos los cambios que hayan podido efectuar las que ya se hab\u00edan ejecutado dentro de la misma transacci\u00f3n, por eso decimos, que las transacciones se consideran unitarias. Es decir, las operaciones que componen la transacci\u00f3n se deben ejecutar todas o ninguna. Esto ayuda a preservarla integridad de los datos e impide posibles desfases entre clientes y servidor.</p> <p>De entrada, cualquier sentencia SQL se considera una transacci\u00f3n en s\u00ed misma y si se produce un error durante su ejecuci\u00f3n se anular\u00e1n todas las operaciones simples derivadas de la ejecuci\u00f3n de la sentencia.</p> <p>Una transacci\u00f3n tiene dos finales posibles, <code>COMMIT</code> o <code>ROLLBACK</code>. Si se finaliza correctamente y sin problemas se har\u00e1 con <code>COMMIT</code>, con lo que los cambios se realizan en la base de datos, y si por alguna raz\u00f3n hay un fallo, se deshacen los cambios efectuados hasta ese momento, con la ejecuci\u00f3n de <code>ROLLBACK</code>.</p> <p></p> <p>Por defecto, al menos en MySQL, en una conexi\u00f3n trabajamos en modo autocommit con valor true. Eso significa que cada consulta es una transacci\u00f3n en la base de datos, es decir, que los cambios se aplicar\u00e1n en la base de datos una vez que la query se haya ejecutado correctamente.</p> <p>Por tanto, si queremos definir una transacci\u00f3n de varias operaciones, estableceremos el modo autocommit a false con el m\u00e9todo <code>setAutoCommit</code> de la clase <code>Connection</code>.</p> <p>En modo <code>no autocommit</code> las transacciones quedan definidas por las ejecuciones de los m\u00e9todos <code>commit</code> y <code>rollback</code>. Una transacci\u00f3n abarca desde el \u00faltimo commit o rollback hasta el siguiente commit. Los m\u00e9todos <code>commit</code> o <code>rollback</code> forman parte de la clase <code>Connection</code>.</p> <p>En la siguiente porci\u00f3n de c\u00f3digo, se puede ver un ejemplo sencillo de c\u00f3mo se puede utilizar <code>commit</code> y <code>rollback</code>: tras las operaciones se realiza el <code>commit</code>, y si ocurre una excepci\u00f3n, al capturarla realizar\u00edamos el <code>rollback</code>.</p> <pre><code>public static void execute (String [] sqlqueries) throws SQLException {\n    boolean autocommit = true;\n    String user = \"patricia\";\n    String password = \"marti\";\n    String url = \"jdbc:mysql://localhost/severo_ad\";\n\n    try (final Connection con = DriverManager.getConnection(url, user, password)) {\n        try (Statement stmt = con.createStatement()) {\n            autocommit = con.getAutoCommit();\n            con.setAutoCommit(false);\n\n            for (String query : sqlqueries) {\n                stmt.executeUpdate(query);\n            }\n            con.commit();\n            con.setAutoCommit(autocommit);\n        } catch (SQLException ex) {\n            con.rollback();\n            throw ex;\n        }\n    }\n}\n</code></pre>"},{"location":"ud10/6rendimiento/","title":"\ud83e\udde0 Mejora del rendimiento","text":"<p>Otro aspecto importante que mide la calidad de las aplicaciones es la eficiencia con la que se consigue comunicar con el SGBD. Para optimizar la conexi\u00f3n es importante reconocer qu\u00e9 procesos pueden actuar de cuello de botella y bajo qu\u00e9 circunstancias o qu\u00e9 otras agilizan las respuestas de los SGBD.</p> <ol> <li> <p>Analizar la petici\u00f3n de conexi\u00f3n a un SGBD porque se trata de un proceso costoso pero inevitable que hay que considerar.</p> </li> <li> <p>Estudiar las sentencias predefinidas (<code>PreparedStatement</code>), porqu\u00e9 su uso facilita la creaci\u00f3n de datos clave e \u00edndices temporales de modo que sea posible anticiparse a la demanda o disponer de los datos de forma mucho m\u00e1s r\u00e1pida.</p> </li> </ol>"},{"location":"ud10/6rendimiento/#ciclo-de-vida-de-una-conexion","title":"\ud83e\ude90 Ciclo de vida de una conexi\u00f3n","text":"<p>El establecimiento de una conexi\u00f3n es un procedimiento bastante lento, tanto en la parte cliente como la parte servidor. En la parte cliente, <code>DriverManager</code> debe descubrir el controlador correcto de entre todos los que tenga que gestionar. La mayor\u00eda de veces las aplicaciones trabajar\u00e1n s\u00f3lo con un \u00fanico controlador, pero hay que tener en cuenta que <code>DriverManager</code> no conoce a priori qu\u00e9 URL de conexi\u00f3n corresponde a cada controlador, y para averiguarlo env\u00eda una petici\u00f3n de conexi\u00f3n a cada controlador que tenga registrado, el controlador que no le devuelve error ser\u00e1 el correcto.</p> <p>En el lado servidor, se crear\u00e1 un contexto espec\u00edfico y se habilitar\u00e1n un conjunto de recursos para cada cliente conectado. Es decir, que durante la petici\u00f3n de conexi\u00f3n del SGBD debe gastar un tiempo considerable antes de no dejar operativa la comunicaci\u00f3n cliente-servidor.</p> <p>Este elevado gasto de tiempo concentrado en el momento de la petici\u00f3n de conexi\u00f3n nos hace plantear si podemos considerar ineficiente abrir y cerrar la conexi\u00f3n cada vez que tengamos que ejecutar una sentencia SQL, como hemos hecho hasta ahora. Desafortunadamente no hay una \u00fanica respuesta, sino que depende de la frecuencia de uso de la conexi\u00f3n y el n\u00famero de conexiones contra un mismo SGBD coexistiendo al mismo tiempo.</p> <p></p> <p>Como en todo, se trata de encontrar {==el punto de equilibrio entre la cantidad de recursos empleados por conexi\u00f3n y la rentabilidad que se saca en mantenerlas abiertas==}. </p> <ul> <li> <p>Si el n\u00famero de clientes, y por tanto de conexiones, es bajo y la frecuencia de uso es alta, ser\u00e1 preferible mantener las conexiones abiertas mucho tiempo. </p> </li> <li> <p>Por el contrario, si el n\u00famero de conexiones es muy alto y el uso infrecuente, lo que ser\u00e1 preferible ser\u00e1 abrir y cerrar la conexi\u00f3n cada vez que se necesite. </p> </li> </ul> <p>Mientras tanto, habr\u00e1 una multitud de casos en que la soluci\u00f3n consistir\u00e1 en mantener las conexiones abiertas, pero no permanentemente. Se puede dar un tiempo de vida a cada conexi\u00f3n, o bien cerrarlas despu\u00e9s de restar inactiva una cantidad determinada de tiempo, o se puede usar el criterio de mantener un n\u00famero m\u00e1ximo de conexiones abiertas, cerrando las m\u00e1s antiguas o las m\u00e1s inactivas cuando se sobrepase el l\u00edmite.</p> <p>\ud83d\ude36\u200d\ud83c\udf2b\ufe0f Nota</p> <p>Por otra parte, hay que tener en cuenta tambi\u00e9n que una misma aplicaci\u00f3n puede trabajar con varias conexiones simult\u00e1neamente para incrementar la eficiencia. Cada conexi\u00f3n abre un hilo de ejecuci\u00f3n independiente, por lo que es posible el env\u00edo simult\u00e1neo de peticiones.</p>"},{"location":"ud10/6rendimiento/#sentencias-predefinidas","title":"\u26a1 Sentencias predefinidas","text":"<p><code>PreparedStatement</code> presenta ventajas sobre su antecesor <code>Statement</code> cuando tengamos que trabajar con sentencias que haya que ejecutar varias veces. </p> \u2b50Statement\u2b50 \u2b50PreparedStatement\u2b50 Statement is usually parsed and executed each time. PreparedStatement is parsed once and executed with different parameters repeatedly. A statement is a static Sql statement.It does not support parameters. A PreparedStatement is a dynamic Sql statement.It does supports parameters. It is slower because every time the statements get parsed and executed. This is faster because this is precompiled once and gets executed with different parameters. Statement verifies metadata against database everytime. PreparedStatement verifies metadata against database only once. If we want to execute sql statement once it is recommended to use statement. If we want to execute sql statements repeatedly it is recommended to use PreparedStatement. <p>La raz\u00f3n es que cualquier sentencia SQL, cuando se env\u00eda el SGBD ser\u00e1 compilada antes de ser ejecutada. Usando un objeto <code>Statement</code>, cada vez que hacemos una ejecuci\u00f3n de una sentencia, ya sea v\u00eda executeUpdate o bien v\u00eda executeQuery, el SGBD la compilar\u00e1, ya que le llegar\u00e1 en forma de cadena de caracteres.</p> <p>En cambio, al <code>PreparedStament</code> la sentencia nunca var\u00eda y por lo tanto se puede compilar y almacenar dentro del mismo objeto, por lo que las siguientes veces que se ejecute no habr\u00e1 que compilarla. Esto reducir\u00e1 sensiblemente el tiempo de ejecuci\u00f3n. La parametrizaci\u00f3n, adem\u00e1s, ayuda a crear sentencias muy gen\u00e9ricas que se puedan reutilizar f\u00e1cilmente.</p> <p>En algunos sistemas gestores, adem\u00e1s, usar <code>PreparedStatement</code> puede llegar a suponer m\u00e1s ventajas, ya que utilizan la secuencia de bytes de la sentencia para detectar si se trata de una sentencia nueva o ya se ha servido con anterioridad. De esta manera se propicia que el sistema almacene las respuestas en la cach\u00e9, de manera que se puedan entregar de forma m\u00e1s r\u00e1pida.</p> <p>Important \ud83e\udd14</p> <p>The use of a <code>Statement</code> in JDBC should be 100% localized to being used for DDL (ALTER, CREATE, GRANT, etc) as these are the only statement types that cannot accept BIND VARIABLES. <code>PreparedStatements</code> or <code>CallableStatements</code> should be used for EVERY OTHER type of statement (DML, Queries). As these are the statement types that accept bind variables.</p> <p>This is a fact, a rule, a law -- use prepared statements EVERYWHERE. Use STATEMENTS almost no where.</p>"},{"location":"ud10/6rendimiento/#ejemplos-de-problemas-con-statement","title":"\ud83d\udcdd Ejemplos de problemas con Statement","text":"<ul> <li> 1. <code>Statement</code> acepta cadenas como consultas SQL. Por lo tanto, el c\u00f3digo se vuelve menos legible cuando concatenamos cadenas SQL:</li> </ul> <pre><code>public void insert(PersonEntity personEntity) {\n    String query = \"INSERT INTO persons(id, name, age, email) VALUES(\" + personEntity.getId() \n                    + \", '\" + personEntity.getName() + \", '\" + personEntity.getAge() \n                    + \", '\" + personEntity.getEmail() + \"')\";\n\n    Statement statement = connection.createStatement();\n    statement.executeUpdate(query);\n}\n</code></pre> <ul> <li> 2. Es vulnerable a la inyecci\u00f3n de SQL. </li> </ul> <pre><code>public void check(String name) {\n    String query = \"SELECT * FROM users WHERE name = '\" + name + \"';\";\n\n    Statement statement = connection.createStatement();\n    statement.executeUpdate(query);\n}\n</code></pre> <p>Si un usuario malintencionado escribe como nombre de usuario a consultar: </p> <p><code>Alicia'; DROP TABLE usuarios; SELECT * FROM datos WHERE nombre LIKE '%</code></p> <p>Se generar\u00eda la siguiente consulta SQL, (el color verde es lo que pretende el programador, el azul es el dato, y el rojo, el c\u00f3digo SQL inyectado):</p> <p></p> <p>En la base de datos se ejecutar\u00eda la consulta en el orden dado, se seleccionar\u00edan todos los registros con el nombre 'Alicia', se borrar\u00eda la tabla 'usuarios' y finalmente se seleccionar\u00eda toda la tabla \"datos\", que no deber\u00eda estar disponible para los usuarios web comunes.'</p>"},{"location":"ud10/7projectstructure%20copy/","title":"\ud83e\udded Estructura de un proyecto con JDBC","text":"<p>Para las tareas de clase vamos a seguir una estructura que iremos perfilando basada en el MVC (modelo - vista - controlador). En el IntelliJ, crearemos un nuevo proyecto con la siguiente distribuci\u00f3n de paquetes:</p> <p></p>"},{"location":"ud10/7projectstructure%20copy/#1-creando-la-bbdd","title":"1\ufe0f\u20e3 - Creando la BBDD","text":"<p>Lo primero que tendremos que hacer asegurarnos de que tenemos el servidor de base de datos instalado y la base de datos creada con las tablas que necesitemos para nuestra aplicaci\u00f3n.</p> <p></p> <p>Creamos tambi\u00e9n la tabla login con la que vamos a trabajar en los ejemplos:</p> <pre><code>CREATE TABLE `login` (\n    `id` int NOT NULL AUTO_INCREMENT,\n    `user_name` varchar(50) NOT NULL,\n    `password` varchar(255) NOT NULL,\n    `created_at` datetime DEFAULT CURRENT_TIMESTAMP,\n    PRIMARY KEY (`id`),\n    UNIQUE KEY `user_name` (`user_name`)\n);\n</code></pre>"},{"location":"ud10/7projectstructure%20copy/#2-clase-connection","title":"2\ufe0f\u20e3 - Clase <code>Connection</code>","text":"<p>Conectar a la BD es un coste muy grande, ya que es un proceso lento, por lo tanto, implementaremos la clase de conexi\u00f3n a la base de datos utilizando el patr\u00f3n singleton. </p> <p>Esta clase estar\u00e1 ubicada dentro del paquete util.</p> <p>Ejemplo de conexi\u00f3n a la BBDD usando Singleton:</p> DatabaseConnection.java<pre><code>public class DatabaseConnection {\n\n    private static Connection connection = null;\n\n    private DatabaseConnection() {}\n\n    static\n    {\n        String url = \"jdbc:mysql://localhost/severo\";\n        String user = \"patricia\";\n        String password = \"marti\";\n        try {\n            connection = DriverManager.getConnection(url, user, password);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static Connection getConnection() {\n        return connection;\n    }\n\n    public static void close() throws SQLException {\n        connection.close();\n    }\n}\n</code></pre>"},{"location":"ud10/7projectstructure%20copy/#3-creando-el-modelo","title":"3\ufe0f\u20e3 - Creando el modelo","text":"<p>{++El modelo contiene una representaci\u00f3n de los datos que maneja la aplicaci\u00f3n y su l\u00f3gica de negocio++}.</p> <p>Para el ejemplo, el modelo de <code>Login</code> debe contener los atributos que contiene la tabla login como variables de la clase Normalmente los modelos de la clase se encuentran en un paquete llamado model.</p> Login.java<pre><code>public class Login {\n\n    private int id;\n    private String username;\n    private String password;\n    private LocalDateTime createdAt;\n\n    //constructors\n\n    //getters y setters\n\n    @Override\n    public String toString() {\n        return \"Login{\" +\n                \"id=\" + id +\n                \", username='\" + username + '\\'' +\n                \", password='\" + password + '\\'' +\n                \", createdAt=\" + createdAt +\n                '}';\n    }\n}\n</code></pre>"},{"location":"ud10/7projectstructure%20copy/#4-clases-para-la-manipulacion-de-la-base-de-datos","title":"4\ufe0f\u20e3 - Clases para la manipulaci\u00f3n de la base de datos","text":"<p>Dentro del paquete mysql a\u00f1adiremos clases que ser\u00e1n las encargadas de manipular la informaci\u00f3n contra la base de datos. </p> <p>En el ejemplo tenemos una clase que realiza la manipulaci\u00f3n de la informaci\u00f3n referente a la tabla login.</p> LoginAccessDB.java<pre><code>public class LoginAccessDB {\n\nprivate static Connection con = DatabaseConnection.getConnection();\n\n    public List&lt;Login&gt; getLogins() throws SQLException {\n\n        String sql = \"SELECT * FROM login\";\n        try (Statement statement = con.createStatement()) {\n            List&lt;Login&gt; lg = new ArrayList&lt;&gt;();\n            ResultSet resultSet = statement.executeQuery(sql);\n\n            while (resultSet.next()) {\n                Login login = new Login();\n                login.setId(resultSet.getInt(1));\n                login.setUsername(resultSet.getString(\"username\"));\n                login.setPassword(resultSet.getString(\"password\"));\n                login.setCreatedAt(resultSet.getTimestamp(\"created_at\").toLocalDateTime());\n                lg.add(login);\n            }\n\n            return lg;\n        }\n    }\n}\n</code></pre> <p>\ud83d\ude36\u200d\ud83c\udf2b\ufe0f Nota</p> <p>M\u00e1s adelante veremos que hay clases que siguen el patr\u00f3n DAO que se encargan del acceso a base de datos.</p>"},{"location":"ud10/7projectstructure%20copy/#5-test","title":"5\ufe0f\u20e3 - Test","text":"<p>Por \u00faltimo comprobamos que todo funciona correctamente haciendo una peque\u00f1a prueba en nuestro <code>main</code> o punto de entrada al programa.</p> MainApp.java<pre><code>public class MainApp {\n\n    public static void main(String[] args) {\n        LoginAccessDB loginHandleDB = new LoginAccessDB();\n        try {\n            for (Login l: loginHandleDB.getLogins()) {\n                System.out.println(l);\n            }\n        } catch (SQLException ex) {\n            System.out.println(\"SQLException: \" + ex.getMessage());\n            System.out.println(\"SQLState: \" + ex.getSQLState());\n            System.out.println(\"VendorError: \" + ex.getErrorCode());\n        }\n    }\n}\n</code></pre>"},{"location":"ud10/7projectstructure%20copy/#6-fichero-readme","title":"6\ufe0f\u20e3 - Fichero README","text":"<p>Readme: el propio nombre, {++l\u00e9eme++}, indica su prop\u00f3sito: {++ser le\u00eddo++}. El archivo readme es el primer archivo que un desarrollador debe mirar antes de embarcarse en un proyecto, por lo que tambi\u00e9n es esencial saber c\u00f3mo escribir un buen archivo readme, para que toda la informaci\u00f3n relevante se presente de forma compacta.</p> <p>Consejo</p> <p>El nombre del archivo se escribe README en may\u00fasculas. De este modo, los sistemas que diferencian entre may\u00fasculas y min\u00fasculas listar\u00e1n el archivo antes que todos los dem\u00e1s archivos que empiezan con min\u00fasculas.</p>"},{"location":"ud10/7projectstructure%20copy/#que-suelen-incluir-los-ficheros-readme","title":"\u00bfQu\u00e9 suelen incluir los ficheros README?","text":"<p>Suelen incluir informaci\u00f3n sobre:</p> <ul> <li>Una descripci\u00f3n general del sistema o proyecto.</li> <li>El estado del proyecto, que es particularmente importante si el proyecto est\u00e1 todav\u00eda en desarrollo. En \u00e9l se mencionan los cambios planeados y la direcci\u00f3n de desarrollo del proyecto, y se especifica directamente si un proyecto est\u00e1 terminado.</li> <li>Los requisitos del entorno de desarrollo para la integraci\u00f3n.</li> <li>Una lista de las tecnolog\u00edas utilizadas y, cuando proceda, enlaces con m\u00e1s informaci\u00f3n.</li> <li>Bugs conocidos y posibles correcciones de errores.</li> <li>Secci\u00f3n de preguntas frecuentes con todas las preguntas planteadas hasta la fecha.</li> <li>Informaci\u00f3n sobre derechos de autor y licencias.</li> </ul>"},{"location":"ud10/7projectstructure%20copy/#como-escribir-un-fichero-readme","title":"C\u00f3mo escribir un fichero README","text":"<p>El contenido del fichero README debe estar en ingl\u00e9s.</p> <p></p> <p>C\u00f3mo crear un fichero README</p>"},{"location":"ud10/7projectstructure%20copy/#exportar-la-bbdd-de-mysql","title":"Exportar la BBDD de MySQL","text":"<p>En MySQL workbench seleccionamos Server \u2192 Data Export</p> <p></p> <p>Selecciono el esquema de BBDD que quiero exportar y hago click en Start export</p> <p></p> <p>Workbench me muestra d\u00f3nde se ha generado el fichero:</p> <p></p>"},{"location":"ud10/7projectstructure/","title":"\ud83e\udded Estructura de un proyecto con JDBC","text":"<p>Para las tareas de clase vamos a seguir una estructura que iremos perfilando basada en el MVC (modelo - vista - controlador). La idea principal es permitir independizar la l\u00f3gica y la parte visual y la procedencia de los datos, usando un controlador que administra los procesos sirviendo de puente entre estos.</p> <p></p> <p>En el IntelliJ, crearemos un nuevo proyecto con la siguiente distribuci\u00f3n de paquetes:</p> <p></p>"},{"location":"ud10/7projectstructure/#1-creando-la-bbdd","title":"1\ufe0f\u20e3 - Creando la BBDD","text":"<p>Vamos a crear la base de datos en MySql. Esta puede ser creada previamente o ser creada en el mismo programa al inicio de la sesi\u00f3n comprobando si existe o no existe. <pre><code>create schema if not exists `mi_DB`;\n\nuse `mi_DB`;\n\ncreate table if not exists `Persona`(\n    `id` int not null auto_increment,\n    `dni` varchar(9) not null,\n    `nombre` varchar(50) not null,\n    `apellido` varchar(50) not null,\n    `edad` int not null,\n    primary key(`id`),\n    unique key(`dni`)    \n);\n</code></pre> Y vamos a insertar algunos datos de ejemplo</p> <pre><code>INSERT INTO Persona (dni, nombre, apellido, edad) \nVALUES ('12345678A', 'Juan', 'P\u00e9rez', 30),\n       ('87654321B', 'Mar\u00eda', 'Gonz\u00e1lez', 25),\n       ('55555555C', 'Pedro', 'Mart\u00ednez', 40),\n       ('99999999D', 'Laura', 'L\u00f3pez', 35),\n       ('11111111E', 'Ana', 'S\u00e1nchez', 28);\n</code></pre>"},{"location":"ud10/7projectstructure/#2-clase-connection","title":"2\ufe0f\u20e3 - Clase <code>Connection</code>","text":"<p>Para el paquete <code>db</code> vamos a crear la clase <code>DBConnection</code>, esta clase mantendr\u00e1 una \u00fanica conexi\u00f3n hacia la base de datos utilizando el patr\u00f3n Singleton. </p> <p></p>"},{"location":"ud10/7projectstructure/#patron-singleton","title":"Patr\u00f3n Singleton","text":"<p>El patr\u00f3n Singleton es un patr\u00f3n de dise\u00f1o de software que garantiza que una clase tenga solo una instancia y proporciona un punto de acceso global a esa instancia. Esto es \u00fatil cuando solo se necesita una instancia de una clase para coordinar acciones en todo el sistema, como por ejemplo, un objeto de conexi\u00f3n a una base de datos, un registro de eventos, un gestor de configuraci\u00f3n, entre otros.</p> <p></p> <p>Para evitar la creaci\u00f3n de nuevas instancias, se crea un constructor privado y se mantiene un variable de instancia static a una \u00fanica instancia.</p> DBConnection.java<pre><code>public class DBConnection {\n    // URL de conexi\u00f3n a la base de datos MySQL\n    private static final String URL = \"jdbc:mysql://localhost:3306/mi_db\";\n    private static final String USERNAME = \"root\";\n    private static final String PASSWORD = \"root123456\";\n\n    private static Connection connection;\n\n    // Constructor privado para evitar instancias directas\n    private DBConnection() {}\n\n    // M\u00e9todo est\u00e1tico para obtener la instancia \u00fanica de la conexi\u00f3n\n    public static Connection getConnection() {\n        if (connection == null) {\n            // Bloqueo sincronizado para evitar concurrencia\n            synchronized (DBConnection.class) {\n                if (connection == null) {\n                    try {\n                       // Establecer la conexi\u00f3n\n                        connection = DriverManager.getConnection(URL, USERNAME, PASSWORD);\n                    } catch ( SQLException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n        return connection;\n    }\n\n    // M\u00e9todo para cerrar la conexi\u00f3n\n    public static void closeConnection() {\n        if (connection != null) {\n            try {\n                connection.close();\n                connection = null;\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"ud10/7projectstructure/#3-creando-el-modelo","title":"3\ufe0f\u20e3 - Creando el modelo","text":"<p>El modelo contiene una representaci\u00f3n de los datos que maneja la aplicaci\u00f3n y su l\u00f3gica de negocio. Permitir\u00e1 mediante clases POJO identificar y asociar el modelo relacional con los objetos que manejar\u00e1 la aplicaci\u00f3n</p> <p>Para el ejemplo, creamos una clase <code>persona</code> que debe contener los atributos que contiene la tabla <code>pesona</code> como variables de la clase. Normalmente los modelos de la clase se encuentran en un paquete llamado model.</p> <p></p> Persona.java<pre><code>public class Persona {\n    private int id;\n    private String dni;\n    private String nombre;\n    private String apellido;\n    private int edad;\n\n    public Persona(String dni, String nombre, String apellido, int edad) {\n        this.dni = dni;\n        this.nombre = nombre;\n        this.apellido = apellido;\n        this.edad = edad;\n    }\n    //gette y setter\n}\n</code></pre>"},{"location":"ud10/7projectstructure/#4-patron-dao-clases-para-la-manipulacion-de-la-base-de-datos","title":"4\ufe0f\u20e3 - Patr\u00f3n DAO. Clases para la manipulaci\u00f3n de la base de datos","text":"<p>El patr\u00f3n DAO (Data Access Object) es un patr\u00f3n de dise\u00f1o que se utiliza para separar la l\u00f3gica de acceso a los datos de la l\u00f3gica de negocio en una aplicaci\u00f3n. Su objetivo principal es abstraer y encapsular todas las operaciones de acceso a la base de datos en un conjunto de clases dedicadas, permitiendo as\u00ed una mayor flexibilidad, reutilizaci\u00f3n de c\u00f3digo y mantenibilidad del sistema. </p> <p>Permitir\u00e1 la sustituci\u00f3n del Gestor de Base de Datos sin que afecte al resto del programa.</p> <p></p> <p>En el ejemplo tenemos una clase en el paquete <code>db</code> que realiza el CRUD de la informaci\u00f3n referente a la tabla <code>persona</code>.</p> <p></p> PersonaDAO.java<pre><code>public class PersonaDAO {\n    // Objeto de conexi\u00f3n a la base de datos. Recuerda el patr\u00f3n singleton de DBConnection\n    private Connection connection=DBConnection.getConnection();\n\n    // Consultas SQL para manipular la tabla Persona\n    private static final String INSERT_QUERY = \"INSERT INTO Persona (dni, nombre, apellido, edad) VALUES (?, ?, ?, ?)\";\n    private static final String SELECT_ALL_QUERY = \"SELECT * FROM Persona\";\n    private static final String SELECT_BY_DNI_QUERY = \"SELECT * FROM Persona WHERE dni = ?\";\n    private static final String UPDATE_QUERY = \"UPDATE Persona SET nombre = ?, apellido = ?, edad = ? WHERE dni = ?\";\n    private static final String DELETE_QUERY = \"DELETE FROM Persona WHERE dni = ?\";\n\n    // M\u00e9todo para insertar una nueva persona en la base de datos\n    public void insertPersona(Persona persona) throws SQLException {\n        try (PreparedStatement statement = connection.prepareStatement(INSERT_QUERY)) {\n            statement.setString(1, persona.getDni());\n            statement.setString(2, persona.getNombre());\n            statement.setString(3, persona.getApellido());\n            statement.setInt(4, persona.getEdad());\n\n            statement.executeUpdate();\n        }\n    }\n\n    // M\u00e9todo para obtener todas las personas de la base de datos\n    public List&lt;Persona&gt; getAllPersonas() throws SQLException {\n        List&lt;Persona&gt; personas = new ArrayList&lt;&gt;();\n        try (PreparedStatement statement = connection.prepareStatement(SELECT_ALL_QUERY)) {\n            ResultSet resultSet = statement.executeQuery();\n            while (resultSet.next()) {\n                Persona persona = resulSetToPersona(resultSet);\n                personas.add(persona);\n            }\n        }\n        return personas;\n    }\n\n    // M\u00e9todo para obtener una persona por su DNI\n    public Persona getPersonaByDni(String dni) throws SQLException {\n        Persona persona = null;\n        try (PreparedStatement statement = connection.prepareStatement(SELECT_BY_DNI_QUERY)) {\n            statement.setString(1, dni);\n            ResultSet resultSet = statement.executeQuery();\n            if (resultSet.next()) {\n                persona = resulSetToPersona(resultSet);\n            }\n        }\n        return persona;\n    }\n\n    // M\u00e9todo para actualizar los datos de una persona en la base de datos\n    public void updatePersona(Persona persona) throws SQLException {\n        try (PreparedStatement statement = connection.prepareStatement(UPDATE_QUERY)) {\n            statement.setString(1, persona.getNombre());\n            statement.setString(2, persona.getApellido());\n            statement.setInt(3, persona.getEdad());\n            statement.setString(4, persona.getDni());\n\n            statement.executeUpdate();\n        }\n    }\n\n    // M\u00e9todo para eliminar una persona de la base de datos por su DNI\n    public void deletePersonaByDni(String dni) throws SQLException {\n        try (PreparedStatement statement = connection.prepareStatement(DELETE_QUERY)) {\n            statement.setString(1, dni);\n            statement.executeUpdate();\n        }\n    }\n\n    // M\u00e9todo auxiliar para mapear un ResultSet en la \n    //posici\u00f3n actual a un objeto Persona\n    private Persona resulSetToPersona(ResultSet resultSet) throws SQLException {\n        Persona persona = new Persona(\n                resultSet.getString(\"dni\"),\n                resultSet.getString(\"nombre\"),\n                resultSet.getString(\"apellido\"),\n                resultSet.getInt(\"edad\"));\n        return persona;\n    }\n}\n</code></pre> <p>Patr\u00f3n Repository</p> <p>Actualmente, el acceso puede venir de varias fuentes de datos, como puede ser una base de datos por un lado y un servicio web por otro. El patr\u00f3n DAO, ha evolucionado al patr\u00f3n Repository que permite seleccionar la fuente de datos aislando del problema a las capas superiores </p>"},{"location":"ud10/7projectstructure/#5-vista","title":"5\ufe0f\u20e3 - Vista","text":"<p>En el paquete <code>view</code> mantenemos las clases encargadas para mostrar y recibir la informaci\u00f3n del usuario. Nosotros vamos a simplificar el programa por consola, pero una aplicaci\u00f3n web o un programa JavaFX, manejar\u00e1 la interacci\u00f3n de eventos visuales con el usuario y avisar\u00e1 de ello al <code>Controller</code></p> <p></p> <p>Simplificando nuestro programa a consola, podemos tener la siguiente interacci\u00f3n con el usuario.</p> <p></p> VistaPersona.java<pre><code>public class VistaPersona {\n    public Scanner scanner;\n\n    public VistaPersona() {\n        scanner = new Scanner(System.in);\n    }\n\n    public void mostrarPersonas(List&lt;Persona&gt; personas) {\n        System.out.println(\"Lista de Personas:\");\n        for (Persona persona : personas) {\n            System.out.println(persona);\n        }\n    }\n\n    public Persona crearPersona() {\n        System.out.println(\"Introduce el DNI:\");\n        String dni = scanner.nextLine();\n        System.out.println(\"Introduce el nombre:\");\n        String nombre = scanner.nextLine();\n        System.out.println(\"Introduce el apellido:\");\n        String apellido = scanner.nextLine();\n        System.out.println(\"Introduce la edad:\");\n        int edad = Integer.parseInt(scanner.nextLine());\n\n        return new Persona(dni, nombre, apellido, edad);\n    }\n\n    public String obtenerDniAEliminar() {\n        System.out.println(\"Introduce el DNI de la persona a eliminar:\");\n        return scanner.nextLine();\n    }\n\n    public Persona obtenerDatosActualizados() {\n        System.out.println(\"Introduce el nuevo nombre:\");\n        String nombre = scanner.nextLine();\n        System.out.println(\"Introduce el nuevo apellido:\");\n        String apellido = scanner.nextLine();\n        System.out.println(\"Introduce la nueva edad:\");\n        int edad = Integer.parseInt(scanner.nextLine());\n\n        return new Persona(\"\", nombre, apellido, edad); // DNI no es necesario para actualizar\n    }\n\n    public void mostrarMensaje(String mensaje) {\n        System.out.println(mensaje);\n    }\n\n    public String obtenerDni() {\n        System.out.println(\"Introduce el DNI de la persona:\");\n        return scanner.nextLine();\n    }\n    //muestra los datos de la persona\n    public void mostrarPersona(Persona persona) {\n        if(persona!=null)\n            System.out.println(persona);\n        else\n            System.out.println(\"La persona no existe\");\n    }\n\n    // Otros m\u00e9todos de la vista...\n}\n</code></pre>"},{"location":"ud10/7projectstructure/#6-controller","title":"6\ufe0f\u20e3 - Controller","text":"<p>El `Controller'(controlador) es una parte fundamental en la arquitectura del patr\u00f3n Modelo-Vista-Controlador (MVC). Su tarea principal es actuar como intermediario entre el modelo (que maneja los datos de la aplicaci\u00f3n) y la vista (que muestra la interfaz de usuario). El controlador interpreta las acciones del usuario desde la vista, realiza las operaciones necesarias en el modelo y actualiza la vista en consecuencia. En resumen, el controlador coordina la interacci\u00f3n entre el modelo y la vista para garantizar que la aplicaci\u00f3n funcione correctamente y responda a las acciones del usuario de manera adecuada.</p> <p></p> <p>En nuestro caso, mantenemos en la clase, instancias del DAO y VIEW de forma simplificada que permiten manejar el CRUD mediante el DAO con los datos obtenidos en la VIEW</p> <p></p> ControllerPersona.java<pre><code>public class ControllerPersona {\n    private PersonaDAO personaDAO;\n    private VistaPersona vistaPersona;\n\n    public ControllerPersona() {\n        // Crear la instancias DAO y VIEW\n\n            personaDAO = new PersonaDAO();\n            vistaPersona = new VistaPersona();\n    }\n\n    public void mostrarTodasLasPersonas() {\n        try {\n            //recupera las personas\n            List&lt;Persona&gt; personas = personaDAO.getAllPersonas();\n            //las muestra en la Vista\n            vistaPersona.mostrarPersonas(personas);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n    public void mostraPersonaDNI() {\n        try {\n            String dni = vistaPersona.obtenerDni();\n            //recupera Persona del DAO\n            Persona persona = personaDAO.getPersonaByDni(dni);\n            vistaPersona.mostrarPersona(persona);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void crearPersona() {\n        try {\n            Persona persona=vistaPersona.crearPersona();\n            personaDAO.insertPersona(persona);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void actualizarPersona() {\n        try {\n            Persona persona=vistaPersona.obtenerDatosActualizados();\n            personaDAO.updatePersona(persona);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void eliminarPersona() {\n        try {\n            String dni=vistaPersona.obtenerDniAEliminar();\n            personaDAO.deletePersonaByDni(dni);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n    // Otros m\u00e9todos del controlador...\n}\n</code></pre> <p>Podemos tener una clase principal con un men\u00fa que realmente podr\u00eda ser parte del View, pero para simplificar vamos a crear como inicio de la aplicaci\u00f3n. Mostrar\u00e1 un men\u00fa que permitir\u00e1 llamar al controller en diferentes acciones</p> <p></p> Main.java<pre><code>public class Main {\n    public static void main(String[] args) {\n\n        ControllerPersona controlador = new ControllerPersona();\n        Scanner scanner = new Scanner(System.in);\n\n        int opcion;\n        do {\n            System.out.println(\"\\nMen\u00fa:\");\n            System.out.println(\"1. Mostrar todas las personas\");\n            System.out.println(\"2. Crear persona\");\n            System.out.println(\"3. Actualizar persona\");\n            System.out.println(\"4. Eliminar persona\");\n            System.out.println(\"5. Mostrar persona por DNI\");\n            System.out.println(\"6. Salir\");\n            System.out.print(\"Elige una opci\u00f3n: \");\n            opcion = Integer.parseInt(scanner.nextLine());\n\n            switch (opcion) {\n                case 1:\n                    controlador.mostrarTodasLasPersonas();\n                    break;\n                case 2:\n                    controlador.crearPersona();\n                    System.out.println(\"Persona creada correctamente.\");\n                    break;\n                case 3:\n                    controlador.actualizarPersona();\n                    System.out.println(\"Persona actualizada correctamente.\");\n                    break;\n                case 4:\n                    controlador.eliminarPersona();\n                    System.out.println(\"Persona eliminada correctamente.\");\n                    break;\n                case 5:\n                    controlador.mostraPersonaDNI();\n                    break;\n                case 6:\n                    System.out.println(\"Saliendo...\");\n                    break;\n                default:\n                    System.out.println(\"Opci\u00f3n no v\u00e1lida.\");\n            }\n        } while (opcion != 6);\n    }\n}\n</code></pre>"},{"location":"ud10/7projectstructure/#fichero-readme","title":"Fichero README","text":"<p>Readme: el propio nombre, l\u00e9eme, indica su prop\u00f3sito: {++ser le\u00eddo++}. El archivo readme es el primer archivo que un desarrollador debe mirar antes de embarcarse en un proyecto, por lo que tambi\u00e9n es esencial saber c\u00f3mo escribir un buen archivo readme, para que toda la informaci\u00f3n relevante se presente de forma compacta.</p> <p>Consejo</p> <p>El nombre del archivo se escribe README en may\u00fasculas. De este modo, los sistemas que diferencian entre may\u00fasculas y min\u00fasculas listar\u00e1n el archivo antes que todos los dem\u00e1s archivos que empiezan con min\u00fasculas.</p>"},{"location":"ud10/7projectstructure/#que-suelen-incluir-los-ficheros-readme","title":"\u00bfQu\u00e9 suelen incluir los ficheros README?","text":"<p>Suelen incluir informaci\u00f3n sobre:</p> <ul> <li>Una descripci\u00f3n general del sistema o proyecto.</li> <li>El estado del proyecto, que es particularmente importante si el proyecto est\u00e1 todav\u00eda en desarrollo. En \u00e9l se mencionan los cambios planeados y la direcci\u00f3n de desarrollo del proyecto, y se especifica directamente si un proyecto est\u00e1 terminado.</li> <li>Los requisitos del entorno de desarrollo para la integraci\u00f3n.</li> <li>Una lista de las tecnolog\u00edas utilizadas y, cuando proceda, enlaces con m\u00e1s informaci\u00f3n.</li> <li>Bugs conocidos y posibles correcciones de errores.</li> <li>Secci\u00f3n de preguntas frecuentes con todas las preguntas planteadas hasta la fecha.</li> <li>Informaci\u00f3n sobre derechos de autor y licencias.</li> </ul>"},{"location":"ud10/7projectstructure/#como-escribir-un-fichero-readme","title":"C\u00f3mo escribir un fichero README","text":"<p>El contenido del fichero README debe estar en ingl\u00e9s.</p> <p></p> <p>C\u00f3mo crear un fichero README</p>"},{"location":"ud10/7projectstructure/#exportar-la-bbdd-de-mysql","title":"Exportar la BBDD de MySQL","text":"<p>En MySQL workbench seleccionamos Server \u2192 Data Export</p> <p></p> <p>Selecciono el esquema de BBDD que quiero exportar y hago click en Start export</p> <p></p> <p>Workbench me muestra d\u00f3nde se ha generado el fichero:</p> <p></p>"},{"location":"ud2/00algoritmos/","title":"Introducci\u00f3n a los algoritmos .","text":""},{"location":"ud2/00algoritmos/#introduccion","title":"Introducci\u00f3n","text":"<p>Un computador es capaz de realizar determinadas acciones sencillas, como sumar, restar o transferir datos. Estas acciones son \u00fatiles, pero los problemas que normalmente interesa resolver son m\u00e1s complejos. Para solucionar un problema real, es necesario encontrar un m\u00e9todo de resoluci\u00f3n del problema y, posteriormente, descomponerlo en acciones sencillas, que el computador sea capaz de realizar.</p> <p></p> <p>Un algoritmo es una serie de pasos organizados, que describe el proceso que se debe seguir, para dar soluci\u00f3n a un problema espec\u00edfico. Por ejemplo, una receta para un robot de cocina puede ser</p> <ol> <li> <p>Espera a que introduzca ma\u00edz y mantequilla.</p> </li> <li> <p>Gira durante un minuto, avanzando progresivamente de la velocidad 1     a la 5.</p> </li> </ol> <p></p> <ol> <li> <p>Espera a que introduzca leche y sal.</p> </li> <li> <p>Gira durante 30 segundos a velocidad 7.</p> </li> <li> <p>Gira durante 10 minutos a velocidad 3 mientras cuece a una     temperatura de 90 grados.</p> </li> <li> <p>Se detiene. \u00a1La crema est\u00e1 lista!</p> </li> </ol> <p>Los algoritmos son los pilares en la inform\u00e1tica.</p> <p></p>"},{"location":"ud2/00algoritmos/#caracteristicas","title":"Caracter\u00edsticas","text":"<p>Un algoritmo tiene que ser:</p> <ul> <li> <p>Preciso: Es claro en cada uno de sus pasos</p> </li> <li> <p>Definido: Si se realiza el algoritmo dos o m\u00e1s veces con los mismos     datos siempre dar\u00e1 el mismo resultado</p> </li> <li> <p>Finito: Siempre va a tener un fin</p> </li> </ul> <p>Para resolver un mismo problema, se pueden definir infinidad de algoritmos. Normalmente interesa, no solo encontrar un algoritmo, sino que este sea eficiente</p>"},{"location":"ud2/00algoritmos/#estructura-del-algoritmo","title":"Estructura del algoritmo","text":"<p>Por lo general, el algoritmo tiene la estructura</p> <ul> <li> <p>Datos de entrada</p> </li> <li> <p>Seg\u00fan el problema a resolver, los datos son procesados</p> </li> <li> <p>Datos de salida con la soluci\u00f3n</p> </li> </ul> <p></p>"},{"location":"ud2/00algoritmos/#herramientas-para-definir-algoritmos","title":"Herramientas para definir algoritmos","text":"<p>Existe diversas herramientas para definir algoritmos. Nosotros vamos a ver brevemente dos de las m\u00e1s utilizada.</p> <ul> <li> <p>Pseudoc\u00f3digo</p> </li> <li> <p>Diagramas de flujo</p> </li> </ul>"},{"location":"ud2/00algoritmos/#pseudocodigo","title":"Pseudoc\u00f3digo","text":"<p>Una de las herramientas que permiten definir algoritmos es pseudoc\u00f3digo. El pseudoc\u00f3digo es un lenguaje que permite pasar casi de manera directa la soluci\u00f3n del problema a un lenguaje de programaci\u00f3n espec\u00edfico. El pseudoc\u00f3digo es una serie de pasos bien detallados y claros que conducen a la resoluci\u00f3n de un problema. La facilidad de pasar casi de forma directa el pseudoc\u00f3digo a la computadora ha dado como resultado que muchos programadores implementen de forma directa los programas en la computadora.</p> <p>https://es.wikipedia.org/wiki/Pseudoc%C3%B3digo</p>"},{"location":"ud2/00algoritmos/#ejemplo-volumen","title":"Ejemplo volumen:","text":"<p>El pseudoc\u00f3digo para determinar el volumen de una caja de dimensiones A, B y C se puede establecer de la siguiente forma:</p> <p></p> <p>1. Inicio</p> <p>2. Leer las medidas A, B y C</p> <p>3. Realizar el producto de A * B * C y guardarlo en V (V = A * B * C)</p> <p>4. Escribir el resultado V</p> <p>5. Fin</p> <p>Como se puede ver, se establece de forma precisa la secuencia de los pasos a realizar; adem\u00e1s, si se les proporciona siempre los mismos valores a las variables A, B y C, el resultado del volumen ser\u00e1 el mismo y, por consiguiente, se cuenta con un final.</p>"},{"location":"ud2/00algoritmos/#diagrama-de-flujo","title":"Diagrama de flujo","text":"<p>Los diagramas de flujo permiten representar visualmente qu\u00e9 operaciones se requieren y en qu\u00e9 secuencia se deben efectuar para solucionar un problema dado.</p> <p>https://es.wikipedia.org/wiki/Diagrama_de_flujo</p> <p></p> <p>Los diagramas de flujo desempe\u00f1an un papel vital en la programaci\u00f3n de un problema, ya que facilitan la comprensi\u00f3n de problemas complicados y sobre todo aquellos cuyos procesos son muy largos; generalmente, los diagramas de flujo se dibujan antes de comenzar a programar el c\u00f3digo fuente, que se insertar\u00e1 posteriormente en el ordenador.</p> <p>Dentro de los diagramas de flujo se pueden utilizar los s\u00edmbolos que se presentan a continuaci\u00f3n, con los cuales se indican las operaciones que se efectuar\u00e1n sobre los datos para producir un resultado.</p> <p></p>"},{"location":"ud2/00algoritmos/#ejemplo-volumen_1","title":"Ejemplo volumen","text":"<p>Se puede establecer la soluci\u00f3n del diagrama de flujo para determinar el volumen de una caja de dimensiones A, B y C como se muestra a continuaci\u00f3n.</p> <p></p> <p>Y como se puede ver de manera gr\u00e1fica, se establece de forma precisa la secuencia de los pasos por realizar para obtener el resultado del volumen. Como se puede verificar, son los mismos pasos que se establecieron en el algoritmo presentado previamente mediante el pseudoc\u00f3digo.</p>"},{"location":"ud2/00algoritmos/#importancia-de-pseudocodigo-y-diagramas-de-flujo","title":"Importancia de pseudoc\u00f3digo y diagramas de flujo","text":"<p>Es importante para un programador:</p> <ul> <li> <p>definir un algoritmo tanto en pseudoc\u00f3digo como en     diagrama de flujo para documentar un proyecto software</p> </li> <li> <p>entender un algoritmo tanto en pseudoc\u00f3digo como en     diagrama de flujo que haya desarrollado otro para poder traducirlo a     un lenguaje de programaci\u00f3n en concreto y resolver un problema.</p> </li> </ul>"},{"location":"ud2/00algoritmos/#pseint","title":"PSeInt","text":"<p>Como vemos, el pseudoc\u00f3digo nos permite mediante lenguaje natural describir un algoritmo que posteriormente se traducir\u00e1 a un lenguaje de programaci\u00f3n en concreto, pero tenemos herramientas educativas que nos permiten ejecutar dicho algoritmo como si de un lenguaje de programaci\u00f3n se tratara y comprobar que el algoritmo es correcto.</p> <p>PSeInt es una de estas herramientas. Vamos a trabajar con ella estos primeros d\u00edas para:</p> <ul> <li> <p>habituarnos a programar</p> </li> <li> <p>comprobar que nuestro algoritmo es correcto</p> </li> <li> <p>comenzar a ver las caracter\u00edsticas b\u00e1sicas de un     IDE     b\u00e1sico</p> </li> </ul> <p>Podemos descargarlo</p> <p>https://sourceforge.net/projects/pseint/</p> <p>Tenemos un completo manual de uso en</p> <p>https://www.youtube.com/watch?v=FvibfpSVFBw&amp;list=PLwOemaB2t99YhnRhGDN-izDQt1_8-LUXG&amp;index=1</p> <p>https://www.edu.xunta.gal/centros/iesblancoamorculleredo/aulavirtual/pluginfile.php/37189/mod_assign/intro/ApuntesPSEINT201617%20%281%29.pdf</p>"},{"location":"ud2/00algoritmos/#instalacion","title":"Instalaci\u00f3n","text":"<p>Descarga la versi\u00f3n de PSeInt para tu sistema operativo y ejec\u00fatalo. Tenemos versiones portables que no son necesarias instalarlas</p> <p></p> <p>Vamos a ver en Linux.</p> <ul> <li> <p>Descarga la versi\u00f3n de 64bits para Linux</p> </li> <li> <p>Descomprime el fichero</p> </li> <li> <p>Entra en la carpeta</p> </li> <li> <p>Bot\u00f3n derecho-&gt;Abrir terminal</p> </li> <li> <p>Escribe el comando</p> </li> </ul> <p>./pseint</p> <p></p> <ul> <li>Deja que cree los lanzadores</li> </ul> <p></p> <ul> <li>Elige la opci\u00f3n 1 y elige la opci\u00f3n de IES_ClaradelRey</li> </ul> <p></p> <p></p> <p>Nota</p> <p>Para todos los ejercicios en PsInt ten\u00e9is que indicar con comentarios vuestro nombre y el enunciado del ejercicio. Todos los comentarios van precedidos por \"//\" y no forman parte del algoritmo. Nos permiten explicar bloques del algoritmo</p> <p></p>"},{"location":"ud2/00algoritmos/#historia-de-hello-world","title":"Historia de \"Hello world\"","text":"<p>Es un cl\u00e1sico cuando empezamos a aprender un lenguaje de programaci\u00f3n el crear como primer programa la muestra de la frase \"Hello world\" u \"Hola mundo\". Pod\u00e9is ver la historia en</p> <p>https://es.wikipedia.org/wiki/Hola_mundo</p>"},{"location":"ud2/00algoritmos/#ejercicio1","title":"Ejercicio1","text":"<p>Crea un algoritmo en PSeInt que muestre \"Hola Mundo\". Captura de pantalla del algoritmo</p>"},{"location":"ud2/00algoritmos/#diagrama-de-flujo-en-psint","title":"Diagrama de flujo en PSInt","text":"<p>Esta herramienta nos permite generar el diagrama de flujo una vez hemos creado el algoritmo</p> <p></p> <p></p>"},{"location":"ud2/00algoritmos/#estructuras-principales-de-un-algoritmo","title":"Estructuras principales de un algoritmo","text":""},{"location":"ud2/00algoritmos/#variables","title":"Variables","text":"<p>En el proceso de datos necesitamos guardarlos en alg\u00fan lugar para procesarlos. Un ordenador tiene la memoria RAM para almacenar la informaci\u00f3n que procesa. Los lenguajes de programaci\u00f3n nos permiten definir una variable con un nombre y con un tipo para que el ordenador nos reserve espacio para trabajar con esa informaci\u00f3n</p> <p></p> <p>Dependiendo del tipo necesario: Texto, n\u00famero entero, n\u00famero real, lista de nombres de alumno, imagen..., el ordenador reserva es espacio necesario para guardar el dato y procesarlo</p> <p></p> <p>En un algoritmo, conviene definir los datos que necesitamos como haremos posteriormente en un lenguaje de programaci\u00f3n</p> <p>En PSeInt tenemos unos tipos b\u00e1sicos</p> <p></p> <p>Y definiremos lo tipos de datos al inicio del algoritmo</p> <p></p>"},{"location":"ud2/00algoritmos/#ejercicio2","title":"Ejercicio2","text":"<ul> <li>Crea un algoritmo que pida al usuario su nombre y escriba \"Hola \" +     nombre. Comenta el c\u00f3digo</li> </ul> <ul> <li>Modifica el anterior para que pida su nombre y su edad y escriba</li> </ul> <p>\"Hola \"+ nombre+ \" tu edad es de \" + edad</p> <p></p> <p>Podemos escribir varias sentencias en una sola l\u00ednea separando con comas</p> <p>Escribir \\\"Hola \\\",nombre, \\\" tu edad es de \\\",edad;</p>"},{"location":"ud2/00algoritmos/#error-de-software-bug","title":"Error de software (bug)","text":""},{"location":"ud2/00algoritmos/#introduccion-a-los-errores-en-programacion","title":"Introducci\u00f3n a los errores en Programaci\u00f3n","text":"<p>Un error de software, error o simplemente fallo (tambi\u00e9n conocido por el ingl\u00e9s, bug) es un problema en un programa de computadora o sistema de software que desencadena un resultado indeseado.</p>"},{"location":"ud2/00algoritmos/#tipo-de-errores","title":"Tipo de errores:","text":""},{"location":"ud2/00algoritmos/#error-de-sintaxis-o-en-tiempo-de-depuracion","title":"Error de sintaxis o en tiempo de depuraci\u00f3n","text":"<p>Cuando no seguimos las reglas del lenguaje de programaci\u00f3n el depurado o interprete no puede leer el programa. En nuestra peque\u00f1a herramienta PSeInt hemos exigido el \";\" o definir el tipo de dato, por lo que nos indicar\u00e1 que hay un error</p> <p>{width=\"3.500488845144357in\" height=\"0.729268372703412in\"}</p>"},{"location":"ud2/00algoritmos/#error-en-tiempo-de-ejecucion","title":"Error en tiempo de ejecuci\u00f3n","text":"<p>Se produce cuando el\u00a0ordenador\u00a0no puede ejecutar alguna instrucci\u00f3n de forma correcta y no puede seguir ejecutando el programa. Por ejemplo, hemos definido la variable \"edad\" como entero y el algoritmo no comprueba la entrada de datos, si el usuario introduce un dato diferente a un entero</p> <p>{width=\"3.3260947069116362in\" height=\"0.8255708661417323in\"}</p>"},{"location":"ud2/00algoritmos/#errores-de-logica","title":"Errores de l\u00f3gica","text":"<p>El programa no resuelve el problema que se le pide. Por ejemplo, queremos que reste dos n\u00fameros y devuelve la suma</p> <p>{width=\"2.5641021434820646in\" height=\"1.2163965441819773in\"}</p>"},{"location":"ud2/00algoritmos/#debugger-o-depurador","title":"Debugger o depurador","text":"<p>Necesitaremos utilizar las herramientas de IDE para localizar f\u00e1cilmente los errores. El debugger es nuestro mejor aliado como programadores. Nuestro peque\u00f1o IDE nos permite seguir paso a paso el algoritmo. Pru\u00e9belo con el ejercicio2</p> <p></p>"},{"location":"ud2/00algoritmos/#estructuras-secuenciales","title":"Estructuras secuenciales.","text":"<p>En este tipo de estructura las instrucciones se realizan o se ejecutan una despu\u00e9s de la otra y, por lo general, se espera que se proporcione uno o varios datos, los cuales son asignados a variables para que con ellos se produzcan los resultados que representen la soluci\u00f3n del problema. Los algoritmos que hemos visto hasta ahora son secuenciales, solo hay un camino</p> <p></p>"},{"location":"ud2/00algoritmos/#ejemplo","title":"Ejemplo","text":"<p>Se desea implementar un algoritmo para obtener la suma de dos n\u00fameros cualesquiera. Se debe partir de que para poder obtener la suma es necesario contar con dos n\u00fameros, pues el proceso que debemos realizar es precisamente la suma de estos, la cual se asigna a una variable que se muestra como resultado del proceso.</p> <p>Es recomendable indicar mediante una tabla las variables que se utilizan, se\u00f1alando lo que representan y sus caracter\u00edsticas, esta acci\u00f3n facilitar\u00e1 la lectura de la soluci\u00f3n de un problema dado, sin importar qu\u00e9 herramienta de programaci\u00f3n se est\u00e9 utilizando para la representaci\u00f3n de la soluci\u00f3n. Para el problema de la suma de dos n\u00fameros, la tabla siguiente muestra las variables utilizadas en la soluci\u00f3n.</p> <p></p> <p>Los pasos por seguir son los mostrados en el pseudoc\u00f3digo siguiente, que corresponde al algoritmo que permite determinar la suma de dos n\u00fameros cualesquiera.</p> <p>1. Inicio</p> <p>2. Leer A, B</p> <p>3. Hacer S = A + B</p> <p>4. Escribir S</p> <p>5. Fin</p> <p>La representaci\u00f3n del algoritmo mediante la utilizaci\u00f3n de un diagrama de flujo ser\u00eda como el que se muestra en el diagrama siguiente.</p> <p></p>"},{"location":"ud2/00algoritmos/#ejercicio-3","title":"Ejercicio 3","text":"<ul> <li>Escribe el algoritmo anterior en PSint. Comenta el c\u00f3digo</li> </ul>"},{"location":"ud2/00algoritmos/#ejemplo_1","title":"Ejemplo","text":"<p>Un estudiante realiza cuatro ex\u00e1menes durante el trimestre, los cuales tienen la misma ponderaci\u00f3n. Realiza el pseudoc\u00f3digo y el diagrama de flujo que representen el algoritmo necesario para obtener el promedio de las calificaciones obtenidas.</p> <p>Las variables que se van a utilizar en la soluci\u00f3n de este problema se muestran en la tabla siguiente.</p> <p></p> <p>1. Inicio</p> <p>2. Leer C1, C2, C3, C4</p> <p>3. Hacer S = C1 + C2 + C3 + C4</p> <p>4. Hacer P = S/4</p> <p>5. Escribir P</p> <p>6. Fin</p> <p></p>"},{"location":"ud2/00algoritmos/#ejercicio-4","title":"Ejercicio 4","text":"<ul> <li>Escribe el algoritmo anterior en PSint</li> </ul>"},{"location":"ud2/00algoritmos/#ejercicio-5","title":"Ejercicio 5","text":"<p>Escribe en PsInt los siguientes algoritmos. Comenta el c\u00f3digo</p> <ol> <li> <p>Crea en pseudoc\u00f3digo el algoritmo de c\u00e1lculo del \u00e1rea de un     rect\u00e1ngulo, tomando b y a como su base y altura, y teniendo en     cuenta que el \u00e1rea es A = b*a</p> </li> <li> <p>Crea un algoritmo que pida el radio R y calcule el \u00e1rea y el     per\u00edmetro de la circunferencia</p> </li> </ol> <p></p> <ol> <li>Crea un algoritmo donde se requiere determinar el sueldo semanal     (SS) de un trabajador con base en las horas (HT) que trabaja y el     pago por hora que recibe (PH).</li> </ol>"},{"location":"ud2/00algoritmos2/","title":"Estructuras de decisi\u00f3n en los algoritmos","text":"<p>Como se puede observar, los problemas que se han presentado hasta el momento no implican cuestionamientos como: \"qu\u00e9 pasa si no le gusta con az\u00facar\", o bien, \"qu\u00e9 pasa si le gusta m\u00e1s caliente\", en un algoritmo de preparaci\u00f3n de una taza de caf\u00e9, donde se puede seguir haciendo muchos cuestionamientos que conducen a tomar una decisi\u00f3n. </p> <p>Por consiguiente,los algoritmos, en determinados momentos, requieren ser selectivos en lo que respecta a las acciones que deben seguir</p> <p></p>"},{"location":"ud2/00algoritmos2/#tipo-booleano","title":"Tipo booleano","text":"<p>Los valores booleanos, sirven para que los programas sean capaces de tomar decisiones l\u00f3gicas. Estas decisiones se tomar\u00e1n con valores booleanos, <code>true</code> y <code>false</code>(verdades o falso)</p> <p>En los lenguajes de programaci\u00f3n tenemos el tipo de datos <code>boolean</code> que nos permite tomar diferentes caminos en el algoritmo. Es necesario dominar las expresiones con resultado booleano para saber el camino que toma el algoritmo.</p> <p>Un ejemplo </p> <p>Un videojuego en el que tenemos que mostrar el enemigo cuando muere de una forma o si est\u00e1 vivo de otra. Podemos tener una variable booleana asociada al enemigo llamada <code>estaMuerto</code> y en cada fotograma ir comparando la variable para saber la imagen a mostrar</p> <p></p> <p>En un principio, <code>estaMuerto</code> ser\u00e1 falso y si el enemigo es tocado por la espada del h\u00e9roe, cambiaremos <code>estaMuerto</code> por verdadero</p>"},{"location":"ud2/00algoritmos2/#operadores-relacionales","title":"Operadores relacionales","text":"<p>Los operadores relacionales son s\u00edmbolos que se usan para comparar dos valores. Si el resultado de la comparaci\u00f3n es correcto la expresi\u00f3n considerada es verdadera, en caso contrario es falsa.</p> <p></p> <p>La expresi\u00f3n &lt;&gt; que nos devuelve verdadero si son distintos, en muchos lenguajes se expresa con</p> <p></p>"},{"location":"ud2/00algoritmos2/#ejemplo","title":"Ejemplo","text":"<p>Indica si es verdadero o falso en funci\u00f3n del valor de X</p> <p></p> <p>Si no te queda claro el resultado, podemos probarlo en PSeInt</p> <p>Por ejemplo, para la primera expresi\u00f3n 5&gt;x</p> <p>Algoritmo pseudoc\u00f3digo</p> <p></p> <p></p>"},{"location":"ud2/00algoritmos2/#estructuras-selectivas","title":"Estructuras selectivas.","text":"<p>Las estructuras selectivas nos permiten tomar caminos diferentes en el algoritmo. La mayor\u00eda de los problemas se tiene presente una estructura selectiva, que implica seguir o no un determinado flujo de secuencia del problema.</p> <p></p> <p>En los algoritmos para la soluci\u00f3n de problemas donde se utilizan estructuras selectivas se emplean frases que est\u00e1n estructuradas de forma adecuada dentro del pseudoc\u00f3digo.</p> <p>En el caso del diagrama de flujo, tambi\u00e9n se estructura de una forma semejante.</p> <p></p> <p>Ejemplo:</p> <p>Se desea implementar un algoritmo para determinar cu\u00e1l de los dos valores proporcionados es el mayor. Repres\u00e9ntalo con pseudoc\u00f3digo y diagrama de flujo.</p> <p>Se puede establecer que las variables que se deben utilizar son las mostradas en esta tabla.</p> <p></p> <p>Pseudoc\u00f3digo  Inicio</p> <p>Leer A, B</p> <p>Si A &gt; B</p> <pre><code>Entonces Hacer M = A\n</code></pre> <p>Si no      Hacer M = B</p> <p>Fin de comparaci\u00f3n</p> <p>Escribir \"el mayor es\", M</p> <p>Fin <pre><code>**Diagrama de flujo**\n\n![](../img/ud2/algoritmo2/image12.png)\n\n### Ejercicio\n\nCrea el algoritmo anterior en PSeInt y comprueba que funciona\n\n**Ejemplo:**\n\nRealiza un algoritmo para determinar si un n\u00famero es positivo o\nnegativo. Repres\u00e9ntalo en pseudoc\u00f3digo y diagrama de flujo.\n\nPara este caso, la tabla siguiente muestra las variables que se\nrequieren en la soluci\u00f3n del problema.\n\n![](../img/ud2/algoritmo2/image13.png)\n\n```bash\nInicio.\n\nLeer N\u00daM\n\nSi N\u00daM \\&gt; = 0\n\n    Entonces Hacer R = \"POSITIVO\"\n\nSi no Hacer R = \"NEGATIVO\"\n\nFin de comparaci\u00f3n\n\nEscribir \"el n\u00famero es\", R\n\nFin\n</code></pre></p> <p></p>"},{"location":"ud2/00algoritmos2/#ejercicio-1","title":"Ejercicio 1","text":"<p>Crea el algoritmo anterior en PSeInt y comprueba que funciona</p>"},{"location":"ud2/00algoritmos2/#ejercicio-2","title":"Ejercicio 2","text":"<p>Si, inicialmente,</p> <p><code>i = 0</code></p> <p>. \u00bfCu\u00e1l es el valor de i despu\u00e9s de ejecutar estos fragmentos de c\u00f3digo individualmente?</p> <p></p>"},{"location":"ud2/00algoritmos2/#ejercicio-3","title":"Ejercicio 3","text":"<p>Si queremos que i valga 2 despu\u00e9s de ejecutar la siguiente sentencia. Rellena los huecos</p> <p></p>"},{"location":"ud2/00algoritmos2/#ejercicio-4","title":"Ejercicio 4","text":"<p>Crea un algoritmo que pida al usuario:</p> <ul> <li>a\u00f1o de nacimiento</li> </ul> <p>Sabiendo que estamos a 2023, le diga al usuario si es menor de edad o no. No tenemos en cuenta el mes ni el d\u00eda</p>"},{"location":"ud2/00algoritmos2/#ejercicio-5","title":"Ejercicio 5","text":"<p>Crea un algoritmo que pida al usuario:</p> <ul> <li> <p>nombre</p> </li> <li> <p>apellido</p> </li> <li> <p>a\u00f1o de nacimiento</p> </li> </ul> <p>Sabiendo que estamos a 2023, le diga al usuario:</p> <ul> <li> <p>es menor de edad: nombre + apellido + \"no podemos registrarte. Eres     menor de edad\"</p> </li> <li> <p>es mayor de edad: nombre+ apellido+ \"est\u00e1s registrado\"</p> </li> </ul> <p>Guarda los datos en variables</p>"},{"location":"ud2/00algoritmos2/#ejercicio-6","title":"Ejercicio 6","text":"<p>Crea un algoritmo para determinar cu\u00e1nto se debe pagar (PAG) por una</p> <p>cantidad de l\u00e1pices (X) considerando que si son 1000 o m\u00e1s el costo es de 0.85 euros</p> <p>de lo contrario, el precio es de 0.90 euros.</p>"},{"location":"ud2/00algoritmos2/#ejercicio-7","title":"Ejercicio 7","text":"<p>Un hipermercado quiere un programa que calcule el impuesto sobre un aparato electr\u00f3nico.</p> <p>Un art\u00edculo que cuesta 300\u20ac o m\u00e1s tiene un impuesto del 5% (0.05); y un art\u00edculo que cuesta</p> <p>menos de 300\u20ac est\u00e1 libre de impuestos. Desarrolla un programa que solicite por teclado un</p> <p>precio, luego calcule e imprima el impuesto y luego imprima el coste total (precio + impuesto).</p>"},{"location":"ud2/00algoritmos2/#ejercicio-8","title":"Ejercicio 8","text":"<p>Escribe un programa que genere un n\u00famero aleatorio entre 1 y 10. Luego, pide al usuario que adivine el n\u00famero. Si el n\u00famero que ingresa el usuario es igual al n\u00famero generado, muestra un mensaje de felicitaci\u00f3n. Si no lo es, muestra un mensaje que indique si el n\u00famero es demasiado alto o demasiado bajo. Busca en PSeInt la funci\u00f3n que te permite obtener n\u00fameros aleatorios.</p>"},{"location":"ud2/00algoritmos2/#ejercicio-9","title":"Ejercicio 9","text":"<p>Escribe un algoritmo que pida al usuario un n\u00famero entero y le diga si es par o impar. Recuerda que un n\u00famero es par si se divide por 2 y el resto es 0.</p> <p>En los lenguajes de programaci\u00f3n, tenemos una funci\u00f3n que nos devuelve el resto de la divisi\u00f3n. Se suele llamar m\u00f3dulo y muchos lenguajes de programaci\u00f3n lo representan con %</p> <p>Ejemplo</p> <p>17%5 -&gt;2</p>"},{"location":"ud2/00algoritmos2/#seleccion-anidada","title":"Selecci\u00f3n anidada","text":"<p>Hasta ahora, los problemas vistos solo presentan una decisi\u00f3n para realizar un determinado proceso; sin embargo, en algunas ocasiones es necesario elaborar estructuras selectivas en cascada o anidadas, esto significa que despu\u00e9s de haber realizado una comparaci\u00f3n selectiva es necesario realizar otra comparaci\u00f3n selectiva como resultado de la primera condici\u00f3n. En la figura siguiente se presentan las formas correcta e incorrecta de estructurar el pseudoc\u00f3digo para este caso:</p> <p></p> <p>Su diagrama de flujo ser\u00eda:</p> <p></p> <p>Ejemplo</p> <p>Se requiere determinar cu\u00e1l de las tres cantidades proporcionadas es la mayor. Realiza su respectivo algoritmo y repres\u00e9ntalo mediante un diagrama de flujo y pseudoc\u00f3digo.</p> <p>Las variables que intervienen en la soluci\u00f3n de este problema se muestran a continuaci\u00f3n.</p> <p></p> <p>Su diagrama de flujo es:</p> <p></p> <p>El pseudoc\u00f3digo correspondiente ser\u00eda el siguiente: <pre><code>Inicio\n\nLeer A, B, C\n\nSi A &gt; B\n    Entonces\n        Si A &gt; C\n             Entonces M = A\n        Si no\n             M = C\n        Fin compara\nSi no\n    Si B &gt; C\n        Entonces M = B\n    Si no\n         M = C\n    Fin compara\nFin compara\n\nEscribir \"El mayor es\", M\n\nFin\n</code></pre></p>"},{"location":"ud2/00algoritmos2/#ejercicio-10","title":"Ejercicio 10","text":"<p>Crea el algoritmo anterior en PSeInt y comprueba que funciona. Realiza el paso a paso del programa introduciendo varios valores viendo los diferentes caminos que toma.</p>"},{"location":"ud2/00algoritmos2/#ejercicio-11","title":"Ejercicio 11","text":"<p>Escribe un algoritmo para clasificar el n\u00famero pedido en una de las siguientes categor\u00edas: positivo, negativo o cero. Imprime un mensaje que indique la clasificaci\u00f3n. Ejemplo:</p> <p>3</p> <p>Positivo</p> <p>0</p> <p>Cero</p> <p>-6</p> <p>negativo</p>"},{"location":"ud2/00algoritmos2/#ejercicio-12","title":"Ejercicio 12","text":"<p>Solicita al usuario un n\u00famero del 1 al 7, que represente un d\u00eda de la semana. Luego, usa una sentencia \\\"if\\\" anidada para imprimir el nombre del d\u00eda correspondiente (por ejemplo, \\\"1\\\" imprimir\u00eda \\\"Lunes\\\").</p>"},{"location":"ud2/00algoritmos2/#ejercicio-13","title":"Ejercicio 13","text":"<p>Escribe un algoritmo que permita al usuario convertir entre diferentes unidades de medida. Pedir\u00e1 un n\u00famero y posteriormente mostrar\u00e1</p> <p>1-cent\u00edmetros a pulgadas</p> <p>2-litros a galones</p> <p>3-metros a pies</p> <p>Dependiendo de si es 1 \u00f3 2 \u00f3 3, realizar\u00e1 la conversi\u00f3n correspondiente</p>"},{"location":"ud2/00algoritmos2/#ejercicio-14","title":"Ejercicio 14","text":"<p>Un hipermercado quiere un programa que calcule el impuesto sobre un aparato electr\u00f3nico. Un art\u00edculo que cuesta 300\u20ac o m\u00e1s tiene un impuesto del 5% (0.05); y un art\u00edculo que cuesta menos de 300\u20ac est\u00e1 libre de impuestos. Desarrolla un programa que solicite por teclado un precio, luego calcule e imprima el impuesto y luego imprima el coste total (precio + impuesto).</p>"},{"location":"ud2/11booleanexpressions/","title":"Expresiones booleanas","text":"<p>Las sentencias if del cap\u00edtulo anterior inclu\u00edan preguntas simples de verdadero / falso (expresiones booleanas) como num&lt;10 o jugadores==1. A menudo, las expresiones booleanas simples no son suficientes. Este cap\u00edtulo trata sobre expresiones booleanas m\u00e1s complicadas.</p>"},{"location":"ud2/11booleanexpressions/#_1","title":"&amp;&amp;","text":"<p>El operador AND &amp;&amp; es un operador l\u00f3gico. Un operador l\u00f3gico examina dos valores verdadero / falso y genera un \u00fanico valor verdadero / falso.</p> <p>Por ejemplo cuando necesitas verificar m\u00e1s de una expresi\u00f3n.</p> <pre><code>    if (harina == 100 &amp;&amp; azucar &gt;= 65) {\n\n    }\n</code></pre> <p>Cada parte es una expresi\u00f3n relacional. Una expresi\u00f3n relacional es un tipo de expresi\u00f3n booleana que usa un operador relacional para calcular un valor verdadero o falso.</p> <p>Las expresiones se eval\u00faan de izquierda a derecha, as\u00ed, tan pronto se detecta el primer false, la expresi\u00f3n entera se convierte en false y no se eval\u00faa el resto de expresiones.</p>"},{"location":"ud2/11booleanexpressions/#_2","title":"||","text":"<p>El operador OR || se usa en una expresi\u00f3n booleana para verificar que haya al menos una verdadera. Si solo un lado es verdadero, toda la expresi\u00f3n es verdadera. Si ambos lados son falsos, toda la expresi\u00f3n es falsa.</p> <pre><code>    if (ahorrosMensuales &gt; 1000 || pr\u00e9stamo == 3000) {\n\n    }\n</code></pre>"},{"location":"ud2/11booleanexpressions/#_3","title":"!","text":"<p>El operador NOT ! cambia de verdadero a falso y de falso a verdadero. Esto puede parecer una tonter\u00eda, pero a menudo es \u00fatil. A veces es m\u00e1s natural expresar una condici\u00f3n de una manera particular, pero la l\u00f3gica del programa requiere lo contrario de lo que ha escrito.</p> <pre><code>    if (!(precio &lt; 35)) {\n\n    }\n</code></pre>"},{"location":"ud2/1seleccion/","title":"Sentencia IF","text":"<p>Este apartado analiza c\u00f3mo los programas del ordenador toman decisiones utilizando la sentencia if. Esta sentencia es uno de los bloques de construcci\u00f3n fundamentales de la programaci\u00f3n.</p> <p>Veamos c\u00f3mo funciona.</p> <p>Los limpiaparabrisas se controlan con un interruptor de encendido y apagado. El diagrama de flujo de la derecha muestra c\u00f3mo se toma esta decisi\u00f3n.</p> <p>Comience en la parte superior del gr\u00e1fico y luego siga la l\u00ednea hasta la pregunta:</p> <p>\u00bfesta lloviendo? La respuesta es verdadera o falsa.</p> <p></p> <p>Si la respuesta es verdadera,</p> <ul> <li>siga la l\u00ednea etiquetada como Verdadero,</li> <li>siga las instrucciones en el cuadro \"Activo limpiaparabrisas ,</li> <li>siga la l\u00ednea para \"Continuar\".</li> </ul> <p>Si la respuesta es falsa,</p> <ul> <li>siga la l\u00ednea etiquetada como Falso,</li> <li>siga las instrucciones en el cuadro \"limpiaparabrisas desactivados\",</li> <li>siga la l\u00ednea para \"Continuar\".</li> </ul> <pre><code>    public static void main(String[] args) {\n        Scanner scan = new Scanner( System.in );\n        String respuesta;\n        System.out.print(\"\u00bfEst\u00e1 lloviendo? (Y or N): \");\n        respuesta = scan.nextLine();\n\n        if (respuesta.equals(\"Y\")) {\n            System.out.println(\"Activa limpiaparabrisas\");\n        } else {\n            System.out.println(\"Desactiva limpiaparabrisas\");\n        }\n    }\n</code></pre>"},{"location":"ud2/1seleccion/#sentencia-simple-condicional-if","title":"Sentencia simple condicional if","text":"<p>La declaraci\u00f3n if es la m\u00e1s b\u00e1sica de todas las declaraciones de flujo de control. Le dice a su programa que ejecute una determinada secci\u00f3n de c\u00f3digo solo si una prueba en particular se eval\u00faa como verdadera. La sentencia simple condicional if tiene la siguiente estructura:</p> <pre><code>    if (*condici\u00f3n*) {\n        //sentencias\n    }\n</code></pre> <p></p> <p>Condici\u00f3n es una expresi\u00f3n booleana. Recuerde que una expresi\u00f3n es una combinaci\u00f3n de literales, operadores, nombres de variables y par\u00e9ntesis que se utilizan para calcular un valor, o incluso una llamada a un m\u00e9todo.</p> <p>Una expresi\u00f3n booleana es una expresi\u00f3n que se eval\u00faa como verdadera o falsa.</p> <p>Dada esta descripci\u00f3n de la sintaxis de la sentencia if, los siguientes son ejemplos de sentencias if v\u00e1lidas:</p> <pre><code>    if (true) {\n        System.out.println(\"expresi\u00f3n if\");\n    }\n\n    int num = 6;\n    if (num &gt; 0) {\n        System.out.println(\"El n\u00famero es positivo.\");\n    }\n</code></pre>"},{"location":"ud2/1seleccion/#sentencia-condicional-compuesta-if-else","title":"Sentencia condicional compuesta if-else","text":"<p>Una segunda versi\u00f3n de la sentencia if incorpora una cl\u00e1usula else en la estructura. Esto nos permite ejecutar cualquiera de dos declaraciones separadas (simple o compuesta) como resultado de un booleano expresi\u00f3n.</p> <pre><code>    if (*condici\u00f3n*) {\n        //sentencias 1\n    } else {\n        //sentencias 2\n    }\n</code></pre> <p></p> <p>Ejemplo:</p> <pre><code>    int numJugadores = 2;\n\n    if (numJugadores == 1) {\n        System.out.println(\"Single player\");\n    } else {\n        System.out.println(\"Multiplayer\");\n    }\n</code></pre>"},{"location":"ud2/1seleccion/#sentencia-condicional-if-else-multiple","title":"Sentencia condicional if-else m\u00faltiple","text":"<p>Lo que se ejecuta dentro de los if or else, es decir las sentencias pueden ser a su vez sentencias if-else. En otras palabras, es posible incrustar una o m\u00e1s sentencias if-else dentro de otra sentencia if-else, creando as\u00ed una estructura de control anidada. Como ocurre con la mayor\u00eda de las cosas, hacer una estructura de control demasiado compleja no es una buena idea, pero existe una estructura de control est\u00e1ndar anidada ifelse que es muy \u00fatil. Se conoce como selecci\u00f3n de m\u00faltiples v\u00edas.</p> <pre><code>    if (*condici\u00f3n*) {\n        //sentencias 1\n    } else if (*condici\u00f3n*) {\n        //sentencias 2\n    } else if (*condici\u00f3n*) {\n        ...\n    } else {\n        //sentencias\n    }\n</code></pre> <p></p> <p>Ejemplo:</p> <pre><code>    if (numJugadores == 1) {\n        System.out.println(\"Single player\");\n    } else if (numJugadores == 2) {\n        System.out.println(\"Two player\");\n    } else if (numJugadores == 3) {\n        System.out.println(\"Multiplayer\");\n    } else {\n        System.out.println(\"Not possible, too many players\");\n    }\n</code></pre>"},{"location":"ud2/1seleccion/#operador-ternario","title":"Operador ternario (?:)","text":"<p>Ternario es una versi\u00f3n abreviada de la sentencia if-else. Tiene tres operandos y de ah\u00ed el nombre ternario. El formato general es:</p> <p></p> <p>La declaraci\u00f3n anterior significa que si la condici\u00f3n se eval\u00faa como verdadera, entonces ejecuta las instrucciones despu\u00e9s del \u2018?\u2018 de lo contrario, ejecuta las instrucciones despu\u00e9s de \u2018:\u2018.</p> <p><pre><code>  int nota = 7;\n  String notaFinal = (nota &gt;= 5) ? \"Aprobado\" : \"Suspendido\";\n  System.out.println(notaFinal); //muestra Aprobado\n</code></pre> Mediante if-else tenemos el siguiente c\u00f3digo m\u00e1s extenso</p> <pre><code>  int nota = 7;\n  String notaFinal;\n  if(nota &gt;= 5){\n    notaFinal=\"Aprobado\";\n  }\n  else{\n    notaFinal=\"Suspendido\";\n  }  \n  System.out.println(notaFinal); //muestra Aprobado\n</code></pre> <p>Tip</p> <p>Cuando las expresiones sean simples, es preferible utilizar el operador ternario en lugar de if-else, por econom\u00eda y legibilidad</p>"},{"location":"ud2/22dowhile/","title":"Sentencia DO-WHILE","text":"<p>El bucle do-while es una variante del bucle while que proporciona el lenguaje de programaci\u00f3n Java. Se puede expresar de la siguiente forma:</p> <pre><code>    //inicializadores\n    do {\n        //bloque de c\u00f3digo: sentencia(s)\n        //actualizador\n    } while (condici\u00f3n);\n</code></pre> <p></p> <p>La diferencia entre do-while y while es que do-while eval\u00faa la condici\u00f3n despu\u00e9s de ejecutar el cuerpo del bucle. Por lo tanto, las sentencias dentro del bloque do-while se ejecutan al menos una vez.</p> <p>Una estructura while correctamente dise\u00f1ada debe incluir 3 partes:</p> <ul> <li>un inicializador,</li> <li>una condici\u00f3n de bucle y</li> <li>un actualizador. El actualizador debe garantizar que la condici\u00f3n de entrada del bucle finalmente falle, permitiendo as\u00ed que el bucle termine.</li> </ul>"},{"location":"ud2/22dowhile/#ejemplo-muestra-los-numeros-del-0-al-4","title":"Ejemplo: Muestra los n\u00fameros del 0 al 4","text":"<pre><code>    int i = 0;\n\n    do {\n        System.out.println(i);\n        i++;\n    } while (i &lt; 5);\n</code></pre> <p>Salida</p> <pre><code>    0\n    1\n    2\n    3\n    4\n</code></pre> <p>Traza</p> Iteraci\u00f3n Variable i &lt; 5 Acci\u00f3n i = 0 no se verifica imprime 0, incrementa i=1 1a i = 1 true imprime 1, i = 2 2a i = 2 true imprime 2, i = 3 3a i = 3 true imprime 3, i = 4 4a i = 4 true imprime 4, i = 5 5a i = 5 false termina"},{"location":"ud2/22dowhile/#ejemplo-sumar-los-numeros-del-0-al-10","title":"Ejemplo: Sumar los n\u00fameros del 0 al 10","text":"<pre><code>    int i = 0; //inicializador\n    int suma = 0;\n\n    do {\n        suma = suma + i;\n        i++;//actualizador\n    } while (i &lt;= 10);\n\n    System.out.println(suma);\n</code></pre> <p>Salida</p> <pre><code>    55\n</code></pre>"},{"location":"ud2/22dowhile/#salir-de-un-bucle-flag-o-bandera","title":"Salir de un bucle: Flag o bandera","text":"<p>La bandera para salir de un bucle es una t\u00e9cnica de programaci\u00f3n que consiste en utilizar una variable booleana (generalmente llamada \"bandera\" o \"flag\") que controla cu\u00e1ndo debe terminar la ejecuci\u00f3n de un bucle. Esta variable se eval\u00faa en cada iteraci\u00f3n del bucle y, cuando cambia de valor (por ejemplo, de true a false), el bucle se interrumpe.</p> <p>Esta t\u00e9cnica es \u00fatil cuando no conoces el n\u00famero exacto de iteraciones y el bucle debe detenerse cuando se cumpla una condici\u00f3n espec\u00edfica.</p> <p></p> <pre><code>Scanner scanner = new Scanner(System.in);\nint num;\nboolean esFin=false;\n\nwhile(!esFin){\n    System.out.println(\"Introduce un n\u00famero(0 para salir)\");\n    num=scanner.nextInt();\n    if(num==0) esFin = true;\n}\n</code></pre>"},{"location":"ud2/22dowhile/#salir-de-un-bucle-centinela","title":"Salir de un bucle: Centinela","text":"<p>Un centinela es un valor especial que marca el final de un bucle o el fin de una secuencia de datos. En lugar de usar una variable booleana, el bucle termina cuando se encuentra un valor espec\u00edfico.</p> <p>Ejemplo: </p> <p>Un bucle que sigue pidiendo al usuario n\u00fameros hasta que introduce un valor centinela, como 0, para indicar que desea terminar.</p> <p></p> <pre><code>int numero;\ndo {\n    System.out.print(\"Introduce un n\u00famero (0 para salir): \");\n    numero = scanner.nextInt();\n} while (numero != -0);\n</code></pre>"},{"location":"ud2/22dowhile/#control-de-la-entrada-del-usuario-mediante-while","title":"Control de la entrada del usuario mediante while","text":"<p>Las estructuras en bucle permiten controlar la entrada del usuario en nuestros programas. Tenemos varios casos de uso. Vamos a ver algunos.</p>"},{"location":"ud2/22dowhile/#ejecutar-el-programa-hasta-que-se-introduzca-un-valor-en-concretocentinela","title":"Ejecutar el programa hasta que se introduzca un valor en concreto(centinela)","text":"<p>Este caso: Vamos a suponer que el programa terminar\u00e1 cuando el n\u00famero sea negativo(puede ser cualquier condici\u00f3n)</p> <pre><code>   1. Mostrar mensaje al usuario: \"Introduzca un n\u00famero o ingrese un n\u00famero negativo para terminar.\"\n   2. Leer el dato ingresado por el usuario.\n   3. Mientras el dato no sea negativo:\n      1. Ejecutar las acciones correspondientes al dato ingresado.\n      2. Mostrar mensaje al usuario: \"Introduzca otro n\u00famero o ingrese un n\u00famero negativo para terminar.\"\n      3. Leer el siguiente dato ingresado por el usuario.\n   4. Fin del bucle while.\n   5. Fin del programa.\n</code></pre> <p>Por ejemplo, si queremos un programa en el que el usuario introduce n\u00fameros en los que le dir\u00e1 si es \"par\" o \"impar\" hasta que introduzca \"0\"</p> <p><pre><code>    Scanner scanner = new Scanner(System.in);\n    System.out.println(\"Introduzca un n\u00famero \u00f3 \\\"0\\\" para terminar:\");\n    int numero = scanner.nextInt();\n    //miestras no sea 0\n    while (numero != 0) {\n        // Realizar acciones con el n\u00famero ingresado\n        if(numero%2 == 0)\n            System.out.println(\"El n\u00famero  es par\");\n        else\n            System.out.println(\"El n\u00famero  es impar\");\n        // Pedir al usuario otro n\u00famero\n        System.out.println(\"Introduzca un n\u00famero \u00f3 \\\"0\\\" para terminar:\");\n        numero = scanner.nextInt();\n    }\n    System.out.println(\"Programa finalizado.\");\n}\n</code></pre> </p> <p>Observa como es necesario pedir el valor antes de entrar en el while</p>"},{"location":"ud2/22dowhile/#leer-opcion-de-menu-valida-del-usuario-o-dato-de-usuario-valido","title":"Leer opci\u00f3n de men\u00fa v\u00e1lida del usuario o dato de usuario v\u00e1lido","text":"<p>Si las opciones por parte del usuario tienen que ser limitadas. Podemos mediante un bucle pedir al usuario la opci\u00f3n hasta que sea una opci\u00f3n v\u00e1lida. </p> <pre><code>Scanner scanner = new Scanner(System.in);\nint opcion;\n\ndo {\n    System.out.println(\"Men\u00fa de opciones:\");\n    System.out.println(\"1. Opci\u00f3n 1\");\n    System.out.println(\"2. Opci\u00f3n 2\");\n    System.out.println(\"3. Opci\u00f3n 3\");\n    System.out.println(\"4. Opci\u00f3n 4\");\n    System.out.print(\"Seleccione una opci\u00f3n: \");\n\n    opcion = scanner.nextInt();\n\n} while (opcion&lt;1 || 4&lt;opcion);\n</code></pre> <p>Esto mismo te sirve para cualquier entrada de datos del usuario, pero hay que ajustar la condici\u00f3n</p> <pre><code>Scanner scanner = new Scanner(System.in);\nString respuesta;\ndo {\n    System.out.print(\"\u00bfDesea continuar? (s/n): \");\n    respuesta = scanner.nextLine();\n\n} while (!respuesta.equalsIgnoreCase(\"s\") &amp;&amp; !respuesta.equalsIgnoreCase(\"n\"));\nSystem.out.println(\"Fin\");\n</code></pre> <p>El m\u00e9todo equalsIgnoreCase compara dos string ignorando may\u00fasculas y min\u00fasculas</p> <p>En programa m\u00e1s complejo, podemos incluir el men\u00fa de la siguiente forma. En este ejemplo, mostramos un men\u00fa con las opciones de una calculadora simple. Mientras no introduzca un opci\u00f3n v\u00e1lida, mostramos el men\u00fa</p> <pre><code>Scanner scanner = new Scanner(System.in);\nint opcion;\nint num1 = 0;\nint num2 = 0;\nint resultado;\n\ndo {\n    //mientras no sea v\u00e1lida la entrada\n    do {\n        //mostramos el men\u00fa\n        System.out.println(\"Men\u00fa:\");\n        System.out.println(\"1. Sumar\");\n        System.out.println(\"2. Restar\");\n        System.out.println(\"3. Multiplicar\");\n        System.out.println(\"4. Dividir\");\n        System.out.println(\"5. Salir\");\n        System.out.print(\"Ingrese su opci\u00f3n: \");\n        //leemos la opci\u00f3n\n        opcion = scanner.nextInt();\n    } while (opcion&lt;1 || opcion&gt;5);\n\n    //leemos los n\u00famero si quiere seguir\n    if (opcion != 5) {\n        System.out.print(\"Ingrese el primer n\u00famero: \");\n        num1 = scanner.nextInt();\n        System.out.print(\"Ingrese el segundo n\u00famero: \");\n        num2 = scanner.nextInt();\n\n        //realizamos la acci\u00f3n\n        switch (opcion) {\n            case 1:\n                resultado = num1 + num2;\n                System.out.println(\"La suma es: \" + resultado);\n                break;\n            case 2:\n                resultado = num1 - num2;\n                System.out.println(\"La resta es: \" + resultado);\n                break;\n            case 3:\n                resultado = num1 * num2;\n                System.out.println(\"La multiplicaci\u00f3n es: \" + resultado);\n                break;\n            case 4:\n                resultado = num1 / num2;\n                System.out.println(\"La divisi\u00f3n es: \" + resultado);\n                break;\n        }\n    }\n    //salimos cuando la opci\u00f3n sea 5\n} while (opcion != 5);\nSystem.out.println(\"\u00a1Hasta luego!\");\n</code></pre>"},{"location":"ud2/22dowhile/#comprobar-en-scanner-que-la-entrada-es-valida","title":"Comprobar en  Scanner que la entrada es v\u00e1lida","text":"<p>Scanner nos permite comprobar si la entrada es v\u00e1lida cuando el usuario introduce el valor. De esta forma evitaremos errores en tiempo de ejecuci\u00f3n por lectura inv\u00e1lida</p> <p>Ejemplo, si queremos leer un entero, mediante un while repetimos la petici\u00f3n de datos hasta que sea v\u00e1lida la entrada</p> <pre><code>Scanner scanner = new Scanner(System.in);\n\nSystem.out.print(\"Ingrese un n\u00famero entero: \");\n//comprobamos si es un entero\nwhile (!scanner.hasNextInt()) {\n    System.out.println(\"Entrada   inv\u00e1lida. Por favor, ingrese un n\u00famero entero:\");\n    scanner.next(); // Consumimos la entrada inv\u00e1lida\n}\n\nint numero = scanner.nextInt();\nSystem.out.println(\"Has introducido el n\u00famero: \" + numero);\n</code></pre>"},{"location":"ud2/22for/","title":"Sentencia FOR","text":"<p>Un bucle de conteo, o bucle controlado por un contador, es un bucle en el que sabes de antemano cu\u00e1ntas veces se repetir\u00e1. Como por ejemplo el siguiente c\u00f3digo que cuenta hasta 100:</p> <pre><code>    int i = 0;\n\n    while (i &lt; 100) {\n        System.out.println(i):\n        i++;\n    }\n</code></pre> <p>Aunque podemos usar una estructura while como la anterior para codificar un bucle de conteo, Java posee una estructura para \u00e9ste prop\u00f3sito, el bucle for. El bucle for se utiliza cuando el n\u00famero de iteraciones es conocido. Mientras que while y do-while se utiliza generalmente cuando el n\u00famero de iteraciones no se conoce.</p> <pre><code>    for(inicializador; condici\u00f3n; modificador) {\n        //cuerpo del bucle\n    }\n\n    //VARIANTES: Si solo tiene una sentencia en el cuerpo tambi\u00e9n \n    //se puede escribir sin llaves\n    for(inicializador; condici\u00f3n; modificador)\n        //sentencia;\n\n    for(inicializador; condici\u00f3n; modificador) //sentencia;\n</code></pre> <pre><code>    for(int i = 0; i &lt; 100; i++) {\n        System.out.println(i);\n    }\n</code></pre> <p>Proceso:</p> <ol> <li>Inicializador: inicializa y/o declara variables y se ejecuta solo una vez.</li> <li>Condici\u00f3n: se eval\u00faa la condici\u00f3n. Si la condici\u00f3n es verdadera, se ejecuta el cuerpo del bucle for.</li> <li>Modificador: actualiza el valor de inicializador.</li> <li>La condici\u00f3n se eval\u00faa nuevamente. El proceso contin\u00faa hasta que la condici\u00f3n es falsa.</li> </ol> <p></p>"},{"location":"ud2/22for/#ejemplo-imprime-cualquier-texto-por-pantalla-4-veces","title":"Ejemplo: Imprime cualquier texto por pantalla 4 veces","text":"<pre><code>    for (int i = 1; i &lt;= 4; ++i) {\n        System.out.println(\"This is a for loop.\");\n    }\n</code></pre> <p>Salida</p> <pre><code>    This is a for loop.\n    This is a for loop.\n    This is a for loop.\n    This is a for loop.\n</code></pre> <p>Traza</p> Iteraci\u00f3n Variable i &lt;= 4 Acci\u00f3n 1a i=1 true imprime texto, i=2 2a i=2 true imprime texto, i=3 3a i=3 true imprime texto, i=4 4a i=4 true imprime texto, i=5 5a i=5 false termina <p>La variable de inicializaci\u00f3n en el bucle for, puede ser declarada en otro lugar del c\u00f3digo. Ejemplo:</p> <pre><code>    int i;\n\n    //c\u00f3digo\n\n    for (i = 1; i &lt;= 4; ++i) {\n        System.out.println(\"This is a for loop.\");\n    }\n</code></pre> <p>Pero esto, viola la idea de que todas las partes del bucle se combinan en una sola declaraci\u00f3n. Por tanto, estar\u00eda bien si la declaraci\u00f3n de la variable i forma parte de la declaraci\u00f3n for.</p> <p>Una variable declarada en una instrucci\u00f3n for solo se puede usar en esa instrucci\u00f3n y en el cuerpo del bucle.</p>"},{"location":"ud2/22for/#bucle-infinito","title":"Bucle infinito","text":"<p>Un l\u00edmite de bucle es un valor que controla cu\u00e1ntas veces se repite un bucle. Un bucle se repetir\u00e1 hasta que se alcance su l\u00edmite de bucle. La condici\u00f3n del bucle debe ser una expresi\u00f3n booleana que pruebe si se ha alcanzado el l\u00edmite del bucle. De manera similar, el actualizador debe modificar el contador del bucle para que avance hacia su l\u00edmite.</p> <p>Si nunca se alcanza el l\u00edmite del bucle, la condici\u00f3n del bucle nunca se volver\u00e1 falsa y el bucle se repetir\u00e1 para siempre. Esto se conoce como bucle infinito.</p> <p>Para salir de un programa con bucle infinito presiona CTRL+C. <pre><code>    int i;\n    //i siempre es mayor que 0\n    for (i = 1; i &gt;= 0; ++i) {\n        System.out.println(\"bucle infinito.\");\n    }\n</code></pre></p>"},{"location":"ud2/22for/#bucle-variando-el-incremento-y-decremento","title":"Bucle variando el  incremento y decremento","text":"<p>Podemos variar el incremento utilizando una operaci\u00f3n diferente en la clausula incremento.</p> <p><pre><code>//muestra los n\u00famero con salto de 2\n    for (int i = 1; i &lt;= 10; i+=2) {\n        System.out.print(\" \"+i);\n    }\n</code></pre> 1 3 5 7 9</p> <p>Tambi\u00e9n podemos decrementar el for modificando las clausulas. <pre><code>//muestra los n\u00famero del 10 al 1\n    for (int i = 10; i &gt;= 1; i--) {\n        System.out.print(\" \"+i);\n    }\n</code></pre>  10 9 8 7 6 5 4 3 2 1</p>"},{"location":"ud2/22nestedloop/","title":"Bucles anidados","text":"<p>Un bucle anidado es una estructura en la que un bucle est\u00e1 contenido dentro del cuerpo de otro bucle.</p> <p>Por ejemplo, imagina que quieres imprimir algo como la siguiente tabla de n\u00fameros, donde en la fila y columnas superiores aparecen las posiciones y dentro de las filas tenemos fila x columna.</p> <p></p> <p>Para producir esta tabla de multiplicar, podr\u00edamos usar los siguientes bucles for anidados:</p> <pre><code>1    for (int fila = 1; fila &lt;= 4; fila++) { //para cada una de las 4 filas\n2        for (int col = 1; col &lt;= 9; col ++) //para cada una de las 9 columnas\n3            System.out.print(col * fila + \"\\t\"); //muestra la multiplicaci\u00f3n\n4        System.out.println(); //Empieza una nueva fila\n5    }\n</code></pre> <p>Indentamos el c\u00f3digo para hacer que sea m\u00e1s legible. En este ejemplo, el bucle externo controla el n\u00famero de filas en la tabla, es decir, nuestra elecci\u00f3n de fila como su contador de bucle.</p> <p>La instrucci\u00f3n println() (l\u00ednea 4) se ejecuta despu\u00e9s de que el bucle interno haya terminado de iterar, lo que nos permite imprimir una nueva fila en cada iteraci\u00f3n del bucle externo.</p> <p>El bucle interno imprime los nueve valores en cada fila imprimiendo la expresi\u00f3n col * fila. Obviamente, el valor de esta expresi\u00f3n depende de ambas variables de bucle.</p> <p>Analicemos un poco el ejemplo anterior:</p> <ol> <li>\u00bfCu\u00e1ntas veces se ejecuta la instrucci\u00f3n for en la l\u00ednea 2? El bucle interno se ejecuta una vez por cada iteraci\u00f3n del bucle externo. Por lo tanto, se ejecuta cuatro veces, que es el mismo n\u00famero de veces que se ejecuta la l\u00ednea 4.</li> <li>\u00bfCu\u00e1ntas veces se ejecuta la declaraci\u00f3n de la l\u00ednea 3? El cuerpo del bucle interno se ejecuta 36 veces, 9 veces por cada ejecuci\u00f3n de la l\u00ednea 2.</li> </ol>"},{"location":"ud2/22nestedloop/#patrones-de-for-anidado","title":"Patrones de FOR anidado","text":"<p>A veces es \u00fatil usar la variable del bucle externo como l\u00edmite para el bucle interno. Por ejemplo, veamos el siguiente patr\u00f3n:</p> <p></p> <p>El n\u00famero de s\u00edmbolos # en cada fila var\u00eda inversamente con el n\u00famero de fila. En la fila 1, tenemos cinco s\u00edmbolos; en la fila 2 tenemos cuatro; y as\u00ed sucesivamente hasta la fila 5, donde tenemos un #.</p> <p>Para producir este tipo de patr\u00f3n bidimensional, necesitamos dos contadores:</p> <ul> <li>uno para contar el n\u00famero de fila y</li> <li>otro para contar el n\u00famero de s\u00edmbolos # en cada fila.</li> </ul> <p>Debido a que tenemos que imprimir los s\u00edmbolos de cada fila antes de pasar a la siguiente fila, el ciclo externo contar\u00e1 los n\u00fameros de fila y el ciclo interno contar\u00e1 los s\u00edmbolos en cada fila.</p> <p>La siguiente tabla muestra la relaci\u00f3n que queremos:</p> Fila L\u00edmite (6-i) N\u00fam. s\u00edmbolos 1 6-1 5 2 6-2 4 3 6-3 3 4 6-4 2 5 6-5 1 <p>Si dejamos que j sea el contador del bucle interno, entonces j estar\u00e1 limitado por la expresi\u00f3n 6 - i. Esto conduce a la siguiente estructura de bucle anidado:</p> <pre><code>    for (int i = 1; i &lt;= 5 ; i++) {\n        for (int j = 1; j &lt;= (6 - i); j++) {\n            System.out.print('#');\n        }\n        System.out.println();\n    }\n</code></pre> <p>Otra soluci\u00f3n si no queremos usar un literal en la condici\u00f3n del bucle interno ser\u00eda:</p> <pre><code>    for (int i = 1; i &lt;= 5 ; i++) {\n        for (int j = 5; j &gt;= i; j--) {\n            System.out.print('#');\n        }\n        System.out.println();\n    }\n</code></pre> <p>A menudo los literales que aparecen como l\u00edmites en los bucles for se denominan n\u00fameros m\u00e1gicos y pueden crear problemas de redundancia en el c\u00f3digo o c\u00f3digo no legible. Para solucionar esto utilizamos constantes:</p> <pre><code>    final int MAX_WIDTH = 5;\n\n    for (int i = 1; i &lt;= MAX_WIDTH ; i++) {\n        for (int j = MAX_WIDTH; j &gt;= i; j--) {\n            System.out.print('#');\n        }\n        System.out.println();\n    }\n</code></pre>"},{"location":"ud2/22principlesloop/","title":"Principios del dise\u00f1o de bucles","text":""},{"location":"ud2/22principlesloop/#cuando-debo-utilizar-un-for-while-o-do-while","title":"Cu\u00e1ndo debo utilizar un for, while o do-While","text":"Instrucci\u00f3n Uso for Utilizar el bucle for cuando se conozca de antemano el n\u00famero exacto de veces que ha de repetirse el bloque de instrucciones. while Utilizar el bucle while cuando no sabemos el n\u00famero de veces que ha de repetirse el bloque y es posible que no deba ejecutarse ninguna vez. do-while Utilizar el bucle do-while cuando no sabemos el n\u00famero de veces que ha de  repetirse el bloque y deber\u00e1 ejecutarse al menos una vez. <ul> <li>Un bucle de conteo se utiliza siempre que se sepa de antemano exactamente cu\u00e1ntas iteraciones se necesitan. La instrucci\u00f3n for de Java es una estructura apropiada para codificar un bucle de conteo.</li> <li>Se debe usar una estructura while cuando el problema sugiera que el cuerpo del bucle puede omitirse por completo.</li> <li>Una estructura do-while debe usarse solo cuando un bucle requiere al menos una o m\u00e1s iteraciones.</li> <li>La variable de bucle se utiliza para especificar la condici\u00f3n de entrada de bucle. Debe inicializarse a un valor inicial apropiado y debe actualizarse en cada iteraci\u00f3n del bucle.</li> <li>El l\u00edmite de un bucle puede ser un recuento, un centinela o, de manera m\u00e1s general, un l\u00edmite condicional. Debe estar correctamente especificado en la expresi\u00f3n de entrada de bucle y el progreso hacia el l\u00edmite debe realizarse en el actualizador.</li> <li>Puede producirse un bucle infinito si el inicializador, la expresi\u00f3n de entrada de bucle o la expresi\u00f3n del actualizador no se especifican correctamente.</li> </ul>"},{"location":"ud2/22while/","title":"Sentencia WHILE","text":"<p>Una estructura de repetici\u00f3n es una estructura de control que repite una declaraci\u00f3n o secuencia de declaraciones de forma controlada. Las estructuras de repetici\u00f3n tambi\u00e9n se denominan estructuras de bucle. Muchos tipos de tareas de programaci\u00f3n requieren una estructura de repetici\u00f3n. Por ejemplo:</p> <ul> <li>Sumar los cuadrados de los n\u00fameros del 1 al 100.</li> <li>Un empleado de seguridad inform\u00e1tica quiere probar todas las contrase\u00f1as posibles para entrar en la cuenta de un presunto esp\u00eda.</li> <li>Quieres que los jugadores inserten movimientos durante un turno en un juego hasta que el juego ha terminado.</li> </ul> <p></p> <p>La instrucci\u00f3n while es una instrucci\u00f3n de bucle en la que la condici\u00f3n de bucle ocurre antes que el cuerpo del bucle. Tiene la siguiente estructura:</p> <pre><code>    while (condici\u00f3n) {\n        //cuerpo del bucle\n        //bloque de c\u00f3digo: sentencia(s)\n    }\n\n    //VARIANTES: Si solo tiene una sentencia en el cuerpo \n    //tambi\u00e9n se puede escribir as\u00ed\n    while (condici\u00f3n)\n        //sentencia;\n</code></pre> <p>Contiene la palabra reservada while seguida de un bloque de c\u00f3digo. Un bloque es un conjunto de sentencias encerradas entre corchetes { y }.</p> <p>Cuando se ejecuta la instrucci\u00f3n while, se eval\u00faa la condici\u00f3n del bucle, que es una expresi\u00f3n booleana y sucede alguno de los siguientes escenarios:</p> <ol> <li>Si esto se eval\u00faa como falso, la ejecuci\u00f3n contin\u00faa en la instrucci\u00f3n inmediatamente despu\u00e9s del cuerpo del bucle(fuera del bloque).</li> <li>Si la condici\u00f3n de bucle se eval\u00faa como verdadero, el cuerpo del bucle se ejecuta y luego la condici\u00f3n se eval\u00faa nuevamente y se repite el proceso.</li> </ol> <p>El cuerpo del bucle contin\u00faa ejecut\u00e1ndose hasta que la condici\u00f3n se eval\u00faa como falsa.</p> <p>Para que una declaraci\u00f3n while realice una tarea, la variable o variables en la condici\u00f3n de entrada de bucle deben inicializarse correctamente antes; y adem\u00e1s estas variables deben actualizarse correctamente al final del cuerpo de bucle. Podemos reformular las pautas anteriores como un principio de dise\u00f1o:</p> <p>Una estructura while correctamente dise\u00f1ada debe incluir 3 partes:</p> <ul> <li>un inicializador,</li> <li>una condici\u00f3n de bucle y</li> <li>un actualizador. El actualizador debe garantizar que la condici\u00f3n de entrada del bucle finalmente falle, permitiendo as\u00ed que el bucle termine.</li> </ul> <pre><code>    //inicializadores\n    while ( condici\u00f3n ) {\n        //sentencias\n        //actualizador\n    }\n</code></pre>"},{"location":"ud2/22while/#ejemplo-mostrar-los-3-primeros-numeros","title":"Ejemplo: Mostrar los 3 primeros n\u00fameros","text":"<pre><code>    int i = 1; //inicializador\n\n    while (i &lt;= 3) {\n        System.out.println(i);//Sentencia\n        i = i + 1;//actualizador\n    }\n</code></pre> <p>Salida</p> <pre><code>    1\n    2\n    3\n</code></pre> <p>Traza</p> Iteraci\u00f3n Variable i &lt;= 3 Acci\u00f3n 1a i = 1 true imprime 1, incrementa i=2 2a i = 2 true imprime 2, incrementa i = 3 3a i = 3 true imprime 3, incrementa i = 4 4a i = 4 false termina el bucle"},{"location":"ud2/22while/#ejemplo-sumar-los-numeros-del-0-al-10","title":"Ejemplo: Sumar los n\u00fameros del 0 al 10","text":"<pre><code>    int i = 0; //inicializador\n    int suma = 0;\n\n    while (i &lt;= 10) {\n        suma = suma + i;\n        i++;//actualizador\n    }\n\n    System.out.println(suma);\n</code></pre> <p>Salida</p> <pre><code>    55\n</code></pre> <p>Traza</p> Iteraci\u00f3n Variable i &lt;= 10 Acci\u00f3n 1a suma=0, i=0 true suma=0, incrementa i(1) 2a suma=0, i=1 true suma=1, incrementa i(2) 3a suma=1, i=2 true suma=3, incrementa i(3) 4a suma=3, i=3 true suma=6, incrementa i(4) 5a suma=6, i=4 true suma=10, incrementa i(5) .. .. .. .. 12a suma=55, i=11 false termina"},{"location":"ud2/22whileif/","title":"Bucles WHILE con sentencias IF","text":"<p>Este cap\u00edtulo muestra c\u00f3mo los bucles while y las instrucciones if se usan juntas para implementar la l\u00f3gica de un programa.</p> <p>El siguiente c\u00f3digo muestra un esqueleto de un programa que suma todos los n\u00fameros enteros hasta un l\u00edmite y suma tambi\u00e9n los que son n\u00fameros pares.</p> <p></p>"},{"location":"ud2/22whileif/#step-1","title":"STEP 1","text":"<p>Primero, inicializamos la variable count. El bucle debe contar desde uno hasta el l\u00edmite(incluido). En este programa, la mayor parte de la l\u00f3gica est\u00e1 contenida dentro del cuerpo del bucle.</p> <p></p> <p>Comprobamos que el programa se puede compilar y ejecutar. Si no fuera as\u00ed, corrige los errores de sintaxis (si los hay) y busca qu\u00e9 errores tienes. Inserta algunas sentencias println temporales para ayudarte en la b\u00fasqueda de errores. (O usa un depurador).</p> <p>Tip</p> <p>Es mejor escribir un programa por etapas. Escriba y depura cada etapa antes de construir sobre el. En un programa con un bucle principal, la primera etapa es construir el bucle.</p>"},{"location":"ud2/22whileif/#step-2","title":"STEP 2","text":"<p>El bucle de momento solo cuenta n\u00fameros hasta un l\u00edmite, pero todav\u00eda no hace nada con ellos. Esto es lo que queremos que suceda:</p> <ul> <li>Sumar cada entero y asignarlo a sumaTotal.</li> <li>Sumar cada entero par y asginarlo a sumaPar.</li> </ul> <p>\u00bfC\u00f3mo decidimos cuando agregar un n\u00famero entero a sumaPar? Para ello necesitaremos la sentencia if.</p> <p>El cuerpo del bucle en este programa contiene una instrucci\u00f3n if. Una instrucci\u00f3n if dentro de un cuerpo de bucle se denomina if anidado. No tiene nada de especial funciona igual que fuera del cuerpo del bucle.</p> <p></p> <p>\u00bfC\u00f3mo calculamos los n\u00fameros que son pares? Los n\u00fameros pares son aquellos que son divisibles por 2. Podemos hacerlo usando el operador %. Si el resto al dividir entre 2 da 0, entonces obtenemos un n\u00famero par.</p> <p></p>"},{"location":"ud2/23breakcontinue/","title":"Break y continue","text":"<p>Las sentencias break y continue son las sentencias de salto que se utilizan para omitir algunas sentencias dentro del bucle o terminar el bucle inmediatamente sin comprobar la condici\u00f3n. Estas instrucciones se pueden usar dentro de cualquier bucle, como for, while, do-while.</p>"},{"location":"ud2/23breakcontinue/#break","title":"BREAK","text":"<p>Ya se ha visto la instrucci\u00f3n break utilizada en un cap\u00edtulo anterior de este tutorial. En concreto en la estructura switch.</p> <p>La sentencia break en java se usa para terminar el bucle inmediatamente.</p> <p>Cuando se encuentra una sentencia break dentro de un bucle, la iteraci\u00f3n del bucle se detiene ah\u00ed y el control vuelve a la primera sentencia despu\u00e9s del bucle, es decir, la primera sentencia que se encuentra al salir del bucle.</p> <p>B\u00e1sicamente, las instrucciones break se utilizan en situaciones en las que no estamos seguros del n\u00famero real de iteraciones del bucle o queremos terminar el bucle en funci\u00f3n de alguna condici\u00f3n.</p> <pre><code>    for (int i = 0; i &lt; 10; i++) {\n        if (i == 3)\n            break;\n        System.out.print(i + \" \");\n    }\n\n    System.out.println(\"Fuera del bucle for\");\n</code></pre> <pre><code>Output: 0 1 2\nFuera del bucle for\n</code></pre> <p>Note</p> <p>En el caso de bucles anidados, la instrucci\u00f3n break termina el bucle m\u00e1s interno.</p>"},{"location":"ud2/23breakcontinue/#break-etiquetado","title":"Break etiquetado","text":"<p>Hasta ahora, hemos utilizado la sentencia break sin etiquetar. Sin embargo, hay otra forma de utilizar break en Java conocido como break etiquetado (labeled break).</p> <p></p> <p>En la imagen se ha utilizado un break etiquetado con el identificador label para especificar el bucle exterior. Observa c\u00f3mo se usa la declaraci\u00f3n break con etiqueta.</p> <p>La sentencia break est\u00e1 terminando la sentencia etiquetada (es decir, el bucle externo). Luego, el control del programa salta a la sentencia justo despu\u00e9s de la etiquetada.</p> <p>De esta forma, podr\u00edamos utilizar la sentencia break etiquetada para terminar el bucle m\u00e1s externo como se ve en el siguiente ejemplo:</p> <pre><code>    public static void main(String[] args) {\n\n        //el primer bucle es etiquetado como primero\n        primero:\n        for( int i = 1; i &lt; 5; i++) {\n\n            // el segundo bucle como segundo\n            segundo:\n            for(int j = 1; j &lt;= 2; j ++ ) {\n                System.out.println(\"i = \" + i + \"; j = \" +j);\n\n                // se realiza un break del primer bucle\n                if ( i == 2)\n                    break primero;\n            }\n        }\n    }\n</code></pre> <pre><code>Output\ni = 1; j = 1\ni = 1; j = 2\ni = 2; j = 1\n</code></pre>"},{"location":"ud2/23breakcontinue/#continue","title":"CONTINUE","text":"<p>La instrucci\u00f3n continue en Java se usa para omitir la iteraci\u00f3n actual de un bucle y continuar con la siguiente iteraci\u00f3n del bucle.</p> <p>Podemos usar la instrucci\u00f3n continue dentro de cualquier tipo de bucle, como el bucle for, while y do-while.</p> <p>B\u00e1sicamente, las sentencias continue se utilizan en situaciones en las que queremos continuar el ciclo pero no queremos la sentencia restante despu\u00e9s de la sentencia continue.</p> <pre><code>    for (int i = 0; i &lt; 5; i++) {\n        if (i == 2)\n            continue;\n\n        System.out.print(i + \" \");\n    }\n</code></pre> <pre><code>Output: 0 1 3 4\n</code></pre>"},{"location":"ud2/24exceptions/","title":"Excepciones","text":""},{"location":"ud2/24exceptions/#jerarquia-de-excepciones-en-java","title":"Jerarqu\u00eda de excepciones en Java","text":"<p>La clase Throwable es la clase base incorporada que se usa para manejar todas las excepciones en Java. El tipo m\u00e1s gen\u00e9rico de excepci\u00f3n, java.lang.Exception, se encuentra en el paquete java.lang, pero la mayor\u00eda de sus subclases est\u00e1n contenidas en otros paquetes. </p> <p>Un programa a menudo encuentra problemas mientras se ejecuta. Puede tener problemas para leer datos, puede haber caracteres ilegales en los datos o un \u00edndice puede salirse de los l\u00edmites. La clase Java que gestiona estos problemas se llama Exception.</p> <p>La entrada y la salida son especialmente propensas a errores. El manejo de excepciones es esencial para la programaci\u00f3n de I/O.</p> <p>Por ejemplo, \u00bfqu\u00e9 ha ido mal en el siguiente programa?:</p> <p></p> <p>Si hacemos un seguimiento a la pila de errores, vemos que el usuario insert\u00f3 \"hola\" y la clase Scanner, en concreto el m\u00e9todo nextInt no pudo convertir ese texto en un n\u00famero, por tanto, se lanz\u00f3 una excepci\u00f3n.</p> <p>Eso no significa que el programa est\u00e9 mal, simplemente el fallo est\u00e1 en los datos. Cuando nextInt encuentra el problema lanza la excepci\u00f3n InputMismatchException. La ejecuci\u00f3n del programa Java detecta la excepci\u00f3n y detiene el programa imprimiendo los mensajes de error.</p> <p>{==</p> <p>Es muy importante leer bien la pila de errores en la consola cuando se lanza una excepci\u00f3n para encontrar el fallo.</p> <p>==}</p> <p></p>"},{"location":"ud2/24exceptions/#que-es-un-error","title":"\u00bfQu\u00e9 es un error?","text":"<p>Un error indica que se ha producido un fallo no recuperable, del que no se puede recuperar la ejecuci\u00f3n normal del programa. Un error est\u00e1 representado por un objeto de clase Error.</p> <p>La clase Throwable tiene dos subclases: Exception y Error. Un m\u00e9todo Java puede \"lanzar\" un objeto de clase Throwable. Por ejemplo, Scanner lanz\u00f3 una excepci\u00f3n cuando intent\u00f3 convertir \"hola\" en un n\u00famero entero.</p> <p>Las excepciones son diferentes de los errores porque los programas se pueden escribir para recuperarse de las excepciones, pero los programas no se pueden escribir para recuperarse de los errores.</p>"},{"location":"ud2/24exceptions/#que-es-una-excepcion","title":"\u00bfQu\u00e9 es una excepci\u00f3n?","text":"<p>Una excepci\u00f3n es un problema que ocurre cuando se ejecuta un programa. Cuando ocurre una excepci\u00f3n, la m\u00e1quina virtual Java crea un objeto de clase Exception que contiene informaci\u00f3n sobre el problema. Cuando se lanza una excepci\u00f3n, se puede capturar la excepci\u00f3n para recuperarse del programa.</p>"},{"location":"ud2/24exceptions/#bloques-try-catch","title":"Bloques try -  catch","text":"<p>Para capturar una excepci\u00f3n realizamos los siguientes pasos:</p> <ol> <li>Colocar el c\u00f3digo que pueda lanzar una excepci\u00f3n dentro de un bloque try.</li> <li>Colocar el c\u00f3digo que maneja la excepci\u00f3n dentro de un bloque catch (captura).</li> <li>El bloque catch debe seguir inmediatamente al bloque try.</li> </ol> <p>Cada bloque catch es un manejador de excepciones que maneja el tipo de excepci\u00f3n indicado por su argumento. El tipo de argumento, ExceptionType, declara el tipo de excepci\u00f3n que el controlador puede manejar y debe ser el nombre de una clase que hereda de la clase Throwable.</p> <p>El siguiente ejemplo arroja dentro del bloque try una InputMismatchException, el bloque catch comienza a ejecutarse inmediatamente. Se omiten las sentencias restantes en el bloque try.</p> <pre><code>    Scanner sc = new Scanner(System.in);\n    int numero;\n\n    System.out.println(\"Introduzca un entero:\");\n\n    try {\n        numero = sc.nextInt();\n    } catch (InputMismatchException e) {\n        System.out.println(\"No has introducido un n\u00famero.\");\n        e.printStackTrace();\n    }\n\n    System.out.println(\"Sigue ejecut\u00e1ndose el programa\");\n</code></pre> <p>El par\u00e1metro dentro de catch e se refiere al objeto de excepci\u00f3n que se lanza. Si queremos mostrar la pila de errores que genera el error usamos el m\u00e9todo e.printStackTrace();</p> <p>Despu\u00e9s de ejecutar el bloque catch, la ejecuci\u00f3n contin\u00faa con la instrucci\u00f3n que sigue al bloque catch. La ejecuci\u00f3n no vuelve al bloque try.</p>"},{"location":"ud2/24exceptions/#como-se-ejecuta-un-try-catch-paso-por-paso","title":"C\u00f3mo se ejecuta un try-catch paso por paso","text":"<ol> <li>Cuando se lanza una excepci\u00f3n dentro de un bloque try, el controlador de excepciones examina la excepci\u00f3n dentro de los bloques catch.</li> <li>Los bloques catch se examinan uno a uno empezando por el primero.</li> <li>El primer bloque catch que encaja con la excepci\u00f3n obtiene el control. Aunque haya muchas excepciones que encajen solo se ejecuta un bloque catch.</li> <li>Si ning\u00fan bloque catch encaja con la excepci\u00f3n lanzada se muestra la pila de errores y se termina la ejecuci\u00f3n del programa ya que no se ha manejado la excepci\u00f3n.</li> <li>Las clases m\u00e1s especificas deben ir primero seguidas de las m\u00e1s generales.</li> <li>Despu\u00e9s de ejecutar la \u00faltima instrucci\u00f3n dentro del catch el control del programa vuelve a la siguiente l\u00ednea fuera del try-catch (o finally si hubiera).</li> </ol>"},{"location":"ud2/24exceptions/#capturar-mas-de-una-excepcion-en-un-solo-catch","title":"Capturar m\u00e1s de una excepci\u00f3n en un solo catch","text":"<p>En Java SE 7 y posteriores, un solo bloque catch puede manejar m\u00e1s de un tipo de excepci\u00f3n. Esta funci\u00f3n puede reducir la duplicaci\u00f3n de c\u00f3digo.</p> <p>En la cl\u00e1usula catch, se especifican los tipos de excepciones que puede manejar el bloque y se separa cada tipo de excepci\u00f3n con una barra vertical (|):</p> <pre><code>catch (IOException | SQLException ex) {\n     //realizar acciones\n}\n</code></pre> <p>Note</p> <p>Si un bloque catch maneja m\u00e1s de un tipo de excepci\u00f3n, el par\u00e1metro catch es impl\u00edcitamente final. En este ejemplo, la variable catch ex es final y, por lo tanto, no puede asignarle ning\u00fan valor dentro del bloque catch.</p>"},{"location":"ud2/24exceptions/#sentencia-throw","title":"Sentencia throw","text":"<p>Utilizando la palabra reservada throw podemos lanzar nosotros expl\u00edcitamente una excepci\u00f3n.</p> <p>Podemos construir una instancia de la excepci\u00f3n que queremos lanzar y a\u00f1adirle un mensaje en el constructor.</p> <p>Ejemplo:</p> <pre><code>    try {\n        System.out.print(\"Inserta el numerador: \");\n        num = scan.nextInt();\n        System.out.print(\"Inserta el denominador: \");\n        div = scan.nextInt();\n\n        if ( div == 0 ) throw new ArithmeticException(\"Error al intentar dividir entre cero\");\n\n        ....\n    } catch (ArithmeticException ex) { \n      System.out.println(\"No se puede dividir \" + num + \" entre \" + div);\n      System.out.println(ex.getMessage());\n    } \n</code></pre>"},{"location":"ud2/24exceptions/#bloque-finally","title":"Bloque finally","text":"<p>El bloque finally siempre se ejecuta cuando sale del bloque try-catch incluso si ocurre una excepci\u00f3n inesperada.</p> <p>Estructura:</p> <pre><code>try {\n    //c\u00f3digo\n} catch () {\n    //c\u00f3digo\n} finally {\n    //siempre se ejecuta\n}\n</code></pre> <p>Solo puede haber un bloque finally, y debe estar despu\u00e9s de los bloques catch.</p> <ul> <li>Si el bloque try sale normalmente (no ocurrieron excepciones), entonces el control va directamente al bloque finally.</li> <li>Si el bloque try sale debido a una excepci\u00f3n que es manejada por un bloque catch, primero ese bloque se ejecuta y luego el control va al bloque finally.</li> <li>Si el bloque try sale debido a una excepci\u00f3n que NO es manejada por un bloque catch, el control va directamente al bloque finally. Despu\u00e9s de que se ejecuta el bloque finally, se lanza la excepci\u00f3n a la persona que llama y el control vuelve a la persona que llama.</li> </ul> <p></p> <p>En resumen: si el control entra en un bloque try, siempre entrar\u00e1 en el bloque finally.</p> <p>Importante</p> <p>El bloque finally es una herramienta clave para prevenir fugas de recursos. Al cerrar un archivo o recuperar recursos, coloque el c\u00f3digo en un bloque final para asegurarse de que el recurso siempre se recupere.</p>"},{"location":"ud2/24exceptions/#sentencia-try-with-resources","title":"Sentencia try-with-resources","text":"<p>Pr\u00f3ximamente.</p> <p>Tip</p> <p>M\u00e1s informaci\u00f3n en oracle-exceptions java</p>"},{"location":"ud2/25fallos/","title":"Prueba y depuraci\u00f3n de aplicaciones","text":"<p>Todo IDE ofrece un conjunto de herramientas para hacer debug.</p> <p>El debug permite supervisar la ejecuci\u00f3n de los programas, para localizar y eliminar los errores de programaci\u00f3n.</p> <p>Es necesario que un programa compile para poder depurarlo.</p> <ul> <li>Permite suspender la ejecuci\u00f3n de un programa, examinar y establecer los valores de las variables, comprobar los valores devueltos por un determinado m\u00e9todo, el resultado de una comparaci\u00f3n l\u00f3gica o relacional, etc...</li> </ul>"},{"location":"ud2/25fallos/#debug-en-intellij","title":"Debug en IntelliJ","text":"<p>Run \u2192 Debug</p>"},{"location":"ud2/25fallos/#breakpoint-punto-de-ruptura","title":"Breakpoint / Punto de ruptura","text":"<ul> <li> <p>Permite detener un programa en una l\u00ednea/parte determinada.</p> <p>1) Click sobre el n\u00famero de l\u00ednea o CTRL + F8</p> </li> <li> <p>Una vez se detiene el programa podemos:</p> <p>1) Analizar el valor de cualquier variable/propiedad</p> <p>2) Analizar el valor de una expresi\u00f3n.</p> <p>3) Ejecutar l\u00ednea a l\u00ednea y comprobar el flujo de la aplicaci\u00f3n.</p> </li> <li> <p>Tras realizar la comprobaci\u00f3n, se puede:</p> <p>1) Detener el programa.</p> <p>2) O continuar su ejecuci\u00f3n hasta el final.</p> </li> </ul>"},{"location":"ud2/25fallos/#tipos-de-ejecucion","title":"Tipos de ejecuci\u00f3n","text":"<ul> <li>Primero hemos de lanzar el Debug (ALT + SHIFT + F9)</li> <li>Step Over (F8) / Paso a paso:</li> <li>Step Into (F7) / Paso a paso entrando en el m\u00e9todo/procedimiento</li> <li>Resume (F9) / Continuar</li> <li>Step Out (SHIFT + F8) / Ejecuci\u00f3n de un programa hasta el final</li> </ul>"},{"location":"ud2/25fallos/#examinador-de-variables","title":"Examinador de variables","text":"<ul> <li>En cualquier momento podemos inspeccionar el valor y tipo de una variable</li> <li>Si queremos evaluar esas variables m\u00e1s de una vez, es mejor crear un \u201cWatchpoint\u201d sobre ellas</li> <li>Bot\u00f3n derecho + Add to Watches o pesta\u00f1a variables</li> </ul>"},{"location":"ud2/25fallos/#proceso-de-depuracion","title":"Proceso de depuraci\u00f3n","text":"<p>1) Localizar el problema</p> <p>2) Poner un breakpoint en la l\u00ednea del error o en la entrada a la llamada</p> <pre><code>\u25cf Poner watchpoint sobre los datos m\u00e1s sensibles\n</code></pre> <p>3) Lanzar el Debug y utilizar Step Over o Step Into. En cada paso, evaluar el contenido de las variables o expresiones fijadas.</p> <p>4) Una vez localizado el error, detener el debug.</p>"},{"location":"ud2/25fallos/#cambiar-codigo-en-caliente","title":"Cambiar c\u00f3digo en caliente","text":"<ul> <li>Al detener un programa mediante un breakpoint, podemos modificar el valor de cualquier variable y ver c\u00f3mo act\u00faa nuestro c\u00f3digo.</li> <li>Pesta\u00f1a Variables \u2192 campo bot\u00f3n derecho \u2192 set value...</li> </ul>"},{"location":"ud2/26methods/","title":"Introducci\u00f3n a los m\u00e9todos en Java","text":"<p>Los m\u00e9todos sirven para hacer nuestro c\u00f3digo m\u00e1s legible, m\u00e1s f\u00e1cil de mantener y sin c\u00f3digo duplicado. Es habitual tener que utilizar en distintas partes la misma funcionalidad, lo que implica:</p> <ul> <li>Duplicidad del c\u00f3digo</li> <li>Dificultad en el mantenimiento si hay un cambio en la duplicidad del c\u00f3digo.</li> </ul> <p>Todo el tiempo hemos estado usando un m\u00e9todo llamado main, dentro de \u00e9l se encuentran todas las sentencias que hemos ido ejecutando, ahora vamos a crear nuestros propios m\u00e9todos teniendo en cuenta:</p> <p></p> <p></p> <p>Los m\u00e9todos se alinean unos debajo de otros, no se puede insertar un m\u00e9todo dentro de otro m\u00e9todo, y adem\u00e1s deben estar dentro de la clase.</p>"},{"location":"ud2/26methods/#parametros-de-entrada","title":"Par\u00e1metros de entrada","text":"<p>Una funci\u00f3n puede definirse para que reciba tantos datos como necesite. Por ejemplo, un funci\u00f3n que multiplique dos n\u00fameros, tendr\u00e1 dos par\u00e1metros</p> <p><pre><code>static int multiplicar(int x, int y){\n        return x*y;\n    }\n</code></pre> llamaremos a la funci\u00f3n</p> <pre><code>int res=multiplicar(45, 2)\n</code></pre>"},{"location":"ud2/26methods/#funcion-sin-parametros","title":"Funci\u00f3n sin par\u00e1metros","text":"<p>Una funci\u00f3n puede no necesitar par\u00e1metro. Por ejemplo, si queremos mostrar un men\u00fa</p> <pre><code>static int muestraMenu() {\n        Scanner sc = new Scanner(System.in);\n        int opc;\n        do {\n            System.out.println(\"1-Jugar\");\n            System.out.println(\"2-Cambiar opciones\");\n            System.out.println(\"3-Salir\");\n            opc = sc.nextInt();\n        } while (opc &lt; 1 || opc &gt; 3);\n        return opc;\n    }\n</code></pre> <p>podr\u00edamos llamar a la funci\u00f3n</p> <pre><code>int opc=muestraMenu();\nswitch (opc){\n    case 1: \n        jugar();\n        break;\n    case 2: \n        opciones();\n        break;\n    case 3: \n        salir();\n        break;\n        }\n</code></pre>"},{"location":"ud2/26methods/#valores-devueltos-por-la-funcion-sentencia-return","title":"Valores devueltos por la funci\u00f3n. Sentencia <code>Return</code>","text":"<p>Un valor devuelto es informaci\u00f3n que un m\u00e9todo devuelve al c\u00f3digo que lo llam\u00f3. Cada m\u00e9todo solo puede devolver un valor: cuando un m\u00e9todo regresa, deja de ejecutarse (y continuamos donde lo dejamos antes de llamar al m\u00e9todo). Para que el c\u00f3digo que llam\u00f3 al m\u00e9todo use el valor devuelto, el valor devuelto debe almacenarse en una variable o usarse inmediatamente.</p> <pre><code>public static type methodName(parameters) { // llamar a nombre de m\u00e9todo devuelve expresi\u00f3n\n     ...\n     return expression;\n}\ntype variableName = methodName(parameters);  // variableName almacena el valor de retorno\n</code></pre> <p>Ejemplo</p> <pre><code>public class Main {\n\n    public static void main(String[] args) {\n        boolean gameOver = true;\n        int puntuacion = 5000;\n        int nivelCompletado = 5;\n        int bonus = 10;\n\n        int score = calcularPuntuacion(gameOver, puntuacion, nivelCompletado, bonus);\n        System.out.println(score);\n\n        //otra forma de hacerlo es pasarle directamente el valor de las variables\n        score = calcularPuntuacion(true, 1000, 10, 30);\n        System.out.println(score);\n\n    }\n\n    public static int calcularPuntuacion(boolean gameOver, int puntuacion, int nivelCompletado, int bonus) {\n        if (gameOver) {\n            int puntuacionFinal = puntuacion + (nivelCompletado * bonus);\n            puntuacionFinal += 100;\n            return puntuacionFinal;\n        } else {\n            return -1;\n        }\n    }\n\n    //OTRAS FORMAS M\u00c1S EFICIENTES DE CREAR EL M\u00c9TODO calcularPuntuaciones\n    //1. M\u00e9todo m\u00e1s eficiente sin sentencia else\n    public static int calcularPuntuacion(boolean gameOver, int puntuacion, int nivelCompletado, int bonus) {\n        if (gameOver) {\n            int puntuacionFinal = puntuacion + (nivelCompletado * bonus);\n            puntuacionFinal += 100;\n            return puntuacionFinal;\n        }\n        return -1;\n    }\n\n    //2. Otra forma de realizar el m\u00e9todo calcularPuntuacion sin utilizar dos sentencias de return ser\u00eda\n    public static int calcularPuntuacion(boolean gameOver, int puntuacion, int nivelCompletado, int bonus) {\n        int puntuacionFinal = -1;\n        if (gameOver) {\n            int puntuacionFinal = puntuacion + (nivelCompletado * bonus);\n            puntuacionFinal += 100;\n        }\n        return puntuacionFinal;\n    }\n\n}\n</code></pre>"},{"location":"ud2/26methods/#funciones-que-no-devuelven-valor-void","title":"Funciones que no devuelven valor: void","text":"<p>Si una funci\u00f3n no devuelve ning\u00fan valor, tenemos que indicarlo mediante void. Por ejemplo, una funci\u00f3n que imprima la tabla de multiplicar de un n\u00famero</p> <pre><code>static void tablaMultiplicar(int n) {\n       for(int i=1;i&lt;=10;i++){\n           System.out.println(i+\"x\"+n+ \"= \"+i*n);\n       }\n    }\n</code></pre>"},{"location":"ud2/26methods/#paso-de-argumentos-por-valor-o-por-referencia","title":"Paso de argumentos por valor o por referencia","text":"<p>En programaci\u00f3n hay dos formas de paso de par\u00e1metros a un m\u00e9todo: por valor o por referencia.</p>"},{"location":"ud2/26methods/#paso-por-valor","title":"Paso por valor","text":"<p>El paso de par\u00e1metros por valor consiste en copiar el contenido de la variable que queremos pasar en otra dentro del \u00e1mbito local de la funci\u00f3n. Se tendr\u00e1n dos valores duplicados e independientes, con lo que la modificaci\u00f3n de uno no afecta al otro.</p> <p></p>"},{"location":"ud2/26methods/#paso-por-referencia","title":"Paso por referencia","text":"<p>Cuando se invoca al m\u00e9todo se crea una nueva variable (el par\u00e1metro formal) a la que se le asigna la direcci\u00f3n de memoria donde se encuentra el par\u00e1metro actual. En este caso el m\u00e9todo trabaja con la variable original por lo que puede modificar su valor.</p> <p></p> <p>Lenguajes como C, C++, C#, php, VisualBasic, etc. soportan ambas formas de paso de par\u00e1metros. </p>"},{"location":"ud2/26methods/#paso-de-parametros-en-java-por-valor","title":"Paso de par\u00e1metros en Java: Por valor","text":"<p>Java solo soporta el paso por valor. </p> <p>Cuando el argumento es de tipo primitivo (int, double, char, boolean, float, short, byte), el paso por valor significa que cuando se invoca al m\u00e9todo se reserva un nuevo espacio en memoria para el par\u00e1metro formal. El m\u00e9todo no puede modificar el par\u00e1metro actual. </p> <p>Como veremos m\u00e1s adelante, cuando se trata de objetos, se env\u00eda la copia a la direcci\u00f3n al objeto, por los que si se modifica el objeto en el m\u00e9todo, se modifica el objeto original.</p> <p>En el caso de los String, es un excepci\u00f3n. Los String son inmnutable, esto quiere decir, que si se modifica el objeto, se crea un nuevo String en vez de modificar el original.</p> <p><pre><code>static void saluda(String nombre){\n    //crea un nuevo objeto String\n        nombre=\"Hola \"+nombre;\n        System.out.println(nombre);\n    }\npublic static void main(String[] args) {\n        String nombre\"Pepe\";\n        //imprime Hola Pepe\n        saluda(nombre);\n        //imprime Pepe\n        System.out.println(nombre);\n    }\n</code></pre> Imprime <pre><code>Hola Pepe\nPepe\n</code></pre></p>"},{"location":"ud2/26methods/#nomenclatura-de-metodos-en-java","title":"Nomenclatura de m\u00e9todos en Java","text":"<p>En general se utilizar\u00e1n verbos para nombrar a los m\u00e9todos, describiendo la acci\u00f3n que realizan. </p> <p>La primera letra del nombre se escribir\u00e1 en min\u00fascula y el resto de primeras letras de cada palabra interna en may\u00fascula. Ejemplos de este tipo de nomenclatura pueden ser:</p> <p>mostrarTablaMultiplicar(5)</p> <p>mostrarNumerosPrimos(9)</p> <p>esPrimo(7)</p>"},{"location":"ud2/26methods/#documentacion-de-metodos-con-javadoc","title":"Documentaci\u00f3n de m\u00e9todos con JavaDoc","text":""},{"location":"ud2/26methods/#introduccion","title":"Introducci\u00f3n","text":"<p>Javadoc es una utilidad de Oracle para la generaci\u00f3n de documentaci\u00f3n de APIs en formato HTML a partir de c\u00f3digo fuente Java. Javadoc es el est\u00e1ndar de la industria para documentar clases de Java. La mayor\u00eda de los IDEs los generan autom\u00e1ticamente. Como nos dice la Wikipedia.</p>"},{"location":"ud2/26methods/#etiquetas-javadoc","title":"Etiquetas Javadoc","text":"<p>Para generar API con Javadoc han de usarse etiquetas (tags) de HTML o ciertas palabras reservadas precedidas por el car\u00e1cter \"@\". Estas etiquetas se escriben al principio de cada clase, miembro o m\u00e9todo, dependiendo de qu\u00e9 objeto se desee describir, mediante un comentario iniciado con \"/*\" y acabado con \"/\"</p> <p><pre><code>/**\n\n * Esto es un comentario para javadoc \n\n */\n</code></pre> Las etiquetas que podemos utilizar</p> TAG DESCRIPCI\u00d3N @author Nombre del desarrollador. @deprecated Indica que el m\u00e9todo o clase es obsoleto (propio de versiones anteriores) y que no se recomienda su uso. @param Definici\u00f3n de un par\u00e1metro de un m\u00e9todo, es requerido para todos los par\u00e1metros del m\u00e9todo. @return Informa de lo que devuelve el m\u00e9todo, no se aplica en constructores o m\u00e9todos \"void\". @see Asocia con otro m\u00e9todo o clase. @version Versi\u00f3n del m\u00e9todo o clase. <p>Las etiquetas @author y @version se usan para documentar clases e interfaces. Por tanto no son v\u00e1lidas en cabecera de constructores ni m\u00e9todos. La etiqueta @param se usa para documentar constructores y m\u00e9todos. La etiqueta @return se usa solo en m\u00e9todos de tipo funci\u00f3n.</p>"},{"location":"ud2/26methods/#ejemplo-javadoc","title":"Ejemplo JavaDoc","text":"<pre><code>/**\n * Esta funci\u00f3n cuenta el n\u00famero de palabras en un String.\n *\n * @param texto El String del cual contar las palabras.\n * @return El n\u00famero de palabras en el String.\n */\npublic static int contarPalabras(String texto) {\n    if (texto == null || texto.isEmpty()) {\n        return 0;\n    }\n    // Dividir el texto en palabras usando espacios en blanco como delimitador.\n    String[] palabras = texto.split(\" \"); \n    return palabras.length;\n}\n</code></pre>"},{"location":"ud2/26pro_modular/","title":"Programaci\u00f3n modular","text":""},{"location":"ud2/26pro_modular/#introduccion","title":"Introducci\u00f3n","text":"<p>Como nos dice la wikipedia:</p> <p>La programaci\u00f3n modular es un paradigma de programaci\u00f3n que consiste en dividir un programa en m\u00f3dulos o subprogramas con el fin de hacerlo m\u00e1s legible y manejable</p> <p></p> <p>Se presenta hist\u00f3ricamente como una evoluci\u00f3n de la programaci\u00f3n estructurada para solucionar problemas de programaci\u00f3n m\u00e1s grandes y complejos de lo que esta puede resolver.</p> <p>Al aplicar la programaci\u00f3n modular, un problema complejo debe ser dividido en varios subprogramas m\u00e1s simples, y estos a su vez en otros subprogramas m\u00e1s simples a\u00fan. Esto debe hacerse hasta obtener subprogramas lo suficientemente simples como para poder ser resueltos f\u00e1cilmente con alg\u00fan lenguaje de programaci\u00f3n. Esta t\u00e9cnica se llama refinamiento sucesivo, divide y vencer\u00e1s o an\u00e1lisis descendente (Top-Down).</p> <p></p> <p>Un 'm\u00f3dulo' es cada una de las partes de un programa que resuelve uno de los subproblemas en que se divide el problema complejo original. Cada uno de estos m\u00f3dulos tiene una tarea bien definida y algunos necesitan de otros para poder operar. En caso de que un m\u00f3dulo necesite de otro, puede comunicarse con este mediante una interfaz de comunicaci\u00f3n que tambi\u00e9n debe estar bien definida.</p>"},{"location":"ud2/2switch/","title":"Sentencia SWITCH","text":"<p>Otra estructura de selecci\u00f3n o alternativa para agregar a nuestro repertorio es la estructura switch.</p> <p> </p> <p>La expresi\u00f3n switch se eval\u00faa una vez. El valor de la expresi\u00f3n se compara con los valores de cada caso. Si hay una coincidencia, se ejecuta el bloque de c\u00f3digo asociado. Las palabras clave break y default son opcionales. Los casos (case) suelen ser literales que no var\u00edan, y a menudo se usan constantes o el tipo de dato enum. No se aceptan el tipo punto flotante(34.5)</p> <p>Es una forma abreviada de codificar la estructura de selecci\u00f3n m\u00faltiple que vimos en el cap\u00edtulo anterior.</p> <p>De forma que el siguiente c\u00f3digo expresado con if-else m\u00faltiple:</p> <pre><code>    if (numJugadores == 1) {\n        System.out.println(\"Single player\");\n    } else if (numJugadores == 2) {\n        System.out.println(\"Two player\");\n    } else if (numJugadores == 3) {\n        System.out.println(\"Multiplayer\");\n    } else {\n        System.out.println(\"Not possible, too many players\");\n    }\n</code></pre> <p>Es equivalente a:</p> <pre><code>    switch (numJugadores) {\n        case 1:\n            System.out.println(\"Single player\");\n            break;\n        case 2:\n            System.out.println(\"Two player\");\n            break;\n        case 3:\n            System.out.println(\"Multiplayer\");\n            break;\n        default:\n            System.out.println(\"Not possible, too many players\");\n    }\n</code></pre>"},{"location":"ud2/2switch/#break","title":"BREAK","text":"<p>Cuando el programa Java alcanza la palabra break, se sale del bloque switch. Es decir, ya no se sigue ejecutando m\u00e1s c\u00f3digo dentro del switch ni ning\u00fan case.</p> <p>Un break puede ahorrar mucho tiempo de ejecuci\u00f3n porque \"ignora\" la ejecuci\u00f3n de todo el resto del c\u00f3digo switch.</p>"},{"location":"ud2/2switch/#default","title":"DEFAULT","text":"<p>La palabra default se usa para ejecutar c\u00f3digo cuando no hay ninguna coincidencia con ning\u00fan caso (case). Siempre se pone al final, por tanto no necesita de la instrucci\u00f3n break.</p>"},{"location":"ud2/2switch/#agrupar-casos","title":"Agrupar casos","text":"<p>En el Switch se va comparando cada case y una vez que encuentra una coincidencia ejecuta todo el c\u00f3digo de switch hasta que se encuntra un break o termina.</p> <p><pre><code>int numJugadores=2;\nswitch (numJugadores) {\n    case 1:\n        System.out.println(\"Single player\");\n    case 2:\n        System.out.println(\"Two player\");\n    case 3:\n        System.out.println(\"Multiplayer\");\n    default:\n        System.out.println(\"Not possible, too many players\");\n}\n</code></pre> Se ejecuta el c\u00f3digo marcado</p> <p></p> <p>Esta caracter\u00edstica la podemos aprovechar para agrupar casos</p> <pre><code>String diaSemana=\"Mi\u00e9rcoles\";\nswitch (diaSemana) {\n    case \"Lunes\":               \n    case \"Martes\":\n    case \"Mi\u00e9rcoles\":\n    case \"Jueves\":\n    case \"Viernes\":\n        System.out.println(\"Es un d\u00eda laborable.\");\n        break;\n    case \"S\u00e1bado\":\n    case \"Domingo\":\n        System.out.println(\"Es un fin de semana.\");\n        break;\n    default:\n        System.out.println(\"D\u00eda no v\u00e1lido.\");\n        break;\n}\n</code></pre>"},{"location":"ud2/2switch2/","title":"Nuevo SWITCH de Java 12","text":"<p>El nuevo <code>switch</code> en Java, introducido en Java 12 como una caracter\u00edstica experimental y estabilizado en Java 14, ofrece una versi\u00f3n m\u00e1s flexible y concisa del tradicional switch</p> <p>Principales Novedades del Nuevo switch en Java:</p>"},{"location":"ud2/2switch2/#switch-como-expresion","title":"switch como expresi\u00f3n","text":"<p>El nuevo <code>switch</code> puede usarse como expresi\u00f3n, lo que significa que puede devolver un valor.</p> <pre><code>int day = 3;\n//el resultado lo asigna a diaSemana\nString diaSemana = switch (day) {\n    case 1 -&gt; \"Lunes\";\n    case 2 -&gt; \"Martes\";\n    case 3 -&gt; \"Mi\u00e9rcoles\";\n    case 4 -&gt; \"Jueves\";\n    case 5 -&gt; \"Viernes\";\n    case 6, 7 -&gt; \"Fin de semana\";\n    default -&gt; \"D\u00eda inv\u00e1lido\";\n};\nSystem.out.println(diaSemana); // Salida: Mi\u00e9rcoles\n</code></pre> <ul> <li>El <code>switch</code> devuelve un valor que se puede asignar directamente a la variable <code>diaSemana</code>.</li> <li>Se utiliza la flecha (<code>-&gt;</code>) en lugar de <code>case:</code> y <code>break</code>, lo que simplifica la sintaxis.</li> <li>M\u00faltiples casos pueden estar en una misma l\u00ednea (ej: <code>case 6, 7</code>).</li> </ul>"},{"location":"ud2/2switch2/#uso-de-yield","title":"Uso de <code>yield</code>","text":"<p>Cuando se utiliza el nuevo <code>switch</code> como expresi\u00f3n, es posible devolver un valor en una estructura de varias l\u00edneas usando la palabra clave <code>yield</code></p> <p>El uso de <code>yield</code> permite ejecutar l\u00f3gica adicional antes de devolver el resultado dentro de cada caso, lo que ofrece m\u00e1s flexibilidad.</p> <pre><code>    int nota = 7;\n\n    String calificacion = switch (nota) {\n        case 0, 1, 2, 3, 4 -&gt; {\n            System.out.println(\"Nota baja, suspenso.\");\n            yield \"Suspenso\";\n        }\n        case 5 -&gt; {\n            System.out.println(\"Nota suficiente.\");\n            yield \"Suficiente\";\n        }\n        case 6 -&gt; {\n            System.out.println(\"Nota aceptable.\");\n            yield \"Bien\";\n        }\n        case 7, 8 -&gt; {\n            System.out.println(\"Buen desempe\u00f1o.\");\n            yield \"Notable\";\n        }\n        case 9, 10 -&gt; {\n            System.out.println(\"Excelente rendimiento.\");\n            yield \"Sobresaliente\";\n        }\n        default -&gt; {\n            System.out.println(\"Nota fuera de rango.\");\n            yield \"Nota inv\u00e1lida\";\n        }\n    };\n\n    System.out.println(\"La calificaci\u00f3n es: \" + calificacion);\n    /*Salida:\n    Buen desempe\u00f1o.\n    La calificaci\u00f3n es: Notable\n        */\n</code></pre> <ul> <li><code>yield</code>: Se usa para devolver el valor dentro de cada caso de switch. Esto es \u00fatil cuando se quiere ejecutar m\u00e1s de una l\u00ednea de c\u00f3digo dentro de un caso antes de devolver el resultado.</li> <li>Bloque de c\u00f3digo: Cada caso tiene ahora m\u00e1s l\u00f3gica (por ejemplo, imprimir un mensaje adicional antes de devolver la calificaci\u00f3n o realizar c\u00e1lculos como media aritm\u00e9tica).</li> <li>Uso de <code>yield</code> en lugar de <code>return</code>: Dado que el <code>switch</code> se usa como una expresi\u00f3n, <code>yield</code> es necesario para devolver un valor desde un bloque de varias l\u00edneas dentro del <code>switch</code>.</li> </ul> <p>Informaci\u00f3n</p> <p>Pod\u00e9is utilizar indistintamente las dos versiones de <code>switch</code>, pero es necesario dominar la versi\u00f3n tradicional, ya que, existe mucho c\u00f3digo escrito con esta versi\u00f3n. Por otro lado, tener en cuenta, que la versi\u00f3n nueva no funcionar\u00e1 en JRE/JDK inferiores a la 12.</p> <p>Las versiones LTS seg\u00fan sus fechas:</p> <ul> <li>Java 8 (LTS): Lanzado en marzo de 2014, sigue siendo ampliamente utilizado en la industria. Oracle proporciona soporte extendido para Java 8 hasta diciembre de 2030 (bajo contratos de soporte comercial). Es una de las versiones m\u00e1s adoptadas debido a su estabilidad.</li> <li>Java 11 (LTS): Lanzado en septiembre de 2018. Es la versi\u00f3n LTS m\u00e1s popular en la actualidad para proyectos modernos. Tiene soporte hasta septiembre de 2026 (soporte extendido hasta 2027 o m\u00e1s si se contrata soporte comercial).</li> <li>Java 17 (LTS): Lanzado en septiembre de 2021. Ser\u00e1 la opci\u00f3n preferida a largo plazo. Tiene soporte hasta septiembre de 2029 (soporte extendido hasta 2031).</li> <li>Java 21 (LTS): Lanzado en septiembre de 2023. Es la versi\u00f3n LTS m\u00e1s actual. Tiene grandes mejoras, se espera su integraci\u00f3n en los nuevos proyecto.</li> </ul>"},{"location":"ud3/0poo/","title":"\ud83d\udcbe Introducci\u00f3n a la programaci\u00f3n orientada a objetos","text":"<p>La programaci\u00f3n modular es un paradigma que consiste en dividir un programa en m\u00f3dulos con el fin de hacerlo m\u00e1s legible y manejable. Enfatiza este concepto mediante la construcci\u00f3n de aplicaciones a partir de su divisi\u00f3n en componentes independientes que llevan a cabo tareas concretas.</p> <p>Al aplicar programaci\u00f3n modular, un problema complejo debe ser dividido en otros subproblemas m\u00e1s simples a\u00fan.</p> <p>Un m\u00f3dulo es cada una de las partes de un programa que resuelve uno de los subproblemas.</p> <p>La programaci\u00f3n orientada a objetos (POO) se basa en la programaci\u00f3n modular, aunque supone una ruptura respecto a \u00e9sta al introducir el concepto de objeto, lo que supone un gran avance en t\u00e9rminos de modularizaci\u00f3n y reutilizaci\u00f3n de c\u00f3digo.</p>"},{"location":"ud3/0poo/#fundamentos-de-la-poo","title":"Fundamentos de la POO","text":"<ul> <li>Abstracci\u00f3n: es el pilar de la POO, un principio por el cual se a\u00edsla toda aquella informaci\u00f3n que no resulta relevante a un determinado nivel de conocimiento. Consiste en captar las caracter\u00edsticas esenciales de un objeto, as\u00ed como su comportamiento. </li> </ul> <p>Por ejemplo, todos los animales mam\u00edferos, los englobamos en el grupo mam\u00edfero. Las personas en un sistema educativo distinguimos por un lado los profesores y por otro los alumnos pero en un sistema de gesti\u00f3n de un restaurante, las personas son empleados y clientes. En el argot de la POO esto son clases</p> <ul> <li>Encapsulaci\u00f3n: se centra en ocultar la complejidad de la clase. Significa proteger a los miembros de una clase de un acceso ilegal o no autorizado.</li> <li>Herencia: es el pilar m\u00e1s fuerte que asegura la reutilizaci\u00f3n de c\u00f3digo. Permite la definici\u00f3n de nuevas clases a partir de otras ya existentes.</li> </ul> <p> </p> <ul> <li>Polimorfismo: posibilita que una misma operaci\u00f3n pueda realizar tareas diferentes, dependiendo del tipo de objeto sobre el cual se ha invocado.</li> </ul> <p></p>"},{"location":"ud3/0poo/#ejemplo","title":"Ejemplo","text":"<p>En un juego como Minecraft, en los que se utilizan bloques  para construir un mundo, los bloques de diferente tipo tienen muchas caracter\u00edsticas comunes, como que son apilables, tienen las mismas dimensiones, posici\u00f3n en el mundo...pero pueden tener diferentes texturas o se comportan diferente al tocarlo el personaje (algunos pueden explotar). </p> <p>De esta forma, mediante la POO podemos crear una clase base con las caracter\u00edsticas comunes(dimensi\u00f3n, posici\u00f3n en el mundo, acci\u00f3n_dibujar) y crear clases que hereden de la base con sus caracter\u00edsticas individuales(potencia_explosi\u00f3n, soporte...) y reescribir aquellas acciones que lo personalizan, como puede ser accion_dibujar en la que cada tipo de bloque se dibujar\u00e1 de forma diferente, por lo que cada clase tendr\u00e1 que describir como hacerlo.</p> <p></p>"},{"location":"ud3/0poo/#concepto-de-objeto","title":"Concepto de objeto","text":"<p>Entonces, \u00bfqu\u00e9 es un objeto? Al igual que en el mundo real, un objeto es cualquier cosa. Un objeto puede ser una cosa f\u00edsica, como un coche, o una cosa mental, como una idea. Puede ser algo natural, como un animal, o algo artificial hecho por el hombre, como un cajero autom\u00e1tico. Un programa que administra un cajero autom\u00e1tico involucrar\u00eda cuentas bancarias y objetos de cliente. Un programa de ajedrez involucrar\u00eda un objeto tablero y objetos piezas de ajedrez.</p> <p>Otro ejemplo puedes ser el juego de Minecraft, podemos tener una clase por cada tipo de elemento de construcci\u00f3n, y en el momento que a\u00f1adimos un bloque al mundo que estamos creando un objeto de ese tipo. Tendremos por ejemplo una clase \"bloque c\u00e9sped\" y tantos objetos c\u00e9sped como haya a\u00f1adido el jugador</p> <p></p>"},{"location":"ud3/0poo/#atributos-y-acciones","title":"Atributos y acciones","text":""},{"location":"ud3/0poo/#atributos","title":"Atributos","text":"<p>Al igual que con los objetos reales, los objetos de nuestros programas tienen ciertos atributos o propiedades caracter\u00edsticos. Por ejemplo, un objeto de cajero autom\u00e1tico tendr\u00eda una cantidad actual de efectivo que podr\u00eda dispensar. Un objeto pieza ajedrez puede tener un par de atributos de fila y columna que especifiquen su posici\u00f3n en el tablero de ajedrez. Observe que los atributos de un objeto son en s\u00ed mismos objetos. El atributo de efectivo del cajero autom\u00e1tico y los atributos de fila y columna de la pieza de ajedrez son n\u00fameros.</p> <p>A veces nos referimos a la colecci\u00f3n de atributos y valores de un objeto como su estado.</p>"},{"location":"ud3/0poo/#acciones-o-metodos","title":"Acciones o M\u00e9todos","text":"<p>Adem\u00e1s de sus atributos o propiedades, los objetos tambi\u00e9n tienen acciones o comportamientos caracter\u00edsticos. Como ya dijimos, los objetos en los programas son din\u00e1micos. Hacen cosas o les hacen cosas.</p> <p>Por ejemplo, en un programa de ajedrez, ChessPieces tiene la capacidad de moveTo () a una nueva posici\u00f3n en el tablero de ajedrez. De manera similar, cuando un cliente presiona el bot\u00f3n \"Saldo actual\" en un cajero autom\u00e1tico, esto le est\u00e1 diciendo al cajero autom\u00e1tico que informe () el saldo bancario actual del cliente. (Observe c\u00f3mo usamos par\u00e9ntesis para distinguir acciones de objetos y atributos).</p> <p>Las acciones asociadas con un objeto se pueden utilizar para enviar mensajes a los objetos y recuperar informaci\u00f3n de los objetos. Un mensaje es el paso de informaci\u00f3n o datos de un objeto a otro. En este ejemplo, le decimos a pe\u00f3n1: Pieza de ajedrez que se mueva a (3,4).</p> <pre><code>    chessPiece.move(3, 4);\n</code></pre> <p>Los n\u00fameros 3 y 4 en este caso son argumentos que le dicen al pe\u00f3n a qu\u00e9 casilla moverse. (Un tablero de ajedrez tiene 8 filas y 8 columnas y cada cuadrado se identifica por sus coordenadas de fila y columna). En general, un argumento es un valor de datos que especializa el contenido de un mensaje de alguna manera.</p> <p>Responder a un mensaje o realizar una acci\u00f3n a veces provoca un cambio en el estado de un objeto. Por ejemplo, despu\u00e9s de realizar moveTo (3,4), el pe\u00f3n estar\u00e1 en una casilla diferente. Su posici\u00f3n habr\u00e1 cambiado.</p> <p>Por otro lado, algunos mensajes (o acciones) no modifican el estado del objeto. Informar el saldo de la cuenta bancaria del cliente no cambia el saldo.</p>"},{"location":"ud3/0poo/#caracteristicas-basicas","title":"Caracter\u00edsticas b\u00e1sicas","text":"<ul> <li>Estado: est\u00e1 representado por atributos de un objeto.</li> <li>Comportamiento: se representa mediante m\u00e9todos de un objeto. Tambi\u00e9n refleja la respuesta de un objeto con otros objetos.</li> <li>Identidad: le da un nombre \u00fanico a un objeto y permite que un objeto interact\u00fae con otros objetos.</li> </ul>"},{"location":"ud3/0poo/#creacion-y-destruccion-de-objetos","title":"Creaci\u00f3n y destrucci\u00f3n de objetos","text":""},{"location":"ud3/0poo/#creacion","title":"Creaci\u00f3n","text":"<p>Para crear un objeto utilizamos la palabra reservada new, que asigna memoria del Heap. Se usa el nombre de la clase (constructor) seguido por par\u00e9ntesis. Se le llama instanciar un objeto.</p> <pre><code>    ATM atm = new ATM();\n</code></pre>"},{"location":"ud3/0poo/#destruccion","title":"Destrucci\u00f3n","text":"<p>En Java no es posible destruir objetos de forma expl\u00edcita, los objetos se destruyen de forma autom\u00e1tica por el recolector de basura. Java busca objetos inalcanzables y los destruye, normalmente cuando falta memoria. Los convierte de nuevo en memoria binaria no utilizada.</p>"},{"location":"ud3/0poo/#uso-de-objetos-acceso-a-atributos-y-metodos","title":"Uso de objetos: acceso a atributos y m\u00e9todos","text":"<p>Para acceder a los atributos y m\u00e9todos de un objeto utilizamos la notaci\u00f3n \".\" detr\u00e1s del nombre del objeto. El objeto debe ser creado previamente sino dar\u00e1 error de compilaci\u00f3n.</p> <pre><code>    double cantidad = atm.efectivo;\n    atm.mostrarEfectivo();\n</code></pre> <p>M\u00e1s adelante veremos la visibilidad de los m\u00e9todos y atributos de los objetos.</p>"},{"location":"ud3/1metodoclase/","title":"\ud83c\udf0e Clases en Java","text":"<p>Las clases es el componente fundamental en la POO. Para entender el concepto de clase, primero necesitamos entender que son los objetos ya que son la clave en la tecnolog\u00eda orientada a objetos.</p>"},{"location":"ud3/1metodoclase/#objetos","title":"Objetos","text":"<p>Los objetos de software son una parte fundamental de la programaci\u00f3n orientada a objetos. Son muy similares a los objetos que representan cosas del mundo real. Como puede ser un micr\u00f3fono, altavoz, ordenador, etc. Como ya estudiamos en la unidad 1, los objetos del mundo real tienen tres caracter\u00edsticas, identidad, estado y comportamiento.</p> <p></p>"},{"location":"ud3/1metodoclase/#identidad","title":"\u2747\ufe0f Identidad","text":"<p>La identidad de un objeto normalmente se implementa a trav\u00e9s de un ID \u00fanico. El valor del ID no es visible para el usuario externo. Sin embargo, la JVM lo utiliza internamente para identificar cada objeto de forma \u00fanica.</p>"},{"location":"ud3/1metodoclase/#estado-campos-o-atributos","title":"\u2747\ufe0f Estado - Campos o Atributos","text":"<p>Representa el valor de los datos. Por ejemplo, para un ordenador, el estado podr\u00eda ser la cantidad de memoria RAM que tiene, el sistema operativo que incluye, tama\u00f1o del disco duro, etc. En el caso de una persona, el estado puede ser la edad, el nombre, si est\u00e1 casada, etc.</p> <p></p>"},{"location":"ud3/1metodoclase/#comportamiento-metodos","title":"\u2747\ufe0f Comportamiento - M\u00e9todos","text":"<p>Atendiendo al comportamiento de un ordenador podr\u00eda ser arrancando, apag\u00e1ndose, reiniciando, escribir en la pantalla, etc. Para una persona ser\u00e1 comer, beber, dormir, etc.</p> <p>Los objetos de software almacenan su estado en atributos o propiedades. Es lo que conocemos como variables. Y exponen su comportamiento en lo que llamamos m\u00e9todos.</p> <p> Instancias de la clase</p> <p>Un objeto es una instancia de la clase. Una clase es una plantilla o modelo a partir del cual se crean objetos. Un objeto es la instancia (resultado) de una clase. </p>"},{"location":"ud3/1metodoclase/#clases","title":"Clases","text":"<p>Teniendo en cuenta todo esto, podemos pasar a hablar de clase. Una clase es una plantilla para crear objetos. Para crear un clase en Java utilizamos la palabra reservada <code>class</code>.</p> <p>La nomenclatura del nombre de la clase es primera letra en may\u00fasculas y usar la regla CamelCase para palabras compuestas.</p> <pre><code>    public class Coche {\n\n    }\n</code></pre> <p><code>public</code>: es un modificador de acceso, determina qu\u00e9 acceso queremos permitir a otros en la clase. Existen tres tipos de modificadores de acceso:</p> <ul> <li>public: en este caso, public especifica que no hay ninguna restricci\u00f3n de acceso.</li> <li>private: nadie puede acceder a la clase.</li> <li>protected: permite a las clases de este paquete acceder y subclases.</li> </ul> <ul> <li>class: identificador de clase.</li> </ul> <p>\u00bfDe qu\u00e9 forma nos ayudan las clases en nuestro c\u00f3digo? Bien, hasta ahora solo hemos trabajado con tipos de datos primitivos como int, short, char, etc. Este tipo de datos es bastante limitado. Por tanto, las clases se podr\u00edan considerar como un tipo de dato extra poderoso definido por el usuario que nos permite realizar acciones en las que los datos primitivos se quedan cortos.</p> <p>Una clase puede contener:</p> <ul> <li>Campos</li> <li>M\u00e9todos</li> <li>Constructores</li> <li>Bloques de c\u00f3digo</li> <li>Clases o interfaces anidadas</li> </ul>"},{"location":"ud3/1metodoclase/#miembros-de-la-clase-atributos-y-metodos","title":"Miembros de la clase : atributos y m\u00e9todos","text":""},{"location":"ud3/1metodoclase/#atributos-campos-de-la-clase-o-variables-de-instancia","title":"Atributos, campos de la clase o variables de instancia","text":"<p>Hasta ahora hemos creado variables dentro de un m\u00e9todo. A \u00e9stas se les llama variables locales porque son propias del m\u00e9todo en si. Y no puedes acceder a ellas desde fuera de ese m\u00e9todo. Tambi\u00e9n vimos esto dentro de bloques de c\u00f3digo {}, donde las variables creadas en un bloque m\u00e1s interno no eran accesibles en bloques m\u00e1s externos. Ejemplo:</p> <pre><code>    public static void sumar() {\n        int contador = 0;\n\n        while (contador &lt; 10) {\n            int suma = 0;\n            suma += contador;\n            contador ++;\n        }\n\n        System.out.println(suma); // esto da error, la variable\n        // suma aqu\u00ed no existe.\n    }\n</code></pre> <p>A diferencia de esto, las clases nos permiten crear variables que pueden ser accesibles desde cualquier lugar dentro de la clase que estamos creando. A estas variables se les conoce con el nombre de variables miembro/instancia, o de manera m\u00e1s com\u00fan como campos o atributos de la clase.</p>"},{"location":"ud3/1metodoclase/#creacion-de-atributos-de-la-clase","title":"Creaci\u00f3n de atributos de la clase","text":"<p>Para crear un campo de la clase se debe especificar:</p> <p>un modificador de acceso(opcional) + tipo de dato + nombre de la variable + inicializaci\u00f3n(opcional).</p> <p>Si no se pone modificador utiliza el de por defecto en el que la variable es accesible por las clases dentro del mismo paquete.</p> <p>El modificador de acceso funciona de la misma forma a como lo hemos explicado anteriormente para la creaci\u00f3n de una clase.</p> <pre><code>    public class Coche {\n\n        private int puertas;\n        private int ruedas;\n        private String modelo;\n        private String color;\n\n    }\n</code></pre> <p>Estamos definiendo el estado del coche, es decir, sus caracter\u00edsticas.</p>"},{"location":"ud3/1metodoclase/#modificadores-de-acceso-de-atributos","title":"Modificadores de acceso de atributos","text":"<p>Un buen dise\u00f1o de software refuerza la encapsulaci\u00f3n. Aqu\u00ed es donde las variables de instancia de un objeto son visibles solo para los propios m\u00e9todos del objeto. El c\u00f3digo fuera del objeto no puede acceder directamente a estas variables. Se utiliza para hacer esto el modificador de visibilidad privada. Como regla general, cuando definimos campos para la clase el modificador de acceso ser\u00e1 privado. Es decir, usamos el concepto de encapsulaci\u00f3n que es una clave fundamental de la programaci\u00f3n orientada a objetos. Lo que hacemos es ocultar los campos de la clase del acceso p\u00fablico para que nadie pueda acceder y modificar los campos de la clase. Significa que la representaci\u00f3n del objeto se ocultar\u00e1 a la vista, es decir, el funcionamiento interno del objeto.</p> <p>Existen los siguientes tipos de modificadores, ordenados de menor a mayor restricci\u00f3n:</p> <ul> <li>public: son accesibles desde cualquier lugar. </li> <li>protected: son accesibles desde dentro del mismo paquete y en clases heredadas.</li> <li>sin modificador: son accesibles desde la propia clase y clases dentro del mismo paquete.</li> <li>private: solo son accesibles desde la propia clase, no son accesibles desde fuera.</li> </ul> <p></p> <pre><code>    //modificador p\u00fablico\n    public int speed;\n\n    //modificador protegido\n    protected int speed;\n\n    //sin modificador\n    int speed;\n\n    //modificador privado\n    private int speed;\n</code></pre>"},{"location":"ud3/1metodoclase/#encapsulacion","title":"Encapsulaci\u00f3n","text":"<p>Uno de los pilares de la POO es la encapsulaci\u00f3n, y se refiere al ocultamiento de los datos miembro de un objeto, de manera que solo se pueda cambiar mediante las operaciones definidas para ese objeto.</p> <p></p>"},{"location":"ud3/1metodoclase/#consejos-para-elegir-un-nivel-de-acceso","title":"Consejos para elegir un nivel de acceso.","text":"<ul> <li>Utiliza el nivel de acceso m\u00e1s restrictivo que tenga sentido para un miembro en particular. Usa private a menos que tengas una buena raz\u00f3n para no hacerlo.</li> <li>Evita los campos p\u00fablicos a excepci\u00f3n de las constantes.</li> </ul>"},{"location":"ud3/1metodoclase/#metodos-de-acceso-getters-y-setters","title":"M\u00e9todos de acceso: Getters y Setters","text":"<p>Hemos visto que la encapsulaci\u00f3n se aconseja la ocultaci\u00f3n de la informaci\u00f3n. </p> <p>\u00bfC\u00f3mo accedemos a la informaci\u00f3n?</p> <p>Para actualizar las propiedades de la clase, como su acceso es privado se utilizan los m\u00e9todos de acceso.</p> <p></p> <p>Para crear los m\u00e9todos que actualizan los campos debemos usar la siguiente nomenclatura:</p> <ul> <li> <p>Setters: Permiten modificar una propiedad del objeto.</p> <p>public void setNombreCampo(TipoDatoCampo nombreCampo), donde el par\u00e1metro del m\u00e9todo debe ser del mismo tipo ya que vamos a actualizar su valor mediante el m\u00e9todo.</p> </li> <li> <p>Getters: devuelven el valor de una propiedad de un objeto de la clase</p> <p>public tipoDatoCampo getNombreCampo()</p> </li> </ul> <pre><code>    public class Coche {\n\n        private int puertas;\n        private int ruedas;\n        private String modelo;\n        private String color;\n\n        public void setPuertas(int puertas) {\n            this.puertas = puertas;\n        }\n\n        public int getPuertas() {\n            return this.puertas;\n        }\n\n        public void setRuedas(int ruedas) {\n            this.ruedas = ruedas;\n        }\n\n        public int getRuedas() {\n            return this.ruedas;\n        }\n\n        public void setModelo(String modelo) {\n            this.modelo = modelo;\n        }\n\n        public String getModelo() {\n            return this.modelo;\n        }\n\n        public void setColor(String color) {\n            this.color = color;\n        }\n\n        public String getColor() {\n            return this.color;\n        }\n\n    }\n</code></pre>"},{"location":"ud3/1metodoclase/#palabra-reservada-this","title":"Palabra reservada this","text":"<p>This hace referencia al objeto actual de la clase. En un m\u00e9todo set, como el nombre del par\u00e1metro del m\u00e9todo es igual al del campo de la clase, necesitamos algo que nos permita distinguir entre uno u otro. Para esto se utiliza la palabra reservada this que hace alusi\u00f3n al campo de la clase.</p> <p></p>"},{"location":"ud3/1metodoclase/#proteccion-de-datos-de-la-clase","title":"Protecci\u00f3n de datos de la clase","text":"<p>Los setter y getter nos permite la introducci\u00f3n de datos correctos en el objeto. Por ejemplo, si las especificaciones nos indican que el n\u00famero de puertas solamente pueden ser 3, 4 \u00f3 5. Podemos tener un m\u00e9todo setter</p> <pre><code>public void setPuertas(int puertas){\n    if(puertas&gt;=3 || puertas&lt;=5){\n        this.puertas=puertas;\n    }else {\n        System.err.println(\"Error: n\u00famero de puertas incorrecto\");\n}\n}\n</code></pre>"},{"location":"ud3/1metodoclase/#transformacion-de-datos","title":"Transformaci\u00f3n de datos","text":"<p>Tambi\u00e9n se puede dar el caso que  queramos mostrar siempre el modelo en may\u00fasculas. Podemos tener un setter que transforme los datos de entrada</p> <pre><code>public void setModelo(String modelo) {\n        this.modelo = modelo.toUpperCase();\n    }\n</code></pre> <p>Si quisi\u00e9ramos mantener los datos de entrada del usuario para la propiedad modelo pero al obtener el dato lo queremos devolver siempre en may\u00fasculas, la soluci\u00f3n puede ser:</p> <pre><code>public void setModelo(String modelo) {\n    this.modelo = modelo;\n}\n\npublic String getModelo() {\n    //devolvemos el string en may\u00fasculas\n    return modelo.toUpperCase();\n}\n</code></pre>"},{"location":"ud3/1metodoclase/#clase-object-en-java","title":"Clase Object en java","text":"<p>Es necesario conocer a grandes rasgos la clase <code>Object</code>. Tambi\u00e9n es llamada como clase c\u00f3smica, ya que la clase <code>Object</code>, es la clase que est\u00e1 por encima de todas las clases de la api de java.</p> <p></p> <p>Esto quiere decir que todas las clases de java que vienen predefinidas en el lenguaje de programaci\u00f3n, como las que nosotros construimos, heredan de la clase <code>object</code>.</p> <p>Por eso, cuando creamos un objeto, viene ya definido con ciertos m\u00e9todos que se han heredado de la clase <code>Object</code>.</p> <p></p>"},{"location":"ud3/1metodoclase/#javadoc-documentacion-de-la-clase","title":"JavaDoc: Documentaci\u00f3n de la clase","text":"<p>Como ya indicamos en el tema de programaci\u00f3n modular, tenemos la siguientes tags para documentar con JavaDoc</p> <p>Las etiquetas que podemos utilizar</p> TAG DESCRIPCI\u00d3N @author Nombre del desarrollador. @deprecated Indica que el m\u00e9todo o clase es obsoleto (propio de versiones anteriores) y que no se recomienda su uso. @param Definici\u00f3n de un par\u00e1metro de un m\u00e9todo, es requerido para todos los par\u00e1metros del m\u00e9todo. @return Informa de lo que devuelve el m\u00e9todo, no se aplica en constructores o m\u00e9todos \"void\". @see Asocia con otro m\u00e9todo o clase. @version Versi\u00f3n del m\u00e9todo o clase. <p>Las etiquetas @author y @version se usan para documentar clases e interfaces, de esta manera, podemos documentar la clase Coche:</p> <pre><code>/**\n * La clase Coche contiene la informaci\u00f3n b\u00e1sica de los coches de\n * la empresa\n * @version 2.11.2023\n * @author Pepito Grillo\n */\npublic class Coche {\n    private int puertas;\n    private double peso;\n    private double precio;\n    private String motor;\n    private int ruedas;\n    private String modelo;\n    private String color;\n}\n</code></pre>"},{"location":"ud3/2constructor/","title":"\ud83c\udf0e Creaci\u00f3n e inicializaci\u00f3n de objetos de la clase","text":"<p>Para crear objetos de la clase, podemos hacerlo de dos formas:</p> <ul> <li>Creando un variable de la clase como hemos hecho hasta ahora:</li> </ul> <pre><code>Coche seat; //(Aqu\u00ed la variable no est\u00e1 inicializada y\n// puede dar errores de compilaci\u00f3n).\n</code></pre> <ul> <li>Utilizando la palabra resevada new m\u00e1s el nombre de la clase:</li> </ul> <pre><code>Coche seat = new Coche(); //En este caso la variable es creada e inicializada\n</code></pre>"},{"location":"ud3/2constructor/#constructor","title":"Constructor","text":"<p>Cuando usamos la palabra new Coche(); para crear un objeto de la clase Coche, en realidad estamos usando lo que se conoce como el constructor de la clase para crear el coche. El constructor por normal general da valor a los campos de la clase.</p>"},{"location":"ud3/2constructor/#constructor-por-defecto","title":"Constructor por defecto","text":"<p>En Java cuando creamos un objeto con la sentencia new Coche(), se lanza el llamado contructor por defecto. Si no se ha definido este en la clase, Java lo crea y lo lanza autom\u00e1ticamente e iniciliza los campos de la clase con valores por defecto.</p> <p>Si queremos definirlo nosotros tenemos que usar public m\u00e1s el nombre de la clase.</p> <pre><code>public class Coche {\n\n    private int puertas;\n    private String modelo;\n    private String color;\n\n    //Constructor por defecto\n    public Coche() {\n\n    }\n\n    //getters y setters\n}\n</code></pre>"},{"location":"ud3/2constructor/#constructor-parametrizado","title":"Constructor parametrizado","text":"<p>Un constructor parametrizado tiene uno o m\u00e1s par\u00e1metros. Podemos usar un constructor parametrizado en caso de que necesitemos pasar algunos valores iniciales a la variable miembro de la clase.</p> <pre><code>public Coche(int puertas, String color) {\n    this.puertas = puertas;\n    this.color = color;\n}\n</code></pre>"},{"location":"ud3/2constructor/#constructor-sobrecargado","title":"Constructor sobrecargado","text":"<p>Ahora surge la pregunta de si una clase puede tener m\u00e1s de un constructor o si una clase solo puede tener un constructor. Podemos tener varios constructores en una clase. Los constructores pueden ser sobrecargados al igual que los m\u00e9todos, es decir, podemos tener m\u00e1s de un constructor en nuestra clase siempre que cambiemos el n\u00famero de par\u00e1metros. Por ejemplo:</p> <pre><code>public Coche(String modelo) {\n    this.modelo = modelo;\n}\n\npublic Coche(int puertas, String color) {\n    this.puertas = puertas;\n    this.color = color;\n}\n\npublic Coche(int puertas, String modelo, String color) {\n    this.puertas = puertas;\n    this.color = color;\n    this.modelo = modelo;\n}\n</code></pre> <p>Estos ser\u00edan dos constructores diferentes para el objeto Coche, donde en uno se construye usando el modelo y en el otro el n\u00famero de puertas.</p> <p>A estos constructores tambi\u00e9n se les conoce como constructor parametrizado.</p> <p>Warning</p> <p>Si se define un constructor con par\u00e1metros en la clase, Java entiende que la clase tiene una forma de construirse y no crear\u00e1 de forma autom\u00e1tica el constructor por defecto Coche(). Por tanto si tenemos c\u00f3digo como Coche coche = new Coche(); nos lanzar\u00e1 un error de compilaci\u00f3n.</p>"},{"location":"ud3/2constructor/#llamar-a-un-constructor-desde-otro-dentro-de-la-misma-clase","title":"Llamar a un constructor desde otro dentro de la misma clase","text":"<p>Hemos comentado que podemos tener m\u00e1s de un constructor en nuestra clase gracias a la sobrecarga. En corcondancia con esto, tambi\u00e9n podemos llamar a un constructor desde otro constructor.</p> <p>Por ejemplo, el constructor por defecto es llamado cuando hacemos new Coche(); pero dentro de este constructor no se inicializa ning\u00fan campo, y tal vez nosotros queramos crear el objeto con algunos valores predeterminados. Entonces llamar\u00edamos desde dentro del constructor por defecto a un constructor parametrizado.</p> <pre><code>public Coche() {\n    this(5, \"blanco\");//invoco al constructor con 2 par\u00e1metros\n}\n\npublic Coche(int puertas, String color) {\n    this(puertas, \"desconocido\", color);//invoco al constructor con 3 par\u00e1metros\n}\n\npublic Coche(int puertas, String modelo, String color) {\n    this.puertas = puertas;\n    this.color = color;\n    this.modelo = modelo;\n}\n</code></pre> <p>En el c\u00f3digo anterior, cada vez que creamos un coche vac\u00edo, le asignamos por defecto 5 puertas y color blanco como valores predeterminados.</p> <p>Con esto te aseguras que el objeto se crea con todos los campos inicializados.</p>"},{"location":"ud3/2constructor/#constructor-copia-en-java","title":"Constructor copia en Java","text":"<p>Cuando igualamos dos objetos, no estamos haciendo una copia del objeto, lo que hacemos es apuntar a ese mismo objeto en memoria. En el siguiente ejemplo tenemos dos variables <code>book</code> y <code>book2</code> apuntando al mismo objeto en memoria, es decir, cualquier cambio que realice alguna de las variables, afectar\u00e1 al objeto en s\u00ed apuntado por las mismas.</p> <pre><code>    Book book = new Book(\"1234ASICK\", \"War and Fire\", \"David Haig\");\n    Book book2 = book;\n    book2.setIsbn(\"9000ISBN234\");\n    System.out.println(book.getIsbn());//imprimir\u00e1 9000ISBN234\n</code></pre> Variables <code>book</code> y <code>book2</code> apuntando a un mismo objeto Modificaci\u00f3n del isbn por la variable <code>book2</code>, pero <code>book</code> tambi\u00e9n se ve reflejada <p>Si queremos realizar una copia de un objeto, es decir, traspasar los valores que tiene a un nuevo objeto, necesitamos invocar al constructor copia.</p> <p>El constructor copia es un tipo de constructor que recibe como par\u00e1metro un objeto de la misma clase. Es decir, en este caso estamos creando objetos de tipo coche, por lo que el constructor recibir\u00e1 por par\u00e1metro un objeto de este tipo. Veamos entonces un ejemplo donde se muestra este tipo de constructor:</p> <pre><code>public class Coche {\n\n    private int puertas;\n    private String modelo;\n    private String color;\n\n    //Constructor copia\n    public Coche(Coche objCoche) {\n        this.puertas = objCoche.puertas;\n        this.color = objCoche.color;\n        this.modelo = objCoche.modelo;\n    }\n\n}\n</code></pre>"},{"location":"ud3/2constructor/#destructor","title":"Destructor","text":"<p>En algunos lenguajes de programaci\u00f3n, para destruir un objeto, existen varios m\u00e9todos o funciones que se ejecutan de forma autom\u00e1tica para destruirlo. Esta funci\u00f3n no devuelve ning\u00fan valor, (por lo tanto es de tipo void), y no recibe ning\u00fan par\u00e1metro.</p> <p>Por otro lado, es importante destacar que en java no existen destructores. Java es un lenguaje que posee un recolector de basura (garbage collector). Este recolector de basura, ejecuta autom\u00e1ticamente un m\u00e9todo llamado finalize(). Por lo tanto, cuando un programa java ya no est\u00e1 utilizando un objeto se realizan dos acciones:</p> <ul> <li>Por un lado entra en acci\u00f3n de forma autom\u00e1tica el garbage collector.</li> <li>Este recolector de basura llama al m\u00e9todo finalize() y lo ejecuta.</li> <li>Para finalizar, se destruye el objeto y se liberan los recursos utilizados en la memoria RAM del ordenador.</li> </ul>"},{"location":"ud3/3sobrecargametodos/","title":"\ud83c\udf0e M\u00e9todos y sobrecarga de m\u00e9todos","text":"<p>En el punto 2.6 del curso vimos una introducci\u00f3n a los m\u00e9todos, qu\u00e9 son, c\u00f3mo definirlos y sus partes. En los siguientes puntos vamos estudiar conceptos relacionados con los m\u00e9todos.</p>"},{"location":"ud3/3sobrecargametodos/#sobrecarga-de-metodos","title":"Sobrecarga de m\u00e9todos","text":"<p>La sobrecarga de m\u00e9todos es una caracter\u00edstica que nos permite tener m\u00e1s de un m\u00e9todo con el mismo nombre, siempre que usemos diferentes par\u00e1metros. Es la capacidad de crear m\u00faltiples m\u00e9todos con el mismo nombre pero diferentes implementaciones</p> <p>Esto tambi\u00e9n se aplica a los constructores como ya hemos visto, ten\u00edamos m\u00e1s de un constructor con el mismo nombre pero diferente n\u00famero de argumentos.</p> <p></p> <p>No hay l\u00edmite en la cantidad de sobrecarga que se puede hacer al dise\u00f1ar constructores y m\u00e9todos, la \u00fanica restricci\u00f3n es que cada m\u00e9todo debe tener una signature distinta con el mismo nombre.</p> <p>La signature(firma) de un m\u00e9todo consta del nombre del m\u00e9todo, m\u00e1s el n\u00famero, los tipos y el orden de sus par\u00e1metros formales. Una clase no puede contener dos m\u00e9todos con la misma signature.</p> <p></p>"},{"location":"ud3/3sobrecargametodos/#ambito-de-variables-locales-y-argumentos","title":"\u00c1mbito de variables locales y argumentos","text":"<p>El estado de un objeto consta de los datos que contiene en sus variables de instancia(campos o atributos). Las variables de instancia mantienen sus valores hasta que se cambian expl\u00edcitamente o hasta que se destruye el objeto.</p> <p>Los m\u00e9todos de un objeto suelen trabajar con otros valores que no se mantienen en las variables de instancia. Estos valores se mantienen en variables y par\u00e1metros locales.</p> <p>En el ejemplo de la clase Cuenta.java ten\u00edamos:</p> <pre><code>public class Cuenta {\n\n    private double balance;\n    ...\n\n    public void ingresar(double cantidad) {\n        this.balance = this.balance + cantidad;\n        System.out.println(\"Balance actual \" + this.balance);\n    }\n}\n</code></pre> <p>La persona que llama al m\u00e9todo ingresar utiliza el par\u00e1metro cantidad para enviar un valor al m\u00e9todo. A esto se le llama pasar un valor al m\u00e9todo.</p> <p>Desde el m\u00e9todo main() llamamos al m\u00e9todo ingresar que usa el par\u00e1metro para pasar un valor al m\u00e9todo:</p> <pre><code>public static void main( String[] args ) {\n    Cuenta patriCuenta = new Cuenta(\"1234567\", 0.0, \"Patricia\");\n    c.ingresar(50);\n}\n</code></pre> <p>Cuando se ejecuta al m\u00e9todo ingresar(50), al par\u00e1metro cantidad se le da el valor 50, luego se ejecuta el interior del m\u00e9todo, y el valor se suma a la variable de instancia o campo balance. El m\u00e9todo termina y el control vuelve al m\u00e9todo main(), pero el balance del objeto patriCuenta ha cambiado.</p> <p>Las variables de instancia se utilizan para almacenar el estado de un objeto. Mantienen los valores mientras exista el objeto.</p> <p>Si intent\u00e1ramos usar la variable cantidad en otro m\u00e9todo, nos dar\u00eda error de compilaci\u00f3n, puesto que esa variable no existe fuera del m\u00e9todo ingresar, es lo que se conoce como una variable local.</p> <p></p> <p>Podr\u00edamos tener otro m\u00e9todo que definiera o usara otra variable llamada cantidad.</p> <pre><code>public class Cuenta {\n\n    private double balance;\n    ...\n\n    public void ingresar(double cantidad) {\n        this.balance = this.balance + cantidad;\n        System.out.println(\"Balance actual \" + this.balance);\n    }\n\n    public void retirar(double cantidad) {\n        this.balance = this.balance - cantidad;\n    }\n}\n</code></pre> <p>En el m\u00e9todo retirar la variable cantidad es una variable diferente a la que usamos en el m\u00e9todo ingresar, aunque tengan el mismo nombre ya que est\u00e1n en \u00e1mbitos diferentes, no pueden verse entre ellas.</p>"},{"location":"ud3/4referencevalue/","title":"\ud83c\udf0e Paso de argumentos por valor y referencia","text":""},{"location":"ud3/4referencevalue/#argumentos-paso-por-valor","title":"Argumentos paso por valor","text":"<p>Un par\u00e1metro es un \"mensaje unidireccional\" que la persona que llama usa para enviar valores a un m\u00e9todo.</p> <p>Dentro del cuerpo de un m\u00e9todo, un par\u00e1metro se usa como cualquier variable. Se puede utilizar en expresiones aritm\u00e9ticas, en sentencias de asignaci\u00f3n, etc.</p> <p>Sin embargo, los cambios realizados en el par\u00e1metro no tienen ning\u00fan efecto fuera del cuerpo del m\u00e9todo. Un par\u00e1metro es una copia local de cualquier valor que la persona que llama haya pasado al m\u00e9todo. Cualquier cambio realizado afectar\u00e1 solo a esta copia local.</p> <p>Esto ocurre cuando se pasa una dato de tipo primitivo.</p> <p>Por ejemplo:</p> <pre><code>------Clase Cuenta\n    public void cambiarCantidad(double cantidad) {\n        cantidad -= 20;\n    }\n------------------Clase Main\n    public static void main() {\n        Cuenta cuenta = new Cuenta(\"Pepe\", \"pepe@gmail.com\", \"873463774\");\n        int cantidad = 50;\n\n        cuenta.ingresar(cantidad);\n        System.out.println(cantidad);//imprime 50\n        cuenta.cambiarCantidad(cantidad);\n        System.out.println(cantidad);//imprime 50\n    }\n</code></pre> <p>cantidad es el nombre de la variable para el valor 50 que se ha enviado al m\u00e9todo cambiarCantidad(). Ese m\u00e9todo cambia el valor de la cantidad, pero esto no tiene ning\u00fan efecto sobre ninguna otra variable fuera del m\u00e9todo.</p> <p>Cuando el m\u00e9todo regresa a su llamador (main), el valor del par\u00e1metro cantidad se olvida.</p> <p></p> <p>Una variable local es una variable que se declara dentro del cuerpo de un m\u00e9todo.</p> <p>El alcance de una variable local comienza desde donde se declara y termina al final del bloque en el que se encuentra. Recuerde que un bloque es un grupo de declaraciones entre llaves, {}.</p> <p>As\u00ed es como funciona el paso de par\u00e1metros por valor:</p> <ol> <li>Cuando la persona invoca un m\u00e9todo, es persona proporciona una lista de valores (los par\u00e1metros) en la lista de par\u00e1metros del m\u00e9todo.</li> <li>Cuando el m\u00e9todo invocado comienza a ejecutarse, estos valores se copian en los par\u00e1metros formales o argumentos.</li> <li>El m\u00e9todo invocado utiliza los par\u00e1metros formales para acceder a estos valores copiados.</li> <li>Cualquier cambio que realice el m\u00e9todo en el valor contenido en un par\u00e1metro formal cambia solo esa copia.</li> <li>El m\u00e9todo invocado no puede utilizar un par\u00e1metro formal para enviar un valor a la persona que ha invocado el m\u00e9todo.</li> </ol> <p>Como hemos visto un cambio en un par\u00e1metro dentro del m\u00e9todo no afecta a ninguna variable desde donde se invoc\u00f3. Entonces, \u00bfc\u00f3mo puede un m\u00e9todo enviar un valor a la persona que lo invoca?</p> <p>Para devolver un valor \u00fanico a la persona que invoca, un m\u00e9todo invocado puede utilizar la declaraci\u00f3n de retorno return junto con el valor que se devolver\u00e1.</p>"},{"location":"ud3/4referencevalue/#paso-por-referencia","title":"Paso por referencia","text":"<p>Las referencias a objetos o variable de referencia pueden ser par\u00e1metros. Esto sigue siendo una llamada por valor, pero ahora el valor es una referencia de objeto. Esta referencia se puede utilizar para acceder al objeto y posiblemente cambiarlo.</p> <p><pre><code>public class Test {\n\n    public static void ingresarCienEuros(Cuenta cuenta) {\n        System.out.println(\"El balance es \" + cuenta.getBalance());\n        cuenta.ingresar(100);\n        System.out.println(\"El balance es \" + cuenta.getBalance());\n    }\n\n    public static void main(String[] args) {\n        Cuenta c = new Cuenta();\n        //suponemos que el balance inicial es 0\n        System.out.println(\"El balance es \" + cuenta.getBalance());//imprime 0\n        ingresarCienEuros(c);\n        System.out.println(\"El balance es \" + cuenta.getBalance());//imprime 100\n    }\n}\n</code></pre> </p> <p>Las variables de instancia p\u00fablica de los objetos se pueden cambiar mediante cualquier m\u00e9todo que tenga una referencia al objeto. Como se ha hecho en el ejemplo anterior en la variable de instancia balance.</p> <p>Si cambiamos el c\u00f3digo anterior por el siguiente, en el que el m\u00e9todo ingresaCienEuros crea un nuevo objeto, estamos cambiando la referencia al par\u00e1metro, por lo que el objeto original no se cambia</p> <p><pre><code>public class Test {\n\n    public static void ingresarCienEuros(Cuenta cuenta) {\n        System.out.println(\"El balance es \" + cuenta.getBalance());//imprime 0\n        cuenta=new Cuenta();\n        cuenta.ingresar(100);\n        System.out.println(\"El balance es \" + cuenta.getBalance());//imprime 100\n    }\n\n    public static void main(String[] args) {\n        Cuenta c = new Cuenta();\n        //suponemos que el balance inicial es 0\n        System.out.println(\"El balance es \" + cuenta.getBalance());//imprime 0\n        ingresarCienEuros(c);\n        System.out.println(\"El balance es \" + cuenta.getBalance());//imprime 0\n    }\n}\n</code></pre> </p>"},{"location":"ud3/4referencevalue/#resumen","title":"Resumen","text":"<p>Un par\u00e1metro formal es una variable en una declaraci\u00f3n de m\u00e9todo. Siempre consta de un tipo seguido de un identificador de variable. Un argumento es un valor que se pasa a un m\u00e9todo a trav\u00e9s de un par\u00e1metro formal cuando se invoca el m\u00e9todo. Los par\u00e1metros de un m\u00e9todo limitan el tipo de informaci\u00f3n que se puede pasar a un m\u00e9todo.</p> <ol> <li> <p>El paso de par\u00e1metros siempre se realiza por valor.</p> </li> <li> <p>Si el par\u00e1metro de un m\u00e9todo es un tipo de datos primitivo, el m\u00e9todo puede cambiar el valor contenido en su par\u00e1metro, pero ese cambio no tiene ning\u00fan efecto en otros lugares.</p> </li> <li> <p>Sin embargo, si el par\u00e1metro de un m\u00e9todo es una referencia a un objeto, el m\u00e9todo puede usar la referencia para acceder al objeto y luego cambiar las variables de instancia del objeto (a menos que sean privadas o en un paquete diferente).</p> </li> <li> <p>Por supuesto, incluso si un m\u00e9todo tiene una referencia a un objeto, el objeto se puede cambiar solo si el objeto permite que se realicen cambios.</p> </li> </ol>"},{"location":"ud3/5static/","title":"\ud83c\udf0e Variables, m\u00e9todos y clases est\u00e1ticas","text":"<p>Una clase, m\u00e9todo o campo declarado como est\u00e1tico puede ser accedido o invocado sin la necesidad de tener que instanciar un objeto de la clase.</p> <p>Para entender mejor que son las variables y m\u00e9todos est\u00e1ticos vamos a ver las diferencias de cada uno de ellos con variables y m\u00e9todos de instancia.</p>"},{"location":"ud3/5static/#variables-estaticas","title":"Variables est\u00e1ticas","text":"<p>Si una variable se declara est\u00e1tica, hay exactamente una copia de esa variable creada sin importar cu\u00e1ntas veces se instancia su clase.</p> <ul> <li>Se declaran usando la palabra reservada static.</li> <li>Cada instancia de la clase comparte la misma variable est\u00e1tica, por lo que si se realizan cambios en esa variable est\u00e1tica todas las dem\u00e1s instancias de esa clase ver\u00e1 el efecto de ese cambio.</li> </ul> <pre><code> class Alumno {\n        //n\u00famero total de alumnos creados\n        private static int totalAlumnos=0;\n\n        private String nombre;\n        public static int getTotalAlumnos(){\n            return totalAlumnos;\n        }\n        public Alumno(String name) {\n            this.nombre = name;\n            //cada vez que creamos un alumno lo sumamos\n            totalAlumnos++;\n        }\n    }\n\n    public class Main {\n        public static void main(String[] args) {\n            Alumno pepe = new Alumno(\"Pepe\");\n            Alumno maria = new Alumno(\"Maria\");\n            //devuelve 2\n            System.out.println(\"Total Alumnos: \"+Alumno.getTotalAlumnos());\n        }\n    }\n</code></pre>"},{"location":"ud3/5static/#variables-constantes-estaticas","title":"Variables constantes est\u00e1ticas","text":"<p>Tambi\u00e9n se puede declarar un variable constante (final) como est\u00e1tica, esto significa que solo habr\u00e1 una copia de la constante aunque hayan muchas instancias de esa clase. Son tambi\u00e9n llamadas constantes de clase:</p> <pre><code>private static final int NUMERO_JUGADORES = 2;\n</code></pre> <p>No todas las constantes son constantes de clase. Es decir, no todas las constantes se declaran est\u00e1ticas. Sin embargo, la idea de asociar constantes con una clase tiene sentido. Ya que te permite ahorrar recursos de memoria, al crear una \u00fanica copia de la constante.</p> <p>Otra ventaja de las constantes de clase es que se pueden usar antes de que existan instancias de la clase. Por ejemplo, una constante de clase (a diferencia de una constante de instancia) se puede usar durante la instanciaci\u00f3n de objetos:</p> <p><pre><code>public class Game {\n\n    public static final int MULTIPLAYER = 2;\n    public static final int ONE_PLAYER = 1;\n\n    private int numeroJugadores;\n\n    public Game(int jugadores) {\n        this.numeroJugadores = jugadores;\n    }\n\n    public static void main(String[] args) {\n        Game game = new Game(Game.MULTIPLAYER);\n    }\n}\n</code></pre> Otros ejemplos son valores num\u00e9ricos y textos que mantenemos fijos en el programa o que tienes pocos cambios en diferentes versiones del programa.</p> <pre><code>public class EjemploStatic {\n        public static double PI = 3.1416;\n        public static double IVA = 21.0;\n        public static double SUELDO_MINIMO = 1000.0;\n        public static String NOMBRE_EMPRESA = \"Acme S.A.\";\n    }\n</code></pre>"},{"location":"ud3/5static/#variables-de-instancia","title":"Variables de instancia","text":"<ul> <li>Las variables de instancia tambi\u00e9n son conocidas como campos o atributos.</li> <li>Las variables de instancia pertenecen a una instancia de la clase.</li> <li>Cada instancia tiene su propia copia de una variable de instancia, as\u00ed que cada instancia puede tener un valor(estado) diferente.</li> <li>Las variables de instancia representan el estado de una instancia.</li> </ul> <pre><code>class Persona {\n    private String name;\n\n    public Persona(String name) {\n        this.name = name;\n    }\n\n    public void printName() {\n        System.out.println(name);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Persona p1 = new Persona(\"Patricia\");\n        Persona p2 = new Persona(\"Maxi\");\n        p1.printName();//imprime Patricia\n        p2.printName();//imprime Maxi\n    }\n}\n</code></pre>"},{"location":"ud3/5static/#metodos-estaticos","title":"M\u00e9todos est\u00e1ticos","text":"<ul> <li>Los m\u00e9todos est\u00e1ticos son declarados usando el modificador static.</li> <li>No se puede acceder desde los m\u00e9todos est\u00e1ticos a m\u00e9todos de instancia o variables de instancia directamente.</li> <li>Para invocar a un m\u00e9todo est\u00e1tico se utiliza el nombre de la clase + \".\" + el nombre del m\u00e9todo, o solamente el nombre del m\u00e9todo si est\u00e1 en la misma clase.(VEASE EJEMPLO)</li> <li>Normalmente se usan para operaciones que no requieren ning\u00fan dato de instancia de la clase, es decir, nada que venga de this.</li> <li>Dentro de un m\u00e9todo est\u00e1tico no podemos usar la palabra this.</li> <li>Cada vez que veas un m\u00e9todo que no utilice variables de instancia, significa que ese m\u00e9todo deber\u00eda declararse como est\u00e1tico.</li> <li>Por ejemplo, el main es declarado como est\u00e1tico y es llamado por la JVM cuando se lanza la aplicaci\u00f3n.</li> </ul> <pre><code>public class Calculadora {\n    public static void printSuma(int a, int b) {\n        System.out.println(a+b);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Calculadora.printSuma(5, 6);\n        printHolaMundo();\n    }\n\n    public static void printHolaMundo() {\n        System.out.println(\"Hola mundo.\");\n    }\n}\n</code></pre>"},{"location":"ud3/5static/#metodos-de-instancia","title":"M\u00e9todos de instancia","text":"<ul> <li>Los m\u00e9todos de instancia pertenecen a una instancia espec\u00edfica de la clase.</li> <li>Para usar un m\u00e9todo de instancia tenemos que instanciar un objeto de la clase primero, normalmente utilizando la palabra resevada new.</li> <li>Los m\u00e9todos de instancia pueden acceder a otros m\u00e9todos de instancia y variables de instancia directamente.</li> <li>Los m\u00e9todos de instancia pueden tambi\u00e9n acceder a m\u00e9todos est\u00e1ticos y variables est\u00e1ticas.</li> </ul>"},{"location":"ud3/5static/#metodo-estatico-o-metodo-de-instancia","title":"\u00bfM\u00e9todo est\u00e1tico o m\u00e9todo de instancia?","text":"<p>Cuando voy a crear un m\u00e9todo y tengo dudas sobre si crearlo est\u00e1tico o de instancia debo seguir la siguiente l\u00f3gica:</p> <p>\u00bfEl m\u00e9todo usa alg\u00fan campo o variable de instancia o invoca en su interior a alg\u00fan m\u00e9todo de instancia?</p> <ul> <li>SI \u2192 Entonces deber\u00eda crear un m\u00e9todo de instancia.</li> <li>NO \u2192 Deber\u00eda crear un m\u00e9todo est\u00e1tico.</li> </ul>"},{"location":"ud3/5static/#clases-estaticas","title":"Clases est\u00e1ticas","text":"<p>En el lenguaje Java, no podemos crear una clase externa como una clase est\u00e1tica, pero existe el privilegio de crear una clase interna anidada como una clase est\u00e1tica.</p> <ul> <li>Una clase interna est\u00e1tica nunca puede acceder a un miembro no est\u00e1tico de la clase externa.</li> <li>Una clase interna est\u00e1tica no necesita ninguna referencia de clase externa para acceder a las variables miembro.</li> <li>La clase est\u00e1tica nunca se puede instanciar. Por lo tanto, los m\u00e9todos son directamente accesibles por el nombre de la clase.</li> </ul> <pre><code>public class Estatica {\n    static int i = 1;\n    int j = 9;\n\n    public static void main(String[] args) {\n        Estatica s = new Estatica();\n        //s.ClaseInterna.printNum(); NO ES CORRECTO\n        //Estatica.ClaseInterna.printNum(); SI se podr\u00eda hacer\n        ClaseInterna.printNum();\n    }\n\n    public static class ClaseInterna {\n        public static void printNum() {\n            System.out.println(i);\n            //System.out.println(j); //NO PODEMOS ACCEDER A ATRIBUTOS NO EST\u00c1TICOS\n        }\n    }\n}\n</code></pre>"},{"location":"ud3/5static/#bloques-estaticos","title":"Bloques est\u00e1ticos","text":"<p>Es posible declarar bloques de c\u00f3digo como est\u00e1ticos, de tal manera que sean ejecutados cuando se cargue la clase. Este tipo de bloques se conocen como bloques de inicializaci\u00f3n est\u00e1ticos (static initializer block). Si no se declara un bloque de este tipo de forma expl\u00edcita, el compilador Just-in-Time combina todos los campos est\u00e1ticos en un bloque y los ejecuta durante la carga de clases.</p> <pre><code>public class Objeto {\n\n    private static int campo1;\n\n    static {\n        campo1 = 10;\n    }\n}\n</code></pre>"},{"location":"ud3/5static/#imports-estaticos","title":"Imports est\u00e1ticos","text":"<p>Una de las caracter\u00edsticas incluidas en Java 5 fu\u00e9 la capacidad de importar los m\u00e9todos y variables est\u00e1ticas de un m\u00f3dulo y acceder a ellos como si hubieran sido declarados en la propia clase. Es especialmente \u00fatil, y mejora la legibilidad, cuando se est\u00e1n definiendo test unitarios, ya que la mayor\u00eda de los m\u00e9todos de aserci\u00f3n de JUnit son est\u00e1ticos.</p> <pre><code>import static java.lang.Math.PI;\n\npublic static void main(String[] args) {\n    double a = PI;\n}\n</code></pre>"},{"location":"ud3/6recursion/","title":"\u267e\ufe0f Recursividad","text":"<p>Un m\u00e9todo recursivo es un m\u00e9todo que se llama a s\u00ed mismo.</p> <p>Un m\u00e9todo iterativo es un m\u00e9todo que resuelve el problema sin llamarse a s\u00ed mismo. </p> <p>Los m\u00e9todos recursivos son \u00fatiles para resolver problemas que pueden descomponerse en subproblemas m\u00e1s peque\u00f1os y similares al problema original.</p> <p>Su esctructura b\u00e1sica es</p> <pre><code>static int funcionRecursiva(){\n    //...\n    funcionRecursiva();\n    //....\n}\n</code></pre>"},{"location":"ud3/6recursion/#definicion-de-la-funcion-recursiva","title":"Definici\u00f3n de la funci\u00f3n recursiva","text":"<p>Caso base: Una funci\u00f3n recursiva tiene que tener una condici\u00f3n  que permita no tener que llamarse a s\u00ed misma en alg\u00fan caso, ya que puede producirse desbordamiento de pila(<code>Stack Overflow</code>) al no terminar nunca la funci\u00f3n. Este es el caso base.</p> <p>Reducci\u00f3n del problema: En cada llamada a la funci\u00f3n, el problema debe ser de menor tama\u00f1o.</p>"},{"location":"ud3/6recursion/#ejemplo-recursividad-factorial-n","title":"Ejemplo recursividad: Factorial: N!","text":"<p>Recordamos como se hac\u00eda el c\u00e1lculo de n!:</p> <p>n! = n * (n-1) * (n-2) * .... mientras n &gt; 0</p> <p>Adem\u00e1s, 0! se define como 1.</p> <p>Ejemplos:</p> <ul> <li>4! = 4 * 3 * 2 * 1 = 24</li> <li>3! = 3 * 2 * 1 = 6</li> <li>1! = 1</li> <li>0! = 1</li> </ul> <p>Como vemos en el ejemplo, podemos deducir que el factorial se repite en t\u00e9rminos de (n-1) y el \u00fanico caso donde no se calcula el factorial es 0!, esto nos lleva a que:</p> <p>0! = 1             \u2192 if n = 0 //caso base</p> <p>n! = n * (n-1)     \u2192 if n &gt; 0 //reducci\u00f3n del problema</p> <p>De forma que el factorial de un n\u00famero quedar\u00eda codificado de la siguiente forma:</p> <pre><code>    public static int factorial(int n) {\n        if (n == 0) {//caso base\n            return 1;\n        } else {//llamada recursiva que reduce el problema\n            return n * factorial(n-1);\n        }\n    }\n</code></pre>"},{"location":"ud3/6recursion/#traza","title":"Traza","text":"<p><pre><code>factorial(4)\n    4 * factorial(3)\n        3 * factorial(2)\n            2 * factorial(1)\n                1 * factorial(0)\n                    return 1\n                return 1 * 1 --&gt; 1   \n            return 2 * 1 --&gt; 2\n        return 3 * 2 --&gt; 6 \n    return 4 * 6 --&gt; 24\nreturn 24\n</code></pre> </p>"},{"location":"ud3/6recursion/#ejemplo-2-sumar-los-elementos-de-un-array","title":"EJEMPLO 2: Sumar los elementos de un array","text":"<p>Podemos tener una versi\u00f3n recursiva de la suma de los elementos de una array.</p> <p>caso base</p> <p>tama\u00f1oArray=0  ---&gt; return 0;</p> <p>reducci\u00f3n del problema</p> <p>return array[tama\u00f1o-1]+ suma(array, tama\u00f1o-1)</p> <pre><code>public static int calcularSuma(int[] array, int n) {\n    // Caso base: cuando el tama\u00f1o del array es 0, la suma es 0\n    if (n == 0) {\n        return 0;\n    } else {\n        // Llamada recursiva: sumar el \u00faltimo elemento con la suma de los elementos restantes\n        return array[n - 1] + calcularSuma(array, n - 1);\n    }\n}\n</code></pre> <p>Importante</p> <p>Algunos puntos importantes a tener en cuenta sobre los m\u00e9todos recursivos en Java:</p> <ul> <li> <p>Caso base: Debes asegurarte de tener un caso base en tu m\u00e9todo recursivo. Este caso base define la condici\u00f3n en la que la recursi\u00f3n se detiene y la funci\u00f3n comienza a devolver resultados.</p> </li> <li> <p>Problemas de desbordamiento de pila (Stack Overflow): Si no se controla adecuadamente, la recursi\u00f3n puede provocar un desbordamiento de la pila de llamadas (Stack Overflow). Esto ocurre cuando hay demasiadas llamadas recursivas anidadas. Es importante tener cuidado con esto y asegurarse de que haya un camino claro hacia el caso base.</p> </li> <li> <p>Eficiencia: Aunque los m\u00e9todos recursivos pueden ser elegantes y concisos, a veces pueden ser menos eficientes que las soluciones iterativas. Esto se debe a que cada llamada recursiva implica un overhead adicional en t\u00e9rminos de memoria y tiempo de ejecuci\u00f3n.</p> </li> <li> <p>Claridad y legibilidad del c\u00f3digo: A veces, un enfoque recursivo puede hacer que el c\u00f3digo sea m\u00e1s f\u00e1cil de entender, especialmente cuando el problema es intr\u00ednsecamente recursivo en su naturaleza. Numerosos problemas son dif\u00edciles de resolver con soluciones iterativas, y solo la soluci\u00f3n recursiva conduce a la resoluci\u00f3n del problema (por ejemplo, Torres de Hanoi o recorrido de \u00c1rboles)</p> </li> </ul>"},{"location":"ud3/7nullvalue/","title":"\ud83c\udf0e Valor nulo","text":"<p>Una variable de referencia contiene informaci\u00f3n sobre la ubicaci\u00f3n de un objeto. No contiene el objeto en s\u00ed.</p> <p>Por ejemplo el siguiente c\u00f3digo:</p> <pre><code> String str;\n Persona p;\n</code></pre> <p>declara dos variables de referencia pero no construye ning\u00fan objeto. Con el siguiente c\u00f3digo:</p> <pre><code> str = \"Programaci\u00f3n\";\n p = new Persona(\"Patricia\");\n</code></pre> <p>se construyen los objetos y se colocan referencias en las variables.</p> <p>null es un valor especial que significa \"sin objeto\". Se establece una variable de referencia a null cuando no se refiere a ning\u00fan objeto. Las variables a menudo se asignan en nulas cuando se declaran:</p> <pre><code> String str = null;\n Persona p = null;\n</code></pre> <p>str y p todav\u00eda no son objetos, son variables que en un futuro pueden referenciar a objetos.</p> <p>Podemos asignar el valor null a cualquier variable de tipo referencia, ya sea un objeto, string, array, etc.</p> <p>Una variable de referencia a veces hace referencia a un objeto y otras veces no, y puede referirse a diferentes objetos en diferentes momentos. Por tanto, necesitamos una forma de decir que una variable ahora no se refiere a un objeto. Para ello, se le asigna un valor null a la variable.</p> <p></p> <p>El objeto Persona con el nombre de Patricia se destruir\u00e1 eventualmente por el garbage collector ya que no es referenciado por nadie.</p>"},{"location":"ud4/1arrays/","title":"Arrays de datos primitivos","text":"<p>Los arrays es una estructura de datos que te permite almacenar una secuencia de valores todos del mismo tipo.</p> <p>Un array est\u00e1 hecho de bloques contiguos de memoria que se divide en varias celdas. Cada celda tiene un valor y todos los valores son del mismo tipo. A veces, las celdas de un array se denominan slots. En el array de la imagen cada celda contiene un int.</p> <p>En el ejemplo de la imagen hemos creado un array de enteros. Tambi\u00e9n se podr\u00eda crear un array de caracteres, de String, etc. Esto se podr\u00eda hacer tanto para tipos de datos primitivos como para objetos.</p> <ul> <li>Las celdas est\u00e1n numeradas secuencialmente empezando por cero.</li> <li>Si hay N celdas en un array, entonces los \u00edndices van del 0 hasta N-1.</li> <li>La longitud de un array es el n\u00famero de celdas.</li> </ul> <p>Al valor almacenado en la celda de un array se le suele llamar elemento.</p> <p>Es muy importante tener en cuenta que los arrays empiezan siempre en la posici\u00f3n cero. Por tanto, si se desea acceder al primer elemento del array, estar\u00e1 almacenado en la posici\u00f3n 0.</p>"},{"location":"ud4/1arrays/#declaracion-y-reseva-de-memoria","title":"Declaraci\u00f3n y reseva de memoria","text":"<p>Para declarar un array, se hace de la misma forma que har\u00edamos si quisi\u00e9ramos declarar una variable pero a\u00f1adiendo [ ]:</p> <pre><code>    int miVariable; //declaramos una variable normal\n    int[] miArray; //declaramos una variable array\n    int miArray2[];//es equivalente al anterior\n</code></pre> <p>Si usamos la declaraci\u00f3n tipo[] arrayName crea una referencia a una variable de tipo de array, pero no construye el objeto.</p> <p>Los arrays en Java se crean como objetos, y como cualquier otro objeto en Java, para construirlo utilizamos la palabra reservada new. Para inicializar un array usaremos la palabra new + tipo de dato + tama\u00f1o del array entre corchetes[]:</p> <pre><code>    int[] miArray = new int[10]; //creamos y reservamos memoria para el array con 10 elementos\n    // y valores 0 en cada posici\u00f3n\n\n    double[] dArray = new double[5];\n    long lArray[];\n    lArray = new long[10];\n</code></pre> <p>Una vez ha sido construido no es posible cambiar su tama\u00f1o. La variable miArray va a ser un array con espacio para 10 elementos de tipo entero. Inicialmente con valores a 0</p> <p></p>"},{"location":"ud4/1arrays/#acceso-a-los-elementos-del-array","title":"Acceso a los elementos del array","text":"<p>Para guardar un valor dentro de una celda del array tenemos que acceder a su posici\u00f3n dentro del array.</p> <p><pre><code>    int[] notas = new int[10];\n    notas[2] = 5; //guardamos en la posici\u00f3n 2 del array el valor 5\n</code></pre> </p> <p>Warning</p> <p>Recuerda que los elementos del array empiezan con \u00edndice 0, por tanto, en realidad la posici\u00f3n 2 ser\u00eda la 3.</p> <p>Para acceder a un valor de una determinada posici\u00f3n del array y mostrarlo lo har\u00edamos de la siguiente forma:</p> <pre><code>int notaBasesDatos = notas[2]; //almacenamos el valor 5 en la variable entera elemento\nSystem.out.println(notaBasesDatos);\n// o tambi\u00e9n podemos hacer directamente\nSystem.out.println(notas[2]);\n</code></pre>"},{"location":"ud4/1arrays/#inicializacion-del-array","title":"Inicializaci\u00f3n del array","text":"<p>Hay varias formas de inicializar un array. Por ejemplo, si quisi\u00e9ramos darle valor a todas las posiciones del array podr\u00edamos hacerlo de la forma:</p> <pre><code>    notas[0] = 2;\n    notas[1] = 3;\n    notas[2] = 5;\n    ....\n    notas[10] = 9;\n</code></pre> <p>Lo cual es una forma muy pesada y tediosa. Java nos ofrece otras formas de inicializar los arrays en una sola l\u00ednea de c\u00f3digo que solo es aplicable a la vez que definimos la variable:</p> <pre><code>    int[] notas = {2,3,5,7,10,4,6,8,1,4};//correcto\n    //no puedo inicializar el array despu\u00e9s de haberlo creado\n    //esto da ERROR\n    notas = {2,3,5,7,10,4,6,8,1,4};\n</code></pre> <p>De esa forma, tambi\u00e9n le indicamos indirectamente el tama\u00f1o del array. Java cuenta el n\u00famero de elementos que hay entre {} y crea un array de ese tama\u00f1o y adem\u00e1s los asigna en posiciones consecutivas dentro del array.</p> <p></p> <p>Los \u00edndices en un array son enteros que especifican la posici\u00f3n que ocupa el elemento dentro del array. Por tanto podemos manejar los \u00edndices con variables enteras.</p> <p>Una tercera forma ser\u00eda utilizando la estructura de bucle for, para esto, debemos saber con antelaci\u00f3n el valor de los elementos del array:</p> <pre><code>    int[] multiplosDe10 = new int[10];\n\n    for(int i = 0; i &lt; 10; i++) {\n        multiplosDe10[i] = i * 10;\n    }\n</code></pre> <p>Lo que hacemos es inicializar cada posici\u00f3n del array utilizando el bucle. Estamos almacenando dentro del array el valor del \u00edndice multiplicado por 10, de forma que tendremos, {0, 10, 20, ...., 90}.</p> <p></p> <p>La estructura for tambi\u00e9n es de gran ayuda si queremos imprimir los valores que est\u00e1n guardados en cada posici\u00f3n del array:</p> <p><pre><code>    for(int i = 0; i &lt; 10; i++) {\n        System.out.println(\"Elemento \" + i + \" valor \" + miArray[i]);\n    }\n</code></pre> Otro ejemplo</p> <pre><code>    Scanner sc = new Scanner(System.in);\n    for(int i = 0; i &lt; 10; i++) {\n        System.out.println(\"Introduzca la nota  \" + i + \": \");\n        notas[i]=sc.nextInt();\n    }\n</code></pre> <p>A falta de cualquier otra informaci\u00f3n, las celdas de un array se inicializan con el valor predeterminado para su tipo. Cada celda de un array de tipo num\u00e9rico se inicializa a cero.</p> <p></p> <p>Y cada celda de un array de referencias a objetos se inicializa en nulo (null).</p> <p></p>"},{"location":"ud4/1arrays/#longitud-del-array","title":"Longitud del array","text":"<p>Una buena pr\u00e1ctica, es utilizar una propiedad integrada dentro de array, en vez de hardcodear literales de tama\u00f1o dentro del bucle. Esta propiedad es length:</p> <pre><code>    Scanner sc = new Scanner(System.in);\n    for(int i = 0; i &lt; notas.length; i++) {\n        System.out.println(\"Introduzca la nota  \" + i + \": \");\n        notas[i]=sc.nextInt();\n    }\n</code></pre> <p>Si ahora cambiamos la longitud del array en su definici\u00f3n, no se ver\u00eda afectado ning\u00fan bucle o lugar donde se utilizara notas.length</p>"},{"location":"ud4/1arrays/#pasar-un-array-como-argumento-en-un-metodo","title":"Pasar un array como argumento en un m\u00e9todo","text":"<p>Al igual que hac\u00edamos con las variables simples, tambi\u00e9n podemos pasar arrays a los m\u00e9todos.</p> <pre><code>public static void imprimirArray(int[] array) {\n    for(int i = 0; i &lt; array.length; i++) {\n        System.out.println(\"Elemento \" + i + \" valor \" + array[i]);\n    }\n}\n\npublic static void main() {\n    int[] miArray = {1, 3, 5, 6, 8};\n    imprimirArray(miArray);\n}\n</code></pre> <p>Warning</p> <p>Recuerda que un array es un objeto y se env\u00eda una referencia a la instancia en la llamada al m\u00e9todo, por lo que los cambios sufridos en el array dentro del m\u00e9todo, se ver\u00e1n reflejados al salir del m\u00e9todo </p>"},{"location":"ud4/1arrays/#devolver-un-array-en-un-metodo","title":"Devolver un array en un m\u00e9todo","text":"<p>Para devolver un objeto de tipo array en un m\u00e9todo simplemente a\u00f1adiremos []:</p> <pre><code>public static int[] calcular() {\n    int[] miArray = new int[10];\n    //....realizo calculos con el array\n    return miArray;\n}\n\npublic static void main() {\n    //me devuelve el array creado en el m\u00e9todo\n    int[] resultados = calcular();\n    //...  \n}\n</code></pre>"},{"location":"ud4/1arrays/#caso-practico-real-uso-de-un-array","title":"Caso pr\u00e1ctico real uso de un array","text":"<p>Vamos a presentar un ejemplo de un caso real para el que los arrays son muy efectivos. Por ejemplo pedir al usuario que inserte n\u00fameros y mostrar la media de los n\u00fameros insertados.</p> <pre><code>/**\n * La clase Notas, lee las notas de n alumnos y devuelve la media\n */\npublic class Notas {\n    private static Scanner sc = new Scanner(System.in);\n\n    public static void main(String[] args) {\n        int totalAlumnos;\n        System.out.println(\"Introduzca en n\u00famero de alumnos\");\n        //tama\u00f1o de array\n        totalAlumnos=sc.nextInt();\n        //El m\u00e9todo nos devuelve un array con las notas de los alumnos\n        int[] notas1DAM_FOL = leerNotas(totalAlumnos);\n\n        //imprimimos los valores\n        for (int i = 0; i &lt; notas1DAM_FOL.length; i++) {\n            System.out.println(\"La nota del alumno \" + i + \": \" + notas1DAM_FOL[i]);\n        }\n        System.out.println(\"La media de los alumnos de FOL es: \" + calcularMedia(notas1DAM_FOL));\n    }\n\n    /**\n     * Recibe el total de alumnos y deuuelve un array con las notas de los\n     * alumnos\n     * @param totalAlumnos: total de los alumnos\n     * @return array de tama\u00f1o totalAlumnos con las notas de los alumnos\n     */\n    public static int[] leerNotas(int totalAlumnos) {\n        //creamos el array\n        int[] notas = new int[totalAlumnos];\n        //leemos las valores\n        for (int i = 0; i &lt; notas.length; i++) {\n            System.out.println(\"Introduzca la Nota del alumno  \" + i + \": \");\n            notas[i] = sc.nextInt();\n        }\n        return notas;\n    }\n\n    /**\n     * Recibe un array de entereos y calcula su media y la devuelve\n     * @param notas: array de enteros con la notas\n     * @return: media de las notas de los alumnos\n     */\n    public static double calcularMedia(int[] notas) {\n        int suma = 0;\n        for (int i = 0; i &lt; notas.length; i++) {\n            suma += notas[i];\n        }\n        return (double) suma / (double) notas.length;\n    }\n}\n</code></pre>"},{"location":"ud4/2usefularrays/","title":"Algoritmos de arrays \u00fatiles","text":"<p>Un array que utiliza un solo \u00edndice para acceder a sus valores se denomina array unidimensional, ya que utilizamos el \u00edndice para acceder a todas las celdas del array. \u00c9stas celdas est\u00e1n alineadas de forma secuencial.</p> <p>Un array bidimensional necesita dos \u00edndices para acceder a los valores. En este caso las celdas est\u00e1n dispuestas en forma de matriz, como una estructura rectangular.</p> <p>Es posible crear arrays de mayores dimensiones aunque rara vez se utilizan.</p>"},{"location":"ud4/2usefularrays/#contar-los-elementos-que-contiene-un-array","title":"Contar los elementos que contiene un array","text":"<p>Cuando utilizamos arrays, es muy molesto contar los elementos de un array para saber su tama\u00f1o. Afortunadamente, todo objeto de tipo array tiene una variable de instancia llamada length que contiene el tama\u00f1o del array, es decir, el n\u00famero de celdas.</p>"},{"location":"ud4/2usefularrays/#imprimir-los-elementos-de-un-array","title":"Imprimir los elementos de un array","text":"<p>Un algoritmo muy utilizado cuando trabajamos con arrays es mostrar los valores que contiene el array en cada una de sus celdas. Para ello nos ayudamos del campo length que nos devuelve la longitud del array.</p> <pre><code>public static void imprimirArray(int[] array) {\n    for(int i = 0; i &lt; array.length; i++) {\n        System.out.println(\"Elemento \" + i + \" valor \" + array[i]);\n    }\n}\n</code></pre>"},{"location":"ud4/2usefularrays/#leer-y-rellenar-los-elementos-de-un-array-por-teclado","title":"Leer y rellenar los elementos de un array por teclado","text":"<p>Es muy com\u00fan que los elementos de un array sean valores introducidos de alguna forma por el usuario. El ejemplo m\u00e1s sencillo es leerlos directamente desde la entrada de flujo, a la vez que leemos el valor insertado por el usuario se lo asignamos al array.</p> <pre><code>    int[] array = new int[elementos];\n\n    for (int i = 0; i &lt; array.length; i++) {\n        array[i] = sc.nextInt();\n    }\n</code></pre>"},{"location":"ud4/2usefularrays/#clasico-error-1-no-testear-los-limites-del-array","title":"Cl\u00e1sico error 1: no testear los l\u00edmites del array","text":"<p>Cuando trabajamos con arrays, a menudo nos puede ocurrir que olvidamos el \u00faltimo elemento del array, si cambiamos la condici\u00f3n del bucle por i &lt; array.length -1, o olvidamos el primer elemento si establecemos el \u00edndice en  int i = 1 porque creemos que el primer elemento est\u00e1 en la posici\u00f3n 1 del array.</p> <p>Estos son errores cl\u00e1sicos: no probar los l\u00edmites de los arrays, es decir, el primer elemento o el \u00faltimo.</p> <p>Por ejemplo, en el siguiente c\u00f3digo no quiero tener n\u00fameros de una cifra en mi array.</p> <pre><code>    int[] datos =  {2, 19, 1, 5, 1, 27, 9, 5};\n\n    for (int i = 0; i &lt; datos.length-1; i++) {\n        if (datos[i] &lt; 10)\n            datos[i] = datos[i] * 10;\n    }\n</code></pre> <p>Cuando recorro el array, el \u00faltimo elemento no ser\u00eda testeado por tanto me devolver\u00eda un 5 en vez de 50. El programa ser\u00eda incorrecto.</p> <p></p>"},{"location":"ud4/2usefularrays/#clasico-error-2-exceder-los-limites-del-array","title":"Cl\u00e1sico error 2: exceder los l\u00edmites del array","text":"<p>Al contrario que, en el apartado anterior, si intentamos acceder a una celda del array que no existe, se lanzar\u00e1 una ArrayIndexOutOfBoundsException y el programa se detendr\u00e1.</p> <p>Los errores de acceso a la \u00faltima posici\u00f3n del array + 1 son muy comunes. Un ejemplo ser\u00eda:</p> <p><pre><code>    int[] datos =  {2, 19, 1, 5, 1, 27, 9, 5};\n\n    for (int i = 0; i &lt;= datos.length; i++) {\n        if (datos[i] &lt; 10)\n            datos[i] = datos[i] * 10;\n    }\n</code></pre> </p>"},{"location":"ud4/2usefularrays/#bucle-foreach-enhanced-for-loop","title":"Bucle foreach (enhanced for loop)","text":"<p>Para evitar que los errores mencionados anteriormente ocurran, Java dispone de un bucle mejorado que visita cada elemento del array en orden sin necesidad de establecer un \u00edndice. Por tanto, los errores de exceder los l\u00edmites del array se eliminan autom\u00e1ticamente con este bucle.</p> <p>La sintaxis es la siguiente:</p> <p></p> <p>Este bucle se lee de la siguiente manera: \"para cada valor del array...\" (for each value in array...)</p> <p>El tipo de dato de la variable que se crea en el bucle es igual al de cada una de las celdas del array, y va a contener los valores de ellas. En la primera iteraci\u00f3n contrendr\u00e1 el valor de la primera celda del array, y as\u00ed sucesivamente hasta llegar a la \u00faltima celda del array.</p> <p>Ejemplo:</p> <pre><code>    int[] array =  {2, 19, 1, 5, 1, 27, 9, 5};\n    int suma = 0;\n    for (int numero : array) {\n            suma += numero;\n    }\n</code></pre>"},{"location":"ud4/2usefularrays/#comparar-si-dos-arrays-son-iguales","title":"Comparar si dos arrays son iguales","text":"<p>Es muy usual utilizar el operador \"==\" cuando queremos comparar si dos arrays son iguales, es decir, si contienen los mismos elementos. Pero si ejecutamos el siguiente c\u00f3digo:</p> <pre><code>    int[] array1 =  {1, 2, 3};\n    int[] array2 =  {1, 2, 3};\n\n    System.out.println(array1 == array2); //imprime false\n</code></pre> <p>Obtenemos false, esta situaci\u00f3n es parecida a cuando intent\u00e1bamos comparar dos String. Recordar que utilizar el operador \"==\" era incorrecto ya que son objetos diferentes aunque tuvieran el mismo contenido.</p> <p>Si utilizamos el m\u00e9todo equals() para arrays, devolver\u00eda el mismo valor booleano que el operador \"==\".</p> <pre><code>    System.out.println(array1.equals(array2)); //imprime false\n</code></pre> <p>Para comprobar que dos arrays contienen los mismos elementos se utiliza la clase Arrays.</p> <p>La clase Arrays contiene muchos m\u00e9todos est\u00e1ticos para manipular matrices. Dado que los m\u00e9todos son est\u00e1ticos, los invoca utilizando el nombre de la clase.</p> <pre><code>    int[] array1 =  {1, 2, 3};\n    int[] array2 =  {1, 2, 3};\n\n    System.out.println(Arrays.equals(array1, array2)); //imprime true\n</code></pre> <p>El m\u00e9todo Arrays.equals comprueba que dos arrays son iguales si tienen la misma longitud y contienen los mismos elementos en el mismo orden.</p>"},{"location":"ud4/2usefularrays/#otros-metodos-de-array","title":"Otros m\u00e9todos de Array","text":"M\u00e9todo Descripci\u00f3n static void fill(T[] array, T valor) Llena el array con el valor indicado: todos los elementos iguales. static boolean equals(T[] a1, T[] a2) Chequea si los arrays son id\u00e9nticos, comprobando valores primitivos (==) y referencias (con equals). static boolean deepEquals(Object[] a1, Object[] a2) Chequea si los arrays son id\u00e9nticos, comprobando valores primitivos (==) y referencias (con equals). Adem\u00e1s, si el array es multidimensional, profundiza en las sucesivas dimensiones. static String toString(T[] datos) Genera una cadena para impresi\u00f3n. static String deepToString(T[] datos) Genera una cadena para impresi\u00f3n, incluso si se trata de un array multidimensional. static T[] copyOf(T[] datos, int n) Genera una copia de los datos. Si n es mayor que datos.length, rellena con null. Si n es menor que datos.length, se ignora el exceso (es decir, trunca). static T[] copyOfRange(T[] datos, int desde, int hasta) Copia un segmento de los datos. static int binarySearch(T[] datos, T clave) Busca en qu\u00e9 posici\u00f3n del array datos se encuentra la clave dada. El array debe estar ordenado. static void sort(T[] datos) Ordena el array. static void sort(T[] datos, int desde, int hasta) Ordena el array entre las posiciones indicadas."},{"location":"ud4/3referencetypearrays/","title":"Tipos de referencia vs tipos de valor","text":"<p>Sabemos que los tipos de datos primitivos como int, double, etc. son tipos de datos primitivos, es decir, son tipos de valor ya que almacenan valores.</p> <p>A diferencia de \u00e9stos, los arrays son tipos de referencia como tambi\u00e9n los son los String.</p> <p>Cuando creamos una variable de tipo valor, se asigna un solo espacio en la memoria para almacenar su valor y esa variable contiene directamente el valor.</p> <p>Si creamos otra variable y le asignamos esa variable como se ve en el siguiente c\u00f3digo:</p> <pre><code>    int variable = 2;\n    int otraVariable = variable;//asignamos un 2 a otraVariable\n\n    otraVariable = 5;\n\n    System.out.println(variable);//imprime 2\n    System.out.println(otraVariable);//imprime 5\n</code></pre> <p>El valor es copiado directamente y ambas variables trabajan independientemente. Cada una tiene su propia copia del valor espec\u00edfico, en este caso 2.</p> <p>Ahora bien, tipos de referencia, como clases o arrays trabajan de forma diferente. Utilizamos la palabra new para crear un nuevo objeto.</p> <pre><code>    int[] array = new int[5];\n</code></pre> <p>En este caso, tenemos una referencia a un array. Los tipos de referencia son usados por una referencia. Por lo tanto, una referencia contiene una referencia o una direcci\u00f3n de objeto pero no el objeto en s\u00ed.</p> <p>En el ejemplo anterior, la variable array contiene una referencia o direcci\u00f3n al array en la memoria.</p> <p>Con los tipos de referencia, usamos una referencia para controlar el objeto en memoria, no podemos acceder al objeto directamente.</p> <p>Una referencia es como una direcci\u00f3n de alg\u00fan objeto en memoria.</p> <pre><code>    int[] array = new int[5];\n    int[] otroArray = array;\n</code></pre> <p>En el c\u00f3digo anterior, hemos declarado otroArray que es una referencia al mismo array en memoria. Es decir, ahora tenemos dos referencias apuntando al mismo array en memoria. O dicho de otra forma, tanto array como otroArray contienen la misma direcci\u00f3n en memoria.</p> <p>Como se puede observar, una forma de saber si es de tipo de referencia es con el operador new, ya que este crea un nuevo objeto en memoria.</p> <p>Para imprimir el contenido de un array, podemos usar un m\u00e9todo integrado en Java en la clase <code>Arrays.toString</code>. Este m\u00e9todo imprime el contenido del array en una sola l\u00ednea separando los elementos con comas.</p> <pre><code>    int[] array = new int[5];\n    int[] otroArray = array;\n\n    System.out.println(Arrays.toString(array));\n    System.out.println(Arrays.toString(otroArray));\n</code></pre> <p>Ahora mismo, los arrays est\u00e1n vac\u00edos por tanto se imprime todo con valores 0. Vamos a ver que ocurre si modificamos un valor en el array otroArray.</p> <pre><code>    int[] array = new int[5];\n    int[] otroArray = array;\n\n    System.out.println(Arrays.toString(array));\n    System.out.println(Arrays.toString(otroArray));\n\n    otroArray[0] = 3;\n\n    System.out.println(Arrays.toString(array));\n    System.out.println(Arrays.toString(otroArray));\n</code></pre> <p>Si ejecutamos el c\u00f3digo, veremos que ambos arrays han cambiado. Esto ocurre porque las dos variables apuntan al mismo array en memoria. Solo hay una copia del array en la memoria. Las dos variables contienen la direcci\u00f3n que apunta al array en memoria.</p> <p></p> <p>Para desreferenciar un array y que apunte a otro array en memoria tenemos que usar el operador new:</p> <pre><code>    int[] array = new int[5];\n    int[] otroArray = array;\n\n    System.out.println(Arrays.toString(array));\n    System.out.println(Arrays.toString(otroArray));\n\n    array = new int[]{1, 2, 3};\n    otroArray[0] = 3;\n\n    System.out.println(Arrays.toString(array));\n    System.out.println(Arrays.toString(otroArray));\n</code></pre>"},{"location":"ud4/3referencetypearrays/#metodos-paso-por-referencia","title":"M\u00e9todos: paso por referencia","text":"<p>Recuerda que Java usa llamada por valor para pasar datos a m\u00e9todos, esto es que env\u00eda una copia del dato, por tanto cualquier modificaci\u00f3n de la copia dentro del m\u00e9todo no afecta al original. Con par\u00e1metros de tipo array es diferente. Si pasamos a un m\u00e9todo el array, ya que le estamos pasando la referencia al array, crear\u00eda una nueva variable dentro del m\u00e9todo pero \u00e9sta apuntar\u00eda al mismo array en memoria. Cualquier modificaci\u00f3n dentro del m\u00e9todo en el array se ver\u00eda fuera del m\u00e9todo puesto que solo hay un objeto array en memoria.</p>"},{"location":"ud4/4arrayobjects/","title":"Array de objetos","text":"<p>Una caracter\u00edstica importante de los arrays, es que todos los elementos deben ser del mismo tipo.</p> <p>Hasta ahora, hemos estudiado arrays con elementos de tipos primitivos. Sin embargo, tambi\u00e9n se puede crear arrays con elementos de cualquier tipo de datos, incluidas las referencias a objetos.</p> <p>Recordemos que, cuando hacemos <code>String str;</code>, se declara una variable llamada <code>str</code> que almacena la referencia a un objeto de tipo String, pero el objeto todav\u00eda no ha sido creado.</p> <p>Un objeto existe solo despu\u00e9s de haber sido construido. Los objetos se construyen solo mientras se ejecuta un programa cuando se invoca el constructor.</p> <p>Una vez construido, se accede a un objeto siguiendo una referencia al objeto. A menudo, la referencia se mantiene en una variable de referencia como <code>str</code>.</p> <p>En el siguiente ejemplo, se declara una variable de referencia, se construye un objeto y luego la referencia al objeto se coloca en la variable de referencia:</p> <pre><code>String str;             // declara una variable de tipo referencia\nstr = \"Hello World\" ;   // construye el objeto y \n                        // almacena su referencia\n</code></pre> <p></p>"},{"location":"ud4/4arrayobjects/#array-de-strings","title":"Array de Strings","text":"<p>Para declarar un array de Strings ser realizar\u00eda de la siguiente forma:</p> <pre><code>String[] array = new String[5];\n\narray[0] = \"Hello\";\narray[1] = \"World\";\n...\n</code></pre> <p></p> <p>Cada objeto String del ejemplo es un String normal. Nada en \u00e9l ha cambiado porque su referencia se mantiene en el array. Cada cadena puede tener cualquier n\u00famero de caracteres.</p>"},{"location":"ud4/4arrayobjects/#array-de-objetos_1","title":"Array de objetos","text":"<p>Al igual que los arrays de string, odemos tener un array de cualquier tipo de clase. Cada elemento del array apuntar\u00e1 a una instancia del tipo de la clase o a null.</p> <p>Podemos ver en el ejemplo una clase de tipo Alumno y un array de alumnos en el que se crean algunas instancias del array.</p> <p><pre><code>public class Alumno {\n    private String nombre;\n    private int nota;\n\n    public Alumno(String nombre, int nota) {\n        this.nombre = nombre;\n        this.nota = nota;\n    }\n    public void mostrarAlumno() {\n        System.out.println( \"Alumno: \" + nombre + \" nota:\" + nota);\n    }\n}\n</code></pre> Si declaramos un array de Alumnos, hay que crear las instancias para cada posici\u00f3n del array como vemos en las dos primeras l\u00edneas marcadas</p> <p><pre><code> public static void main(String[] args) {\n        //creamos una array de Alumnos\n        Alumno[] dam1k = new Alumno[5];\n        //creamos dos alumnos en las dos primeras posiciones\n        dam1k[0] = new Alumno(\"Pepe\", 7);\n        dam1k[1] = new Alumno(\"Maria\", 9);\n        //mostramos alumnos \n        dam1k[0].mostrarAlumno();\n        dam1k[1].mostrarAlumno();\n        //produce el error NullPointerException\n        dam1k[2].mostrarAlumno();\n\n    }\n</code></pre> Vemos en la \u00faltima l\u00ednea marcada como se intenta acceder a una instancia de la posici\u00f3n 2 pero no se ha creado una instancia, esto  producir\u00e1 un error en tiempo de ejecuci\u00f3n NullPointerException</p> <p></p>"},{"location":"ud4/4arrayobjects/#argumentos-de-linea-de-comandos","title":"Argumentos de l\u00ednea de comandos","text":"<p>Como ya sabemos el m\u00e9todo <code>main</code> recibe un array de Strings como par\u00e1metro:</p> <pre><code>    public static void main(String[] args) {\n    }\n</code></pre> <p>Es decir, main recibe una referencia a un array de referencias de String. Este array es construido por el sistema Java justo antes de que <code>main()</code> obtenga el control. Los elementos que contiene el array son cadenas de texto que se pasan en la l\u00ednea de comando que inicia el programa. Por ejemplo, digamos que un programa se inicia con esta l\u00ednea de comando:</p> <p>java Demo cadena1 cadena1</p> <p>Donde <code>Demo</code> es el nombre del programa, <code>cadena1</code> es el primer argumento y <code>cadena2</code> el segudno.</p> <p>Por tanto <code>args[0]</code> contendr\u00e1 cadena1 y <code>args[1]</code> cadena2.</p> <p>Puede haber cualquier n\u00famero de argumentos en la l\u00ednea de comandos. Los argumentos son siempre cadenas de caracteres. Cada argumento est\u00e1 separado del resto por espacios.</p> <p>A veces, se quieren enviar n\u00famero por l\u00ednea de comandos. Por tanto necesitaremos convertir las cadenas de d\u00edgitos en n\u00fameros. Para ello, utilizaremos el m\u00e9todo <code>Integer.parseInt(String)</code> o <code>Double.parseDouble(String)</code>.</p>"},{"location":"ud4/4arrayobjects/#espacio-de-memoria-en-arrays-de-objetos","title":"Espacio de memoria en arrays de objetos","text":"<p>Como hemos comentado, en arrays de objetos, Java almacena solo la referencia al objeto en el propio array, en lugar de todo el objeto. Esto conserva la memoria, ya que las referencias requieren solo 4 bytes cada una, mientras que cada objeto puede requerir cientos de bytes.</p> <p>Ejemplo, para un array de 15 enteros, sabiendo que cada entero requiere 4 bytes de almacenamiento, se almacenar\u00e1 60 bytes contiguos de memoria.</p>"},{"location":"ud4/5sortarrays%20copy/","title":"Algoritmos de ordenaci\u00f3n","text":"<p>La ordenaci\u00f3n es una de las t\u00e9cnicas fundamentales que se utilizan en la resoluci\u00f3n de problemas, especialmente en los relacionados con la escritura y la implementaci\u00f3n de algoritmos eficientes.</p> <p>Por lo general, la ordenaci\u00f3n se combina con la b\u00fasqueda, lo que significa que primero ordenamos los elementos de la colecci\u00f3n dada, luego buscamos algo dentro de ella, ya que generalmente es m\u00e1s f\u00e1cil buscar algo en una colecci\u00f3n ordenada, en lugar de sin ordenar.</p> <p>Ordenar un array es el proceso de ordenar sus elementos en orden ascendente o descendente. Los algoritmos de ordenaci\u00f3n se encuentran entre los algoritmos m\u00e1s utilizados en computaci\u00f3n.</p>"},{"location":"ud4/5sortarrays%20copy/#bubble-sort-burbuja","title":"Bubble sort (Burbuja)","text":"<p>Funciona intercambiando elementos adyacentes si no est\u00e1n en el orden deseado. Este proceso se repite desde el principio del array hasta que todos los elementos est\u00e1n en orden.</p> <p>Sabemos que todos los elementos est\u00e1n en orden cuando logramos hacer toda la iteraci\u00f3n del array sin intercambiar ning\u00fan elemento en absoluto; entonces, todos los elementos que comparamos estaban en el orden deseado con sus elementos adyacentes y, por extensi\u00f3n, todo el array.</p> <p>Ejemplo:</p> <pre><code>[4, 2, 1, 5, 3] - Paso 1: como 4 &gt; 2, los intercambiamos \n[2, 4, 1, 5, 3] - Paso 2: como 4 &gt; 1, los intercambiamos\n[2, 1, 4, 5, 3] - Paso 3: como no se cumple 4 &gt; 5, los dejamos igual\n[2, 1, 4, 5, 3] - Paso 4: como 5 &gt; 3, los intercambiamos\n[2, 1, 4, 3, 5] - Este es el resultado del array despu\u00e9s de la primera iteraci\u00f3n del bucle externo.\n</code></pre> <p>Como al menos se produjo un intercambio durante la primera iteraci\u00f3n (en realidad hubo tres), debemos revisar todo el array otra vez y repetir el mismo proceso.</p> <p>Repetiremos este proceso, hasta que no se realicen m\u00e1s intercambios, que ser\u00e1 cuando tengamos el array ordenado.</p> <p>La raz\u00f3n por la que este algoritmo se llama Bubble sort es porque los n\u00fameros \"burbujean\" hasta la \"superficie\".</p> <p>Si seguimos haciendo trazas en el ejemplo, siguiendo un n\u00famero en particular (4 es un gran ejemplo), ver\u00e1s que se mueve lentamente hacia la derecha durante el proceso.</p>"},{"location":"ud4/5sortarrays%20copy/#complejidad-temporal","title":"Complejidad temporal","text":"<p>Para calcular la complejidad temporal de Bubble Sort, necesitamos mirar el peor escenario posible. \u00bfCu\u00e1l es la cantidad m\u00e1xima de veces que necesitamos pasar por todo el array antes de ordenarlo?</p> <p>El peor escenario ser\u00eda <code>[5, 4, 3, 2, 1]</code>. En la primera iteraci\u00f3n, 5 \"burbujear\u00e1 hasta la superficie\", pero el resto de los elementos permanecer\u00e1n en orden descendente. Tendr\u00edamos que hacer una iteraci\u00f3n para cada elemento excepto 1, y luego otra iteraci\u00f3n para verificar que todo est\u00e9 en orden, por lo que un total de 5 iteraciones.</p> <p>Si pensamos en un array de n elementos, eso significa que necesitamos hacer n iteraciones.</p> <p>Cada una de esas n veces estamos iterando a trav\u00e9s de todo el array, lo que significa que la complejidad temporal en el peor de los casos ser\u00eda Big-O: O(n^2).</p>"},{"location":"ud4/5sortarrays%20copy/#counting-sort","title":"Counting sort","text":"<p>El ordenamiento por conteo es un algoritmo de ordenamiento que ordena los elementos de un array contando el n\u00famero de apariciones de cada elemento \u00fanico en el array. El recuento se almacena en un array auxiliar y la ordenaci\u00f3n se realiza mapeando la cuenta como un \u00edndice del array auxiliar.</p>"},{"location":"ud4/5sortarrays%20copy/#como-funciona","title":"\u00bfC\u00f3mo funciona?","text":"<ol> <li>Encuentra el elemento m\u00e1ximo <code>max</code> del array dado. </li> <li>Crea un array de longitud <code>max + 1</code> con todos los elementos a 0. Este array se utiliza para almacenar el recuento de los elementos del array. </li> <li>Almacena el recuento de cada elemento en su \u00edndice respectivo en el array de recuento. Por ejemplo: si el elemento 3 aparece 2 veces en el array, entonces 2 se almacena en la tercera posici\u00f3n del array de recuentos. Si el elemento \"5\" no est\u00e1 presente en el array, entonces 0 se almacena en la quinta posici\u00f3n. </li> <li>Almacena la suma acumulativa de los elementos del array de recuentos. Es \u00fatil colocar los elementos en el \u00edndice correcto del array ordenado. </li> <li>Encuentra el \u00edndice de cada elemento del array original en el array de conteo. Esto da el recuento acumulativo. Coloca el elemento en el \u00edndice calculado como se muestra en la figura siguiente. </li> <li>Despu\u00e9s de colocar el elemento en la posici\u00f3n correcta del array ordenado, disminuye el array de recuento para ese \u00edndice en uno.</li> </ol>"},{"location":"ud4/5sortarrays%20copy/#complejidad","title":"Complejidad","text":"<p>La complejidad temporal en el peor caso es Big-O: O(n).</p>"},{"location":"ud4/5sortarrays/","title":"Algoritmos de ordenaci\u00f3n","text":"<p>La ordenaci\u00f3n es una de las t\u00e9cnicas fundamentales que se utilizan en la resoluci\u00f3n de problemas, especialmente en los relacionados con la escritura y la implementaci\u00f3n de algoritmos eficientes.</p> <p>Por lo general, la ordenaci\u00f3n se combina con la b\u00fasqueda, lo que significa que primero ordenamos los elementos de la colecci\u00f3n dada, luego buscamos algo dentro de ella, ya que generalmente es m\u00e1s f\u00e1cil buscar algo en una colecci\u00f3n ordenada, en lugar de sin ordenar.</p> <p>Ordenar un array es el proceso de ordenar sus elementos en orden ascendente o descendente. Los algoritmos de ordenaci\u00f3n se encuentran entre los algoritmos m\u00e1s utilizados en computaci\u00f3n.</p>"},{"location":"ud4/5sortarrays/#articulos-de-referencia","title":"Art\u00edculos de referencia","text":"<p>https://es.wikipedia.org/wiki/Algoritmo_de_ordenamiento</p> <p>http://lwh.free.fr/pages/algo/tri/tri_es.htm</p>"},{"location":"ud4/6searcharrays/","title":"Algoritmos de b\u00fasqueda","text":"<p>Supongamos que tenemos un array de grandes dimensiones y necesitamos encontrar uno de sus elementos. Necesitamos un algoritmo para buscar en el array un valor particular, generalmente llamado <code>clave</code>. Si los elementos del array no est\u00e1n organizados en ning\u00fan orden en particular, la \u00fanica forma en que podemos estar seguros de encontrar la clave, asumiendo que est\u00e1 en el array, es buscar cada elemento, comenzando por el primer elemento, hasta encontrarlo. Este algoritmo es conocido como b\u00fasqueda lineal o secuencial.</p>"},{"location":"ud4/6searcharrays/#busqueda-secuencial","title":"B\u00fasqueda secuencial","text":"<p>En la b\u00fasqueda secuencial, cada elemento del array se examinar\u00e1 en secuencia hasta que se encuentre la clave (o se llegue al final del array).</p>"},{"location":"ud4/6searcharrays/#algoritmo-busqueda-secuencial","title":"Algoritmo b\u00fasqueda secuencial","text":"<p>Este algoritmo se puede implementar f\u00e1cilmente en un m\u00e9todo que busca un array de enteros, que se pasa como par\u00e1metro del m\u00e9todo y la <code>clave</code> a buscar. Si la <code>clave</code> se encuentra en el array, se devuelve su ubicaci\u00f3n. Si no se encuentra, se devuelve <code>\u22121</code> para indicar fallo.</p> <pre><code>public class Search {\n\n   public static int sequentialSearch(int[] array, int key) {\n      for (int i = 0; i &lt; array.length; i++) {\n         if (array[i] == key) {\n            return i;\n         }\n      }\n      return -1; //no lo ha encontrado\n   }\n\n}\n</code></pre> <p>Big O notation es una notaci\u00f3n para representar la complejidad temporal de un algoritmo, su rendimiento. Generalmente describe el peor escenario, es decir, el m\u00e1ximo tiempo en la mayor cantidad de repeticiones que el algoritmo tiene que ejecutar.</p> <ul> <li>Big-O de una b\u00fasqueda secuencial es O(n) en el peor de los casos y O(1) en el mejor.</li> </ul>"},{"location":"ud4/6searcharrays/#busqueda-binaria","title":"B\u00fasqueda binaria","text":"<p>La b\u00fasqueda binaria es un algoritmo de b\u00fasqueda para encontrar la posici\u00f3n de un elemento en un array ordenado.</p> <p>La b\u00fasqueda binaria solo se puede implementar en una lista ordenada de elementos. Si los elementos no est\u00e1n ordenados, primero debemos ordenarlos.</p> <p>El algoritmo de b\u00fasqueda binaria se puede implementar de dos formas diferentes:</p> <ol> <li>M\u00e9todo iterativo</li> <li>M\u00e9todo recursivo. El m\u00e9todo recursivo sigue el enfoque de divide y vencer\u00e1s.</li> </ol>"},{"location":"ud4/6searcharrays/#como-se-hace","title":"\u00bfC\u00f3mo se hace?","text":"<ol> <li>El array en el que se va a realizar la b\u00fasqueda es. Sea <code>x = 4</code> el elemento a buscar. </li> <li>Establezce dos punteros <code>low</code> y <code>high</code> en las posiciones m\u00e1s baja y m\u00e1s alta, respectivamente. </li> <li>Encuentra el elemento del medio <code>mid</code> en la mitad del array, es decir, <code>mid = (low + high)/2; array[mid] = 6</code>. </li> <li>Si <code>x == array[mid]</code>, devuelve <code>mid</code>. De lo contrario, compara el elemento que se va a buscar con <code>m</code>.</li> <li>Si <code>x &gt; array[mid]</code>, comparamos <code>x</code> con el elemento medio de los elementos en el lado derecho de <code>mid</code>. Esto se hace estableciendo <code>low</code> a <code>low = mid + 1</code>.</li> <li>De lo contrario, comparamos <code>x</code> con el elemento central de los elementos en el lado izquierdo de <code>mid</code>. Esto se hace estableciendo <code>high</code> a <code>high = mid - 1</code>. </li> <li>Repetimos los pasos 3 a 6 mientras que <code>low</code> sea menor igual que <code>high</code>. </li> <li><code>x = 4</code> se ha encontrado.</li> </ol> <p>Al m\u00e9todo se le pasa el <code>array</code>, la <code>clave</code>, y las posiciones <code>low</code> y <code>high</code>.</p> <ul> <li>Big-O para la b\u00fasqueda binaria es O(log N) en el peor de los casos y O(1) en el mejor caso.</li> </ul>"},{"location":"ud4/7twodimensionarray/","title":"Arrays multidimensionales","text":"<p>Un array bidimensional o matriz, es un array cuyos componentes son ellos mismos arrays, y es necesario o \u00fatil para ciertos tipos de problemas. Por ejemplo, imagina una clase de 7 estudiantes que tienen un examen cada semana durante 5 semanas. El profesor registra las calificaciones en una tabla. Una celda particular de la tabla se designa por n\u00famero de estudiante y n\u00famero de semana.</p> <p>En Java, una tabla se puede implementar como una matriz 2D. Cada celda de la matriz es una variable que puede contener un valor y funciona como cualquier variable. Al igual que con los arrays unidimensionales, todas las celdas de una matriz 2D son del mismo tipo. El tipo puede ser un tipo primitivo o un tipo de referencia de objeto.</p> <p>Importante: cada celda de la matriz se especifica con un n\u00famero de fila y columna, en ese orden.</p> <p><code>matriz[fila][col]</code></p> <p>Al igual que con los arrays unidimensionales, los \u00edndices comienzan en cero.</p> <p></p> <p>Para acceder a la posici\u00f3n 0,2 lo har\u00edamos con <code>matriz[0][2]</code> y esto devuelve el entero 4.</p> <p>Al igual que con una matriz 1D o un arrar, un \u00edndice de matriz puede ser un literal entero, una variable de tipo entero, un m\u00e9todo que se eval\u00faa como un n\u00famero entero o una expresi\u00f3n aritm\u00e9tica que involucra todas estas cosas:</p> <pre><code>int [][] matriz=new int[4][3];\nmatriz[3][2] = 34;\n//si estamos en un bucle\nsuma = matriz[i][j] + matriz[i][j + 1];\n//\nvalue = matriz[2][someFunction()];\n\nmatriz[1][0] = matriz[i + 3][algunaFunci\u00f3n() - 2];\n</code></pre>"},{"location":"ud4/7twodimensionarray/#declaracion-de-un-array-2d-o-matriz-2d","title":"Declaraci\u00f3n de un array 2D o matriz 2D","text":"<p>Recordamos que al igual que los arrays unidimensionales, las matrices bidimensionales son objetos. Para declara un array bidimensional se puede crear una lista. La lista debe contener las filas cada una separada por una coma; y cada fila es una lista de valores.</p> <p>Ejemplo:</p> <pre><code>int[][] myArray = { {8,1,2,2,9}, {1,9,4,0,3}, {0,3,0,0,7} };\n\n//tambi\u00e9n se puede hacer as\u00ed\nint[][] matriz = new int[5][7];//inicializa todo a 0s\n</code></pre> <p>Cada fila de una matriz 2D puede tener un n\u00famero diferente de celdas.</p> <p>Si un programa intenta acceder a una celda que no existe, se lanzar\u00e1 una excepci\u00f3n (que generalmente detendr\u00e1 su programa). Hacer una asignaci\u00f3n a una celda que no existe es un error.</p>"},{"location":"ud4/7twodimensionarray/#longitud-de-una-matriz-2d","title":"Longitud de una matriz 2D","text":"<p>La longitud de una matriz 2D es el n\u00famero de filas que tiene. Se puede adivinar que \"longitud\" podr\u00eda definirse como un par de n\u00fameros (filas, columnas). Pero el n\u00famero de columnas puede variar de una fila a otra, por lo que esto no funcionar\u00e1. Sin embargo, el n\u00famero de filas no cambia, por lo que funciona como una longitud.</p>"},{"location":"ud4/7twodimensionarray/#longitud-de-un-array-2d-de-tamano-de-columna-fijo","title":"Longitud de un array 2D de tama\u00f1o de columna fijo","text":"<p>Si sabemos que un array 2D es una cuadr\u00edcula rectangular, podemos obtener el n\u00famero de filas usando matriz.length y el n\u00famero de columnas usando matriz[0].length</p> <pre><code>int[][] matriz;\nmatriz = new int[5][10];\nint row = matriz.length;//5\nint col = matriz[0].length;//10\n</code></pre>"},{"location":"ud4/7twodimensionarray/#recorrer-array-2d-de-tamano-de-columna-fijo","title":"Recorrer array 2D de tama\u00f1o de columna fijo","text":"<p>Para recorrer un array, debemos usar un bucle anidado, donde el primer bucle controla las filas y el de dentro las columnas</p> <pre><code>//Definimos un array de 3 filas x 5 columnas\nint array[][]={{1,2,3,4,5}, {6,7,8,9,10}, {11,12,13,14,15}};\n\n//Recorremos el array multidimensional\nfor (int i=0;i&lt;array.length;i++){//total filas\n    for(int j=0;j&lt;array[0].length;j++){//total columnas\n        System.out.println(array[i][j]);\n    }\n}\n</code></pre>"},{"location":"ud4/7twodimensionarray/#longitud-de-un-array-2d-con-tamano-de-columna-variable-en-java","title":"Longitud de un array 2D con tama\u00f1o de columna variable en Java","text":"<p>Cada fila de una matriz 2D puede tener un n\u00famero diferente de celdas (columnas), por lo que cada fila tiene su propia longitud.</p> <pre><code>int[][] matriz;\nmatriz = new int[2][];//dos filas\nmatriz[0] = new int[5];//5 elementos la fila 0\nmatriz[1] = new int[10];//10 elementos la fila 1\nint row = test.length;\nint col_1 = test[0].length;//5\nint col_2 = test[1].length;//10\n</code></pre>"},{"location":"ud4/7twodimensionarray/#recorrer-array-2d-de-tamano-de-columna-variable","title":"Recorrer array 2D de tama\u00f1o de columna variable","text":"<p>Para recorrer un array, debemos usar un bucle anidado, donde el primer bucle controla las filas y el de dentro las columnas</p> <pre><code>//Definimos un array de 3 filas x  columnas variables\nint array[][]={{1,2,3,4,5}, {6,7,8}, {11,12,13,14,15}};\n\n//Recorremos el array multidimensional\nfor (int i=0;i&lt;array.length;i++){//total filas\n    for(int j=0;j&lt;array[i].length;j++){//total columna actual\n        System.out.println(array[i][j]);\n    }\n}\n</code></pre>"},{"location":"ud4/7twodimensionarray/#entender-mejor-los-arrays-o-matrices-2d","title":"Entender mejor los arrays o matrices 2D","text":"<p>Un array bidimensional se implementa como un array unidimensionales. La declaracion</p> <p><code>int [][] myArray;</code> // 1.</p> <p></p> <p>declara una variable llamada <code>myArray</code> que en el futuro puede hacer referencia a un objeto de matriz. En este punto, no se ha dicho nada sobre el n\u00famero de filas o columnas.</p> <p>Para crear una matriz de 3 filas, har\u00edamos:</p> <p><code>myArray = new int [3][];</code> // 2.</p> <p></p> <p>Ahora <code>myArray</code> hace referencia a un objeto de matriz. El objeto de matriz tiene 3 celdas. Cada celda puede hacer referencia (en el futuro) a una matriz de int, un objeto int []. Sin embargo, ninguna de las celdas se refiere todav\u00eda a un objeto. Se inicializan a nulo.</p> <p>Una forma de crear la fila 0 es esta:</p> <p><code>myArray[0] = new int [3];</code> // 3.</p> <p></p> <p>Esto crea un objeto array 1D y coloca su referencia en la celda 0 de myArray. Las celdas del array 1D se inicializan a 0.</p> <p>Una matriz o array 1D construida previamente se puede asignar a una fila:</p> <pre><code>int[] x = {0, 2};\nint[] y = {0, 1, 2, 3, 4};\n\nmyArray [1] = x;\nmyArray [2] = y; // 4.\n</code></pre> <p></p> <p>No es necesario que las filas tengan el mismo n\u00famero de celdas.</p> <p>Las declaraciones anteriores construyen la matriz 2D paso a paso.</p>"},{"location":"ud4/7twodimensionarray/#como-se-podrian-reemplazar-las-celdas-individuales-de-cada-fila-dentro-de-una-matriz","title":"\u00bfC\u00f3mo se podr\u00edan reemplazar las celdas individuales de cada fila dentro de una matriz?","text":"<p>Si quisieras reemplazar la fila uno del ejemplo anterior con la siguiente sentencia:</p> <p><code>myArray [0] = {1, 9, 4};</code> No funcionar\u00e1.</p> <p>Una lista de inicializadores entre llaves { } solo se puede usar para inicializar una matriz, no para asignarle valores despu\u00e9s de que ya se ha creado y existe.</p> <p>Si has pensado en hacer algo as\u00ed:</p> <pre><code>int[] x = {1, 9, 4}; // declarar e iniciar x\nmyArray [0] = x; // asignar a myArray\n</code></pre> <p>Esto si funcionar\u00eda, pero no har\u00edamos exactamente lo que se pidi\u00f3 en la pregunta. Es decir, de esta forma reemplazar\u00edamos la antigua fila 0 con una nueva fila. Lo que hacemos es construir un nuevo objeto de matriz 1D (un array) que contiene los valores deseados en sus celdas y luego asigna ese objeto a la fila 0 de <code>myArray</code>. La fila 0 anterior ahora es basura.</p> <p>Lo correcto ser\u00eda recorrer la fila 0 y reemplazar el valor de cada celda.</p> <p></p>"},{"location":"ud4/8string/","title":"\ud83d\udcbe String en Java","text":"<p>Un String es un tipo de dato no primitvo que, en Java representa una cadena de caracteres no modificable. Todos los literales de la forma \"cualquier texto\", es decir, literales entre comillas dobles, que aparecen en un programa java se implementan como objetos de la clase String.</p> <p>A diferencia de otras clases, String se puede crear sin la palabra new.</p> <p>String text = \"hola\";</p>"},{"location":"ud4/8string/#creacion-de-string","title":"Creaci\u00f3n de String","text":"<p>Se puede crear un String de varias formas.</p> <pre><code>    String texto = \"Severo Ochoa\";\n\n    //Utilizando new\n    String texto2 = new String(\"Severo Ochoa\");\n\n    //Utilizando el operador concatenaci\u00f3n +\n    String s2 = text + \" 2023\";      //s2 contiene \"Severo Ochoa 2023\"\n</code></pre>"},{"location":"ud4/8string/#el-operador-concatenacion","title":"El operador concatenaci\u00f3n","text":"<p>La clase proporciona el operador + (concatenaci\u00f3n) para unir dos o m\u00e1s String. El resultado de aplicar este operador es un nuevo String concatenaci\u00f3n de los otros. Por ejemplo, si tenemos dos String b y c:</p> <pre><code>String b = \"Ordenador\";\nString c = \" Port\u00e1til\";\n</code></pre> <p></p> <p>La operaci\u00f3n</p> <pre><code>b = b + c;\n</code></pre> <p>Crea un nuevo String que se incluye en el String Pool:</p> <p></p>"},{"location":"ud4/8string/#indices","title":"\u00cdndices","text":"<p>Cada uno de los caracteres que forman un String son del tipo primitivo char. Los caracteres de un string est\u00e1n numerados internamente con \u00edndices empezando desde el cero:</p> <p></p> <p>El primer car\u00e1cter tiene \u00edndice 0 y el \u00faltimo tiene la longitud del string menos 1.</p>"},{"location":"ud4/8string/#metodos-de-la-clase-string","title":"M\u00e9todos de la clase String","text":"<p>La clase String proporciona m\u00e9todos para el tratamiento de las cadenas de caracteres: acceso a caracteres individuales, buscar y extraer una subcadena, copiar cadenas, convertir cadenas a may\u00fasculas o min\u00fasculas, etc. Alguno de los m\u00e9todos m\u00e1s importantes son:</p> <p></p> <p>Para acceder a alguno de los m\u00e9todos siguientes utilizamos la notaci\u00f3n \".\"</p> <pre><code>  String texto = \"Clase\";\n  int longitud = texto.length(); //devuelve 5\n</code></pre> <p></p> <p></p> <p>Tip</p> <p>Para m\u00e1s informaci\u00f3n consulta la documentaci\u00f3n oficial de la clase String</p>"},{"location":"ud4/8string/#comparar-strings","title":"Comparar Strings","text":"<p>Los operadores relacionales como == o &lt; &gt; NO se utilizan para comparar Strings, aunque el c\u00f3digo compile no es correcto, ya que == compara objetos, y devolver\u00eda falso aunque dos strings tuvieran el mismo texto puesto que son objetos diferentes.</p> <p>Para comparar strings utilizamos el m\u00e9todo equals.</p> <pre><code>  String name = \"Patri\";\n\n  if (name.equals(\"Patri\")) {\n    System.out.println(\"Coincide.\");\n  }\n</code></pre> <p>La siguiente tabla muestra los m\u00e9todos que se utilizan para comparar Strings.</p> <p></p>"},{"location":"ud4/8string/#char-dentro-de-string","title":"char dentro de String","text":"<p>Como se ha comentado, un String est\u00e1 compuesto de caracteres tipo char.</p> <p>Para acceder a los caracteres dentro de un String usamos el m\u00e9todo charAt.</p> <p>Se puede usar la concatenaci\u00f3n + para concatenar char con String.</p> <pre><code>String food = \"cookie\";\nchar firstLetter = food.charAt(0); // 'c'\nSystem.out.println(firstLetter + \" is for \" + food); \n</code></pre> <p>Tambi\u00e9n podemos recorrer el String con un bucle for e imprimir cada uno de los caracteres que lo forman.</p> <pre><code>String major = \"CSE\";\nfor (int i = 0; i &lt; major.length(); i++) {\n  char c = major.charAt(i);\n  System.out.println(c);\n}\n</code></pre> <p><pre><code>OUTPUT\nC\nS\nE\n</code></pre> Tambi\u00e9s es posible recorrerlo mediante un foreach transformando el String en array de char</p> <pre><code>String s=\"Hola\";\nfor (char c:s.toCharArray()) {\n    System.out.println(c);\n}\n</code></pre>"},{"location":"ud4/8string/#char","title":"char","text":"<p>A todos los valores char se les asigna un n\u00famero internamente por el ordenador, son los llamados valores UNICODE. Por ejemplo:</p> <p>el car\u00e1cter 'A' es 65 en c\u00f3digo UNICODE</p> <p>el car\u00e1cter 'a' es 97 en c\u00f3digo UNICODE</p> <p>Mezclar tipos de datos char e int autom\u00e1ticamente cause una conversi\u00f3n en entero. Por ejemplo:</p> <p>'a' + 10 \u2192 devuelve 107.</p> <p>Para convertir un entero en su equivalente a car\u00e1cter (char) har\u00edamos:</p> <p>(char) ('a' + 2) \u2192 devuelve 'c'.</p>"},{"location":"ud4/8string/#diferencias-entre-char-y-string","title":"Diferencias entre char y String","text":"<ul> <li>String es un objeto, por tanto, contiene m\u00e9todos.</li> <li>char es un tipo de dato primitivo, no puedes llamar a m\u00e9todos con \u00e9l.</li> <li>String utiliza comillas dobles.</li> <li>char utiliza comillas simples.</li> <li>No se puede comparar un String usando operadores relacionales.</li> <li>Si se puede comparar un char usando operadores relacionales: 'a' &lt; 'b', 'X' == 'X', ...</li> </ul>"},{"location":"ud4/8string/#clasificacion-de-caracteres","title":"Clasificaci\u00f3n de caracteres","text":"<p>Un car\u00e1cter puede clasificarse dentro de alguno de estos grupos:</p> <ul> <li>D\u00edgitos: formado por '0', '1'...'9'</li> <li>Letras: formado por todos los elementos del alfabeto: 'a','b'...'A','B'...</li> <li>Caracteres blancos: como espacio, tabulador...todos aquellos que no tienen representaci\u00f3n visual</li> <li>Otros caracteres: signos de puntuaci\u00f3n, matem\u00e1ticos, etc.</li> </ul> <p>Tenemos una serie de m\u00e9todos que nos permite saber el tipo de car\u00e1cter</p> <p></p> <pre><code>boolean b;\nb=Character.isDigit('8');//true\nb=Character.isDigit('a');//false\nb=Character.isLetter('8');//false\nb=Character.isLetter('a');//true\nb=Character.isLetterOrDigit('8');//true\nb=Character.isLetterOrDigit('a');//true\nb=Character.isLetterOrDigit('%');//false\nb=Character.isUpperCase('t');//false\nb=Character.isUpperCase('T');//true\nb=Character.isLowerCase('t');//true\nb=Character.isLowerCase('T');//false\nb=Character.isWhitespace('\\n');//true\nb=Character.isWhitespace('\\r');//true\nb=Character.isWhitespace(' ');//true\nb=Character.isWhitespace('a');//false\n</code></pre> <p>Tip</p> <p>Para m\u00e1s informaci\u00f3n consulta la documentaci\u00f3n oficial de la clase Character</p>"},{"location":"ud4/8string/#modificacion-de-cadenas-con-frecuencia-stringbuilder","title":"Modificaci\u00f3n de cadenas con frecuencia: StringBuilder","text":"<p>Como hemos visto anteriormente, cada vez que se reasigna un String a una variable, se destruye el objeto y se crea uno nuevo lo que puede implicar una perdida de eficiencia y recursos  cuando estamos construyendo un String en un algoritmo que implica muchas reasignaciones.</p> <p>Tenemos la clase StringBuilder que permite manipular  cadenas de forma eficiente, ya que se puede modificar su contenido sin crear nuevos objetos en memoria.</p> <p>Sus m\u00e9todos principales son</p>"},{"location":"ud4/8string/#metodos-principales-de-stringbuilder-en-java","title":"M\u00e9todos principales de <code>StringBuilder</code> en Java","text":"M\u00e9todo Descripci\u00f3n Ejemplo <code>append(String s)</code> A\u00f1ade texto al final del contenido actual del <code>StringBuilder</code>. <code>StringBuilder sb = new StringBuilder(\"Hola\");</code><code>sb.append(\" Mundo\");</code><code>// Salida: Hola Mundo</code> <code>insert(int offset, String s)</code> Inserta una cadena en una posici\u00f3n espec\u00edfica dentro del <code>StringBuilder</code>. <code>StringBuilder sb = new StringBuilder(\"Hola\");</code><code>sb.insert(4, \" Mundo\");</code><code>// Salida: Hola Mundo</code> <code>delete(int start, int end)</code> Elimina los caracteres comprendidos entre las posiciones indicadas (<code>start</code> inclusivo, <code>end</code> exclusivo). <code>StringBuilder sb = new StringBuilder(\"Hola Mundo\");</code><code>sb.delete(5, 10);</code><code>// Salida: Hola</code> <code>replace(int start, int end, String s)</code> Reemplaza los caracteres entre los \u00edndices especificados con la cadena proporcionada. <code>StringBuilder sb = new StringBuilder(\"Hola Mundo\");</code><code>sb.replace(5, 10, \"Java\");</code><code>// Salida: Hola Java</code> <code>reverse()</code> Invierte el contenido del <code>StringBuilder</code>. <code>StringBuilder sb = new StringBuilder(\"Hola\");</code><code>sb.reverse();</code><code>// Salida: aloH</code> <code>length()</code> Devuelve el n\u00famero de caracteres que contiene el <code>StringBuilder</code>. <code>StringBuilder sb = new StringBuilder(\"Hola\");</code><code>System.out.println(sb.length());</code><code>// Salida: 4</code> <code>capacity()</code> Muestra la capacidad actual del buffer interno. Este valor aumenta autom\u00e1ticamente cuando se excede. <code>StringBuilder sb = new StringBuilder();</code><code>System.out.println(sb.capacity());</code><code>// Salida: 16 (por defecto)</code> <code>setCharAt(int index, char ch)</code> Modifica un car\u00e1cter espec\u00edfico en la posici\u00f3n indicada. <code>StringBuilder sb = new StringBuilder(\"Hola\");</code><code>sb.setCharAt(1, 'e');</code><code>// Salida: Hela</code> <code>substring(int start, int end)</code> Devuelve una subcadena que empieza en <code>start</code> y termina en <code>end</code> (exclusivo), similar a <code>String</code>. <code>StringBuilder sb = new StringBuilder(\"Hola Mundo\");</code><code>System.out.println(sb.substring(0, 4));</code><code>// Salida: Hola</code> <code>deleteCharAt(int index)</code> Elimina el car\u00e1cter en la posici\u00f3n especificada. <code>StringBuilder sb = new StringBuilder(\"Hola Mundo\");</code><code>sb.deleteCharAt(4);</code><code>// Salida: HolaMundo</code> <p>El siguiente ejemplo construimos un String concatenando 100 n\u00fameros mediante StringBuilder</p> <pre><code>public static void main(String[] args) {\n    int n = 100;\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"N\u00fameros de 1 al \")\n    sb.append(n);\n    sb.append(\": \");\n    for (int i = 0; i &lt; n; i++) {\n        sb.append(i).append(\" \");\n    }\n    System.out.println(sb.toString());\n}\n</code></pre>"},{"location":"ud4/8string/#formateo-de-cadenas-stringformat","title":"Formateo de cadenas: String.format","text":"<p>La clase String en Java incluye el m\u00e9todo est\u00e1tico String.format, que se utiliza para crear cadenas formateadas de manera eficiente. Este m\u00e9todo permite insertar valores en una cadena de texto seg\u00fan un formato especificado</p> <p>Sintaxis b\u00e1sica</p> <pre><code>String formattedString = String.format(String format, Object... args);\n</code></pre> <ul> <li>format: Especifica el patr\u00f3n de formato (con especificadores como %s, %d, %f).</li> <li>args: Lista de argumentos que se insertan en el patr\u00f3n.</li> </ul> <p><pre><code>public static void main(String[] args) {\n    double dinero=10.345;\n    String nombre=\"Juanito\";\n\n    String salida= String.format(\"%s tienes %.2f\u20ac en tu cuenta\",nombre,dinero);\n    System.out.println(salida);\n    //Juanito tienes 10,35\u20ac en tu cuenta\n}\n</code></pre> </p>"},{"location":"ud4/8string/#especificadores-comunes-en-stringformat","title":"Especificadores comunes en <code>String.format</code>","text":"Especificador Descripci\u00f3n Ejemplo Salida <code>%s</code> Representa una cadena de texto. <code>String.format(\"Hola %s\", \"Mundo\")</code> <code>Hola Mundo</code> <code>%d</code> Representa un n\u00famero entero en formato decimal. <code>String.format(\"N\u00famero: %d\", 42)</code> <code>N\u00famero: 42</code> <code>%f</code> Representa un n\u00famero en formato decimal (coma flotante). <code>String.format(\"Valor: %.2f\", 3.1416)</code> <code>Valor: 3.14</code> <code>%x</code> Representa un n\u00famero en formato hexadecimal (en min\u00fasculas). <code>String.format(\"Hex: %x\", 255)</code> <code>Hex: ff</code> <code>%X</code> Representa un n\u00famero en formato hexadecimal (en may\u00fasculas). <code>String.format(\"Hex: %X\", 255)</code> <code>Hex: FF</code> <code>%o</code> Representa un n\u00famero en formato octal. <code>String.format(\"Octal: %o\", 8)</code> <code>Octal: 10</code> <code>%%</code> Representa el car\u00e1cter <code>%</code>. <code>String.format(\"Progreso: 75%%\")</code> <code>Progreso: 75%</code> <code>%e</code> Representa un n\u00famero en notaci\u00f3n cient\u00edfica (min\u00fasculas). <code>String.format(\"Cient\u00edfico: %e\", 12345.6789)</code> <code>Cient\u00edfico: 1.234568e+04</code> <code>%E</code> Representa un n\u00famero en notaci\u00f3n cient\u00edfica (may\u00fasculas). <code>String.format(\"Cient\u00edfico: %E\", 12345.6789)</code> <code>Cient\u00edfico: 1.234568E+04</code> <code>%c</code> Representa un car\u00e1cter. <code>String.format(\"Letra: %c\", 'A')</code> <code>Letra: A</code> <code>%b</code> Representa un valor booleano (<code>true</code> o <code>false</code>). <code>String.format(\"Es v\u00e1lido: %b\", true)</code> <code>Es v\u00e1lido: true</code> <code>%,d</code> Formatea n\u00fameros enteros con separadores de miles (seg\u00fan la configuraci\u00f3n regional). <code>String.format(\"N\u00famero: %,d\", 1000000)</code> <code>N\u00famero: 1,000,000</code>"},{"location":"ud4/8string/#ejemplos","title":"Ejemplos","text":"<p>Ejemplo 1: Formatear texto y n\u00fameros <pre><code>double precio = 45.6789;\nString resultado = String.format(\"El precio es %.2f euros.\", precio);\nSystem.out.println(resultado);\n// Salida: El precio es 45.68 euros.\n</code></pre> Ejemplo 2: Formatear n\u00fameros decimales con precisi\u00f3n <pre><code>double precio = 45.6789;\nString resultado = String.format(\"El precio es %.2f euros.\", precio);\nSystem.out.println(resultado);\n// Salida: El precio es 45.68 euros.\n</code></pre> Ejemplo 3: Representaci\u00f3n en diferentes formatos <pre><code>int numero = 255;\nString resultado = String.format(\"Decimal: %d, Hexadecimal: %x, Octal: %o\", numero, numero, numero);\nSystem.out.println(resultado);\n// Salida: Decimal: 255, Hexadecimal: ff, Octal: 377\n</code></pre> Ejemplo 4: Crear una tabla tabulada <pre><code>public class Persona {\n    private String nombre;\n    private int edad;\n    private double altura;\n\n    // Constructores\n       //....\n    // Getters y setter\n    //....\n public static void main(String[] args) {\n        // Crear objetos Persona\n        Persona p1 = new Persona(\"Carlos\", 28, 1.75);\n        Persona p2 = new Persona(\"Ana\", 32, 1.62);\n        Persona p3 = new Persona(\"Luis\", 25, 1.80);\n\n        // Imprimir tabla tabulada\n        String formatoEncabezado=\"%-10s %-10s %-10s\";\n        String formatoFila=\"%-10s %-10d %-10.2f\";\n\n        System.out.println(String.format(formatoEncabezado, \"Nombre\", \"Edad\", \"Altura\"));\n        System.out.println(String.format(formatoFila, p1.getNombre(), p1.getEdad(), p1.getAltura()));\n        System.out.println(String.format(formatoFila, p2.getNombre(), p2.getEdad(), p2.getAltura()));\n        System.out.println(String.format(formatoFila, p3.getNombre(), p3.getEdad(), p3.getAltura()));\n    }\n}\n</code></pre> Salida:</p> <p></p>"},{"location":"ud5/1herencia/","title":"Herencia","text":"<p>Cuando tenemos una clase con una serie de caracter\u00edsticas  y nuestro programa se actualiza o amplia, tal vez se necesita de una clase con unas caracter\u00edsticas similares, como por ejemplo, Ordenador, posee un ram, cpu, tama\u00f1o de disco, etc.</p> <p>Si ahora queremos a\u00f1adir la clase Tablet Android en nuestro sistema, como posee todas esas caracter\u00edsticas de ordenador adem\u00e1s de algunas espec\u00edficas, copiar\u00edamos todo lo que hay en ordenador y agregar\u00edamos lo que fuera espec\u00edfico para Tablet. Lo mismo tendr\u00edamos que realizar si a\u00f1adi\u00e9ramos P\u00f3rtatil Mac. Como te habr\u00e1s dado cuenta, este proceso genera mucho c\u00f3digo repetido. Y arreglar un error en \u00e9l puede ser tambi\u00e9n complicado. Para ello utilizamos la herencia.</p> <p>\u00bfC\u00f3mo se relacionan las clases entre s\u00ed? En Java, y en cualquier otro lenguaje orientado a objetos, las clases se organizan en una jerarqu\u00eda de clases. Una jerarqu\u00eda de clases es como un \u00e1rbol al rev\u00e9s. En lo m\u00e1s alto de la jerarqu\u00eda se encuentra la clase m\u00e1s general, en Java, la clase <code>Object</code>. Las clases debajo de <code>Object</code> en la jerarqu\u00eda se conocen como sus subclases. Dado que todos los objetos que usamos en nuestros programas pertenecen a una clase u otra, esto es como decir que todos los objetos son <code>Object</code>.</p> <p></p> <p>En Java, todas las clases heredan de la clase <code>java.lang.Object</code>. La Figura muestra el concepto de jerarqu\u00eda de clases. Observa que la clase <code>Object</code> se encuentra en la parte superior de la jerarqu\u00eda. Es la clase m\u00e1s generalizada. Tiene caracter\u00edsticas que son comunes a todos los objetos Java. A medida que desciende en la jerarqu\u00eda, las clases se vuelven cada vez m\u00e1s espec\u00edficas. Un rect\u00e1ngulo es un objeto, pero contiene atributos (largo y ancho) que son comunes a todos los rect\u00e1ngulos, pero no a otros objetos de la jerarqu\u00eda. Por ejemplo, un objeto <code>Vehicle</code> no tiene necesariamente una longitud y una anchura.</p> <p>Tambi\u00e9n est\u00e1 la clase <code>Square</code> en la jerarqu\u00eda. Un <code>Square</code> (cuadrado) es un tipo especial de rect\u00e1ngulo, es decir, uno cuyo largo es igual a su ancho.</p>"},{"location":"ud5/1herencia/#superclase-y-subclase","title":"Superclase y subclase","text":"<p>Usando la terminolog\u00eda asociada con este tipo de jerarqu\u00eda, decimos que la clase <code>Rectangle</code> es una subclase de la clase <code>Object</code>. La clase <code>Square</code> es una subclase de <code>Rectangle</code> y <code>Object</code>. Se dice que las clases que se encuentran por encima de una clase dada en la jerarqu\u00eda son sus superclases.</p> <p>Por lo tanto, la clase <code>Rectangle</code> y tambi\u00e9n <code>Object</code> es una superclase de la clase <code>Square</code>.</p> <p>En general, decimos que una subclase extiende una superclase, lo que significa que agrega elementos adicionales (atributos y / o m\u00e9todos) a los contenidos en sus superclases. Como el caso de la clase <code>Square</code> que agrega la caracter\u00edstica de que su largo y ancho son siempre iguales.</p> <p>Hay tres conjuntos de terminolog\u00eda para describir las relaciones de herencia:</p> <ul> <li>padre / hijo</li> <li>clase base / clase derivada</li> <li>superclase / subclase</li> </ul> <p></p> <p>Herencia</p> <p>El concepto importante asociado con una jerarqu\u00eda de clases es la noci\u00f3n de herencia de clases, mediante la cual una subclase hereda elementos (atributos y / o m\u00e9todos, excepto el constructor) de sus superclases.</p> <p>Nota</p> <p>Los atributos y m\u00e9todos declarados como <code>private</code> se dice que no se heredan porque su visibilidad es privada y no se puede acceder desde la clase hija, pero si son heredados.</p> <p>Reutilizaci\u00f3n de c\u00f3digo</p> <p>Un t\u00e9rmino muy usado en herencia es reutilizaci\u00f3n. Como el propio nombre dice, reutilizar el c\u00f3digo repetido en los programas. Es un mecanismo para reutilizar el c\u00f3digo existente cuando creamos clases heredadas.</p> <p>Para ilustrar c\u00f3mo funciona la herencia pensemos en un framework para crear programas en sistemas operativos como puede ser Windows, y nos ofrece la clase Boton para ejecutar acciones por parte del usuario, si deseamos tener un bot\u00f3n en nuestra aplicaci\u00f3n que siempre que se pulse se oiga un pitido, no creamos un bot\u00f3n nuevo desde el principio, creamos el BotonSonido que herede del Boton general del framework que hereda todas sus caracter\u00edsticas y que amplio con la nueva funcionalidad. De esta forma, no tengo que crear de cero un nuevo bot\u00f3n con todas las caracter\u00edsticas ya programadas.</p> <p></p>"},{"location":"ud5/1herencia/#herencia-simple","title":"Herencia simple","text":"<p>En Java, solo se puede heredar de una clase. A esto se le llama herencia simple. Aunque algunos lenguajes de programaci\u00f3n permiten que una clase hija herede de m\u00e1s de una clase padre. A esto se le llama herencia m\u00faltiple. Con la herencia m\u00faltiple, a veces es dif\u00edcil saber qu\u00e9 padre contribuy\u00f3 con qu\u00e9 caracter\u00edsticas al hijo. Java evita estos problemas mediante el uso de herencia simple.</p> <p></p> <p>Una clase padre si puede tener m\u00faltiples hijos.</p> <p></p>"},{"location":"ud5/1herencia/#sintaxis-herencia-en-java-extends","title":"Sintaxis herencia en Java - extends","text":"<p>La sintaxis para heredar de una superclase es:</p> <pre><code>public class Child extends Parent {\n    // los nuevos miembros y constructores de la clase hija van aqu\u00ed\n}\n</code></pre> <p>Los miembros (variables y m\u00e9todos) de la clase padre se incluyen autom\u00e1ticamente en el hijo por herencia. Si se quieren agregar miembros adicionales en la clase hija se hace en su definici\u00f3n de clase.</p>"},{"location":"ud5/1herencia/#caracteristicas-de-las-clases-derivadas","title":"Caracter\u00edsticas de las clases derivadas","text":"<p>Importante</p> <ul> <li> <p>Una clase derivada hereda de la clase base sus componentes (atributos y m\u00e9todos).</p> </li> <li> <p>Los constructores no se heredan. Las clases derivadas deber\u00e1n implementar sus propios constructores. </p> </li> <li> <p>Una clase derivada puede acceder a los miembros p\u00fablicos y protegidos de la clase base como si fuesen miembros propios.</p> </li> <li> <p>Una clase derivada no tiene acceso a los miembros privados de la clase base. Deber\u00e1 acceder a trav\u00e9s de m\u00e9todos heredados de la clase base.</p> </li> <li> <p>Si se necesita tener acceso directo a los miembros privados de la clase base se deben declarar protected en lugar de private en la clase base.</p> </li> <li> <p>Una clase derivada puede a\u00f1adir a los miembros heredados, sus propios atributos y m\u00e9todos (extender la funcionalidad de la clase).</p> </li> <li> <p>Tambi\u00e9n puede modificar los m\u00e9todos heredados (especializar el comportamiento de la clase base).</p> </li> <li> <p>Una clase derivada puede volver a declarar un atributo heredado (atributo public o protected en la clase base). En este caso, el atributo de la clase base queda oculto por el de la clase derivada</p> </li> <li> <p>Una clase derivada puede, a su vez, ser una clase base, dando lugar a una jerarqu\u00eda de clases.</p> </li> </ul>"},{"location":"ud5/1herencia/#modificadores-de-acceso-en-java","title":"Modificadores de acceso en Java","text":"<p>Una clase derivada podr\u00e1 acceder a los miembros de su padre seg\u00fan el modificador</p> <p></p>"},{"location":"ud5/1herencia/#package-y-metodos-de-acceso","title":"Package y m\u00e9todos de acceso","text":"<p>Un paquete en Java se utiliza para agrupar clases relacionadas de acuerdo con alg\u00fan criterio l\u00f3gico. Cuando el proyecto a desarrollar contiene demasiadas clases es recomendable dividir el sistema en paquetes.</p> <p>En Java los paquetes se dividen en:</p> <ul> <li>Propios de Java incorporados en la API de Java</li> <li>Definidos por el usuario</li> </ul> <p>Se definen de la siguiente manera</p> <p><pre><code>package nombrePaquete;\nclass nombreClase {\n . . . \n}\n</code></pre> Respecto a la herencia, hay que tener en cuenta:</p> <ul> <li>Una subclase puede acceder a todos los atributos  protegidos de su clase padre, sin importar en qu\u00e9 paquete est\u00e9 la subclase</li> <li>Una clase  en el mismo paquete puede acceder a los atributos  protegidos de otra clase clase</li> <li>Una clase  en el distinto paquete no puede acceder a los atributos  protegidos de otra clase clase</li> </ul>"},{"location":"ud5/1herencia/#constructores-y-herencia-en-java-constructores-en-clases-derivadas","title":"Constructores y herencia en Java. Constructores en clases derivadas","text":"<p>Los constructores no se heredan. Cada clase derivada tendr\u00e1 sus propios constructores. La clase base es la encargada de inicializar sus atributos. La clase derivada se encarga de inicializar solo los suyos. Cuando se crea un objeto de una clase derivada se ejecutan los constructores en este orden:</p> <ol> <li>Primero se ejecuta el constructor de la clase base.</li> <li>Despu\u00e9s se ejecuta el constructor de la clase derivada.</li> </ol> <pre><code>public class Persona {\n    private String nif;\n    private String nombre;\n    public Persona() {\n        System.out.println(\"Ejecutando el constructor de Persona...\");\n    }\n/* Resto de m\u00e9todos */\n}\npublic class Alumno extends Persona{\n    private String curso;\n    public Alumno() {\n        System.out.println(\"Ejecutando el constructor de Alumno...\");\n    }\n/* Resto de m\u00e9todos */\n}\n</code></pre> <p>Si creamos una instancia de Alumno</p> <p><pre><code>Alumno pepito=new Alumno();\n</code></pre> Cuando se invoca al constructor de la clase Alumno se invoca autom\u00e1ticamente al constructor de la clase Persona y despu\u00e9s contin\u00faa la ejecuci\u00f3n del constructor de la clase Alumno. </p> <p>Muesta por pantalla</p> <pre><code>Ejecutando el constructor de Persona...\nEjecutando el constructor de Alumno...\n</code></pre>"},{"location":"ud5/1herencia/#ejemplo-clase-animal","title":"Ejemplo clase Animal","text":"<p>Vamos a crear una clase base <code>Animal</code> que tendr\u00e1 una serie de caracter\u00edsticas comunes para todos los animales como puede ser, nombre, peso, tama\u00f1o, etc.</p> <pre><code>public class Animal {\n\n    private String name;\n    private int size;\n    private int weight;\n\n    public Animal(String name, int size, int weight) {\n        this.name = name;\n        this.size = size;\n        this.weight = weight;\n        System.out.println(\"Ejecutando el constructor de Animal...\");\n    }\n\n    //getters y setters\n}\n</code></pre> <p>Ahora queremos crear un tipo de animal <code>Dog</code> que contendr\u00e1 todas las caracter\u00edsticas (atributos y m\u00e9todos) de la clase <code>Animal</code>:</p> <p></p> <pre><code>public class Dog extends Animal {\n\n}\n</code></pre> <p>Cuando creamos una subclase, necesitamos llamar al constructor de la superclase para inicializarla, ya que hereda de ella. As\u00ed que tendremos que crear el constructor en la clase <code>Dog</code> que llame dentro al constructor de la superclase (<code>Animal</code>):</p> <pre><code>public class Dog extends Animal {\n\n    public Dog(String name, int size, int weight) {\n        //llamada al constructor de Animal\n        super(name, size, weight);\n    }\n}\n</code></pre> <p>Al crear una clase hija <code>Dog</code> que hereda de la clase padre <code>Animal</code>, lo que estamos haciendo es heredar todo su comportamiento (atributos y m\u00e9todos) y adem\u00e1s nos permite a\u00f1adir atributos espec\u00edficos y \u00fanicos para esa clase hija que son particulares de los perros y no comunes o aplicables a todos los animales.</p>"},{"location":"ud5/1herencia/#super","title":"Super","text":"<p>La palabra reservada <code>super</code> se utiliza para llamar al constructor de la clase de la que estamos heredando, es decir, llamar a la clase padre o superclase. En nuestro caso, para invocar al constructor de la superclase <code>Animal</code>. Esto nos permite inicializar la clase <code>Animal</code>, ya que <code>Dog</code> es una clase derivada que se basa en ella.</p> <p>Importante</p> <ul> <li>La primera l\u00ednea dentro del constructor de la clase hija debe ser la llamada al constructor padre con super(). <pre><code>public Persona{\n    public String nombre;\n}\n\npublic class Alumno extends Persona{\n    String curso;\n    public Alumno(String nombre, String curso) {\n        super(); //esta instrucci\u00f3n se ejecuta siempre. No es necesario escribirla\n        this.nombre=nombre;\n        this.curso=curso;\n        System.out.println(\"Ejecutando el constructor de Alumno\");\n    }\n}\n</code></pre></li> <li>Si no se especifica expl\u00edcitamente entonces el compilador Java llama por defecto a super();, es decir, al constructor por defecto (sin argumentos) de la clase padre <pre><code>public class Alumno extends Persona{\n    String curso;\n    //no es necesario llamar a super(), lo llama el compilador\n    public Alumno(String nombre, String curso) {  \n        this.nombre=nombre;\n        this.curso=curso;\n        System.out.println(\"Ejecutando el constructor de Alumno\");\n    }\n}\n</code></pre></li> <li>Si se proporciona un constructor con par\u00e1metros en una clase, el compilador de Java no crear\u00e1 autom\u00e1ticamente el constructor sin par\u00e1metros. El siguiente c\u00f3digo es err\u00f3neo: <pre><code>public Persona{\n    public String nombre;\n    public Persona(String nombre) {\n        this.nombre = nombre;\n        System.out.println(\"Ejecutando el constructor de Persona..\");\n    }\n}\n\npublic class Alumno extends Persona{\n    String curso;\n    //ERROR: es necesario llamar al constructor del padre\n    public Alumno(String nombre, String curso) {                    \n        this.nombre=nombre;\n        this.curso=curso;\n        System.out.println(\"Ejecutando el constructor de Alumno\");\n    }\n}\n</code></pre> El constructor de Alumno tendr\u00eda que ser como sigue <pre><code>    public Alumno(String nombre, String curso) {                    \n        Persona(nombre);\n        this.curso=curso;\n        System.out.println(\"Ejecutando el constructor de Alumno..\");\n    }\n}\n</code></pre></li> </ul> <p>En la clase hija vamos a crear algunos campos espec\u00edficos para los perros como ojos, piernas, etc. Porque recuerda que no todos los animales tienen piernas u ojos pero si todos los perros.</p> <p></p> <p>Adem\u00e1s de los campos que se necesitan para crear un objeto <code>Animal</code>, tambi\u00e9n hay que inicializar los campos propios de la clase <code>Dog</code> en el constructor:</p> <pre><code>public class Dog extends Animal {\n\n    private int eyes;\n    private int legs;\n    private int tail;\n\n    public Dog(String name, int size, int weight, int eyes, int legs, int tail) {\n        super(name, size, weight);//llama al constructor de Animal\n        this.eyes = eyes;\n        this.legs = legs;\n        this.tail = tail;\n        System.out.println(\"Ejecutando el constructor de Dog...\");\n    }\n}\n</code></pre> <p>En la clase base, vamos a a\u00f1adir comportamiento, que ser\u00e1 com\u00fan para todos los animales: comer y moverse</p> <p></p> <pre><code>public class Animal {\n\n    private String name;\n    private int size;\n    private int weight;\n\n    public Animal(String name, int size, int weight) {\n        this.name = name;\n        this.size = size;\n        this.weight = weight;\n        System.out.println(\"Ejecutando el constructor de Alumno...\");\n\n    }\n\n    public void eat() {\n        System.out.println(\"comiendo animal...\"+name);\n\n    }\n\n    public void move() {\n        System.out.println(\"se mueve el animal...\"+name);\n    }\n}\n</code></pre> <p>Al hacer esto, y crearlos como <code>public</code> (<code>protected</code> tambi\u00e9n servir\u00eda), significa que ahora est\u00e1n disponibles en la clase <code>Dog</code> autom\u00e1ticamente. Es decir, el m\u00e9todo <code>eat</code> y <code>move</code> se hereda a la clase <code>Dog</code>.</p> <pre><code>public static void main(String[] args) {\n\n    Dog dog = new Dog(\"Maxi\", 2, 5, 2, 4, 1);\n    //llamamos al m\u00e9todo eat que existe en la clase padre\n    dog.eat();\n\n}\n</code></pre> <p>muestra</p> <p>comiendo animal...Maxi</p>"},{"location":"ud5/1herencia/#sobrescribir-metodosoverride","title":"Sobrescribir m\u00e9todos(@Override)","text":"<p>La herencia nos aporta la opci\u00f3n de la sobrescritura de m\u00e9todos. Es decir, redefinir los m\u00e9todos de una clase padre en las clases hijas con su propia funcionalidad.</p>"},{"location":"ud5/1herencia/#llamar-a-metodo-en-una-clase-derivada","title":"Llamar a m\u00e9todo en una clase derivada","text":"<p>Importante</p> <p>Cuando se invoca un m\u00e9todo de una clase en una jerarqu\u00eda de clases sucede lo siguiente</p> <ol> <li>Se busca en su clase el m\u00e9todo correspondiente.</li> <li>Si no se encuentra, se busca en su clase base.</li> <li>Si no se encuentra, se sigue buscando hacia arriba en la jerarqu\u00eda de clases hasta que el m\u00e9todo se encuentra.</li> <li>Si al llegar a la clase ra\u00edz el m\u00e9todo no se ha encontrado se producir\u00e1 un error.</li> </ol> <p>Por ejemplo, en la clase <code>Dog</code> podemos sobrescribir el m\u00e9todo <code>eat()</code> con una funcionalidad m\u00e1s espec\u00edfica.</p> <pre><code>public class Dog extends Animal {\n\n    private int eyes;\n    private int legs;\n    private int tail;\n\n    public Dog(String name, int size, int weight, int eyes, int legs, int tail) {\n        super(name, size, weight);//llama al constructor de Animal\n        this.eyes = eyes;\n        this.legs = legs;\n        this.tail = tail;\n        System.out.println(\"Ejecutando el constructor de Dog...\");\n    }\n    @Override\n    public void eat(){\n        System.out.println(\"El dog \"+name+\" est\u00e1 comiendo...\");\n    }\n}\n</code></pre>"},{"location":"ud5/1herencia/#sobrecarga-vs-sobrescritura","title":"Sobrecarga vs Sobrescritura","text":"<p>Sobrecarga</p> <p>No confundir con el concepto de sobrecarga en la que en una clase tenemos varios m\u00e9todos con el mismo nombre pero diferentes par\u00e1metros <pre><code>    //m\u00e9todo sumar 2 par\u00e1metros\n    public int sumar(int m1, int m2) {\n        return m1+m2;\n    }\n\n    //m\u00e9todo sumar 3 par\u00e1metros\n    public int sumar(int m1, int m2, int m3) {\n        return m1+m2+m3;\n    }\n</code></pre></p>"},{"location":"ud5/1herencia/#intellij-y-override","title":"IntelliJ y Override","text":"<p>El IntelliJ nos ofrece un atajo para sobrescritura de m\u00e9todos. </p> <p>Bot\u00f3n derecho \u2192 Generate...</p> <p></p> <p></p> <p>IntelliJ nos muestra todos los m\u00e9todos que est\u00e1n en la clase <code>Animal</code> y podemos sobrescribir:</p> <p></p> <p>Si seleccionamos el m\u00e9todo <code>eat()</code>, tenemos:</p> <pre><code>public class Dog extends Animal {\n\n    private int eyes;\n    private int legs;\n    private int tail;\n\n    public Dog(String name, int size, int weight, int eyes, int legs, int tail) {\n        super(name, size, weight);\n        this.eyes = eyes;\n        this.legs = legs;\n        this.tail = tail;\n    }\n\n    @Override\n    public void eat() {\n        super.eat();//C\u00f3digo que se crea autom\u00e1ticamente y llama al m\u00e9todo eat de la clase padre\n    }\n}\n</code></pre> <p>Ahora la clase hija <code>Dog</code> tiene su propio m\u00e9todo <code>eat()</code> con c\u00f3digo espec\u00edfico para esta clase.</p> <pre><code>public class Dog extends Animal {\n\n    private int eyes;\n    private int legs;\n    private int tail;\n\n    public Dog(String name, int years, int weight, int eyes, int legs, int tail) {\n        super(name, years, weight);\n        this.eyes = eyes;\n        this.legs = legs;\n        this.tail = tail;\n    }\n\n    //M\u00e9todo privado solo de la clase Dog\n    private void chew() {\n\n    }\n\n    @Override\n    public void eat() {\n        System.out.println(\"El dog \"+name+\" est\u00e1 comiendo...\");\n\n    }\n}\n</code></pre>"},{"location":"ud5/1herencia/#clases-finales","title":"Clases Finales","text":"<p>Si queremos evitar que una clase tenga clases derivadas debe declararse con el modificador final delante de class: <pre><code>public final class Dog{\n\u2026 \n}\n</code></pre></p> <p>Esto la convierte en clase final. Una clase final no se puede heredar. Si intentamos crear una clase derivada de Dog se producir\u00e1 un error de compilaci\u00f3n:</p> <pre><code>//producir\u00e1 un error de compilaci\u00f3n\npublic  class Chiguagua extends Dog{\n\u2026 \n}\n</code></pre>"},{"location":"ud5/1thisvssuper/","title":"This vs Super","text":"<ul> <li> <p>La palabra reservada super se usa para acceder a los miembros (atributos y m\u00e9todos) de la clase padre.</p> </li> <li> <p>La palabra reservada this se utiliza para acceder a los miembros (atributos y m\u00e9todos) de la clase actual en la que se usa.</p> </li> </ul> <p>Importante</p> <p>Las dos palabras pueden usarse en cualquier lugar excepto en bloques de c\u00f3digo est\u00e1tico.</p>"},{"location":"ud5/1thisvssuper/#this","title":"This","text":"<p><code>this</code> es generalmente usada en constructores y en los m\u00e9todos setters, y opcionalmente en los getters ya que no tenemos par\u00e1metro de entrada con el mismo nombre:</p> <pre><code>public class Coche {\n\n    private int ruedas;\n\n    public Coche(int ruedas) {\n        this.ruedas = ruedas;\n    }\n\n    public void setRuedas(int ruedas) {\n        this.ruedas = ruedas;\n    }\n\n    public int getRuedas() {\n        return ruedas;\n    }\n}\n</code></pre>"},{"location":"ud5/1thisvssuper/#super","title":"Super","text":"<p><code>super</code> es generalmente usada en sobreescritura de m\u00e9todos al usar herencia. Es decir, se utiliza para llamar desde las clases hijas al m\u00e9todo con el mismo nombre en la clase padre.</p> <pre><code>    @Override\n    public void eat() {\n        System.out.println(\"Dog eat\");\n        chew();\n        super.eat();\n    }\n</code></pre> <p>Sin la palabra reservada <code>super</code>, se producir\u00eda una llamada recursiva al mismo m\u00e9todo de forma infinita.</p>"},{"location":"ud5/1thisvssuper/#this_1","title":"this()","text":"<p>Usamos <code>this()</code> en forma de m\u00e9todo dentro del cuerpo de un constructor cuando queremos invocar a otro constructor sobrecargado dentro de la misma clase. <code>this()</code> solo puede usarse en un constructor; y debe de ser la primera sentencia que aparece en el constructor.</p>"},{"location":"ud5/1thisvssuper/#super_1","title":"super()","text":"<p>Usamos <code>super()</code> en forma de m\u00e9todo dentro del cuerpo de un constructor cuando queremos invocar a un constructor de la clase padre. <code>super()</code> solo puede usarse en un constructor; y debe de ser la primera sentencia que aparece en el constructor.</p> <p>Recordemos que el compilador de Java agrega de forma autom\u00e1tica la sentencia <code>super()</code> en el constructor de la clase hija si nosotros no lo a\u00f1adimos.</p> <p>Nota</p> <p>Un constructor puede tener las sentencias <code>this()</code> o <code>super()</code> pero nunca ambas.</p> <p></p> <p>En el siguiente ejemplo, usamos las dos sentencias:</p> <pre><code>class Transporte {\n\n    private int puertas;\n    private int precio;\n\n    public Transporte(int puertas, int precio) {\n        this.puertas = puertas;\n        this.precio = precio;\n    }\n}\n\npublic class Coche extends Transporte {\n\n    private String modelo;\n    private String marca;\n\n    public Coche(String modelo, String marca) {\n        //llama al constructor de abajo\n        this(0,0,modelo,marca);\n    }\n\n    public Coche(int puertas, int precio, String modelo, String marca) {\n        //llama al constructor padre\n        super(puertas, precio);\n        this.modelo = modelo;\n        this.marca = marca;\n    }\n}\n</code></pre>"},{"location":"ud5/1xclaseobject/","title":"Clase Object","text":"<p>Como ya indicamos en el tema introductorio de POO, la clase Object es una clase especial de la que heredan todas la clases en Java. Es la superclase que se sit\u00faa en la c\u00faspide de la estructura de herencias entre clases</p> <p></p> <p>La siguiente clase</p> <pre><code>class Vehiculo{\n    . . .\n}\n</code></pre> <p>en realidad  equivale a</p> <pre><code>class Vehiculo extends Object{\n    String tipo;\n    String color;\n    . . .\n}\n</code></pre> <p>La clase Object tiene una serie de m\u00e9todos que todas las clases heredan por defecto</p> <p></p>"},{"location":"ud5/1xclaseobject/#metodo-tostring","title":"M\u00e9todo toString()","text":"<p>El m\u00e9todo toString() es un m\u00e9todo de la clase Object que se puede sobrescribir en cualquier clase para proporcionar una representaci\u00f3n de cadena (String) significativa de la instancia de esa clase</p> <p>Por defecto, la implementaci\u00f3n en la clase Object devuelve una cadena que consiste en el nombre de la clase seguido por el signo \"@\" y la representaci\u00f3n hexadecimal del valor del identificador del objeto en memoria</p> <p><pre><code>public  static void main(String[] args){\n    Vehiculo coche=New Vehiculo(\"coche\",\"rojo\");\n    //imprime algo parecido a: Vehiculo@2a139b44\n    System.out.println(coche.toString());\n}\n</code></pre> Sin embargo, este comportamiento predeterminado suele ser insuficiente para representar de manera \u00fatil la informaci\u00f3n de un objeto.</p> <p>Al sobrescribir el m\u00e9todo toString() en una clase espec\u00edfica, puedes proporcionar una representaci\u00f3n m\u00e1s significativa y personalizada del objeto en forma de cadena.</p> <pre><code>    class Vehiculo extends Object{\n    String tipo;\n    String color;\n   // Constructor y m\u00e9todos de la clase . . .\n\n   // Sobrescribir el m\u00e9todo toString para proporcionar una representaci\u00f3n significativa\n    @Override\n    public String toString() {\n        return \"Vehiculo {tipo='\" + tipo + \"', color=\" + color + \"}\";\n    }\n}\n</code></pre> <p>Cuando es necesaria una transformaci\u00f3n a String, Java llama autom\u00e1ticamente al m\u00e9todo toString(), por lo que puedes simplemente usar:</p> <pre><code>    System.out.println(coche);\n</code></pre>"},{"location":"ud5/1xclaseobject/#metodo-equals","title":"M\u00e9todo equals()","text":"<p>En Java, el m\u00e9todo equals() se utiliza para comparar la igualdad de dos objetos. Este m\u00e9todo est\u00e1 definido en la clase Object, que es la clase base para todas las clases en Java. Sin embargo, es com\u00fan que las clases personalizadas sobrescriban este m\u00e9todo para proporcionar una implementaci\u00f3n espec\u00edfica de la igualdad entre dos objetos de la misma clase.</p> <p>La firma del m\u00e9todo equals() en la clase Object es la siguiente:</p> <p><pre><code> public boolean equals(Object obj)\n</code></pre> Por ejemplo:</p> <p>Para una clase Persona en la que queremos determinar que dos personas son iguales si su dni es igual</p> <p><pre><code>public class Persona {\n    private String nombre;\n    private String dni;\n\n    // Constructor y otros m\u00e9todos de la clase\n\n    // Sobrescribir el m\u00e9todo equals para comparar personas por su DNI\n    @Override\n    public boolean equals(Object obj) {\n       // Verificar si es el mismo objeto\n        if (this == obj) {\n            return true;\n        }\n\n        // Verificar si el objeto no es nulo y pertenece a la misma clase\n        if (obj == null || getClass() != obj.getClass()) {\n            return false;\n        }\n\n        // Convertir el objeto a la misma clase y comparar DNI\n        Persona otraPersona = (Persona) obj;\n        return dni.equals(otraPersona.dni);\n    }\n}\n</code></pre> Podemos comparar los objeto <pre><code>public static void main(String[] args) {\n        Persona juan = new Persona(\"Juan\", \"12345678A\");\n        Persona maria = new Persona(\"Maria\", \"87654321B\");\n        Persona juanito = new Persona(\"Juanito\", \"12345678A\");\n\n        // Comprobando la igualdad\n        System.out.println(\"persona1 equals persona2: \" + juan.equals(maria)); // false\n        //el dni es el mismo\n        System.out.println(\"persona1 equals persona3: \" + juan.equals(juanito)); // true\n    }\n</code></pre></p>"},{"location":"ud5/1xclaseobject/#equals-vs","title":"'equals' vs '=='","text":"<p>Es importante tener en cuenta, que una variable que instancia a un objeto, tiene la direcci\u00f3n a dicho objeto. Por lo que si dos variables se comparan con ==, nos dar\u00e1 true si la direcci\u00f3n en la misma y no su contenido.</p> <p></p> <pre><code>Alumno a=new Alumno(\"Maria\");\nAlumno c=new Alumno(\"Maria\");\nAlumno b=a;\n\nSystem.out.println(a.equals(c)); // true\nSystem.out.println(a==b); // true\nSystem.out.println(a==c); // false\n</code></pre>"},{"location":"ud5/1xclaseobject/#importancia-de-sobrescribir-equals","title":"Importancia de sobrescribir 'equals'","text":"<p>Otras clases utilizan equals para comparar si sus elementos son iguales, por ejemplo, el m\u00e9todo Arrays.equals o indexOf de la clase ArrayList</p> <pre><code>public static void main(String[] args) {\n        Persona persona1 = new Persona(\"Juan\", \"12345678A\");\n        Persona persona2 = new Persona(\"Maria\", \"87654321B\");\n        Persona persona3 = new Persona(\"Juanito\", \"12345678A\");\n\n        // Comprobando la igualdad usando el m\u00e9todo equals de Persona\n        System.out.println(\"persona1 equals persona2: \" + persona1.equals(persona2)); // false\n        System.out.println(\"persona1 equals persona3: \" + persona1.equals(persona3)); // true\n\n        // Creando arrays de Personas\n        Persona[] array1 = {persona1, persona2};\n        Persona[] array2 = {persona3, new Persona(\"Marieta\", \"87654321B\")};\n\n        // Comprobando la igualdad de los arrays usando Arrays.equals\n        System.out.println(\"Arrays.equals(array1, array2): \" + Arrays.equals(array1, array2)); // true\n\n    }\n</code></pre>"},{"location":"ud5/1xclaseobject/#intellij-y-equals","title":"IntelliJ y equals()","text":"<p>IntelliJ nos permite generar autom\u00e1ticamente el m\u00e9todo equals junto a hashCode(necesario para ciertas clases)</p> <p></p>"},{"location":"ud5/1xclaseobject/#conclusion","title":"Conclusi\u00f3n","text":"<p>Debemos sobrescribir siempre los m\u00e9todos toString y equals en nuestras clases para permitir imprimir el contenido de la clase y poder comparar objetos de la misma clase</p>"},{"location":"ud5/2composicion/","title":"Composici\u00f3n","text":"<p>La composici\u00f3n es otro componente de la programaci\u00f3n orientada a objetos y es muy utilizada.</p> <p>Es el mecanismo en el cual una clase se construye a partir de otros objetos de igual o distinto tipo, pudi\u00e9ndolos combinar para obtener la funcionalidad deseada. En la composici\u00f3n la nueva clase, mantiene una relaci\u00f3n \u201cUsa/Tiene un\u201d, con los objetos que son parte de la clase.</p> <p>Vamos a ver un ejemplo de la clase <code>Car</code> que extiende <code>Vehicle</code>:</p> <p></p> <pre><code>public class Vehicle {\n\n    private String name;\n}\n\npublic class Car extends Vehicle {\n\n    private int doors;\n    private int seats;\n\n    public Car(int doors, int seats) {\n        this.doors = doors;\n        this.seats = seats;\n    }\n}\n</code></pre> <p>Estas dos clases tienen una relaci\u00f3n de herencia, el significado es que un coche es un veh\u00edculo.</p> <p>Pero la composici\u00f3n es diferente a la herencia tambi\u00e9n es un tipo de relaci\u00f3n. Por ejemplo, pensemos en un ordenador. Un ordenador se compone de una CPU, pantalla, rat\u00f3n y teclado. Pero una pantalla no es un ordenador, un rat\u00f3n no es un ordenador. Decimos que un ordenador tiene una pantalla, un ordenador tiene un teclado, etc. Eso es la composici\u00f3n, un todo que se construye con partes.</p> <p>Vamos a ver como se implementa esto:</p> <pre><code>public class Procesador {\n\n    private String modelo;\n    private int ramSlots;\n    private int cardSlots;\n\n    public Procesador(String modelo, int ramSlots, int cardSlots) {\n        this.modelo = modelo;\n        this.ramSlots = ramSlots;\n        this.cardSlots = cardSlots;\n    }\n\n    public void presionarBotonEncendido() {\n        System.out.println(\"Iniciando el pc\");\n    }\n\n    public void cargarPrograma(String nombre) {\n        System.out.println(nombre);\n    }\n\n    public String getModelo() {\n        return modelo;\n    }\n\n    public void setModelo(String modelo) {\n        this.modelo = modelo;\n    }\n\n    public int getRamSlots() {\n        return ramSlots;\n    }\n\n    public void setRamSlots(int ramSlots) {\n        this.ramSlots = ramSlots;\n    }\n\n    public int getCardSlots() {\n        return cardSlots;\n    }\n\n    public void setCardSlots(int cardSlots) {\n        this.cardSlots = cardSlots;\n    }\n}\n\npublic class Monitor {\n\n    private String modelo;\n    private String resolucion;\n    private int tam;\n\n    public Monitor(String modelo, String resolucion, int tam) {\n        this.modelo = modelo;\n        this.resolucion = resolucion;\n        this.tam = tam;\n    }\n\n    public void dibujarPixel(int x, int y) {\n        System.out.println(\"Pixel en \" + x + y);\n    }\n\n    public String getModelo() {\n        return modelo;\n    }\n\n    public void setModelo(String modelo) {\n        this.modelo = modelo;\n    }\n\n    public String getResolucion() {\n        return resolucion;\n    }\n\n    public void setResolucion(String resolucion) {\n        this.resolucion = resolucion;\n    }\n\n    public int getTam() {\n        return tam;\n    }\n\n    public void setTam(int tam) {\n        this.tam = tam;\n    }\n}\n\npublic class Teclado {\n\n    private String color;\n    private int teclas;\n\n    public Teclado(String color, int teclas) {\n        this.color = color;\n        this.teclas = teclas;\n    }\n\n    public void pushKey(char key) {\n        System.out.println(\"Se ha presionado la tecla \" + key);\n    }\n\n    public String getColor() {\n        return color;\n    }\n\n    public void setColor(String color) {\n        this.color = color;\n    }\n\n    public int getTeclas() {\n        return teclas;\n    }\n\n    public void setTeclas(int teclas) {\n        this.teclas = teclas;\n    }\n}\n</code></pre> <p>Hemos creado las clases <code>Monitor</code>, <code>Teclado</code> y <code>Procesador</code>. Ahora vamos a crear una clase <code>Ordenador</code> que se compondr\u00e1 de las otras tres clases de la forma:</p> <p></p> <pre><code>public class Ordenador {\n\n    private Procesador procesador;\n    private Teclado teclado;\n    private Monitor monitor;\n\n    public Ordenador(Procesador procesador, Teclado teclado, Monitor monitor) {\n        this.procesador = procesador;\n        this.teclado = teclado;\n        this.monitor = monitor;\n    }\n\n    public Procesador getProcesador() {\n        return procesador;\n    }\n\n    public void setProcesador(Procesador procesador) {\n        this.procesador = procesador;\n    }\n\n    public Teclado getTeclado() {\n        return teclado;\n    }\n\n    public void setTeclado(Teclado teclado) {\n        this.teclado = teclado;\n    }\n\n    public Monitor getMonitor() {\n        return monitor;\n    }\n\n    public void setMonitor(Monitor monitor) {\n        this.monitor = monitor;\n    }\n}\n</code></pre> <p>Ya hemos implementado nuestras clases que componen un <code>Ordenador</code>. Ahora vamos a ver como utilizarlas:</p> <pre><code>public class Main {\n\n    public static void main(String[] args) {\n        Procesador procesador = new Procesador(\"Intel\", 2, 3);\n        Monitor monitor = new Monitor(\"Philips\", \"1024x900\", 24);\n        Teclado teclado = new Teclado(\"Negror\",90);\n\n        Ordenador ordenador = new Ordenador(procesador, teclado, monitor);\n    }\n}\n</code></pre> <p>Se ha creado un objeto de la clase <code>Ordenador</code> a partir de las otras clases. En herencia ten\u00edamos acceso a los atributos de la clase padre, pero ahora con composici\u00f3n para acceder a los m\u00e9todos o atributos de las partes a partir de <code>Ordenador</code> lo haremos usando los m\u00e9todos getters que tenemos en la clase y nos permite acceder a <code>Teclado</code>, <code>Monitor</code> y <code>Procesador</code>.</p> <pre><code>    public static void main(String[] args) {\n        Procesador procesador = new Procesador(\"Intel\", 2, 3);\n        Monitor monitor = new Monitor(\"Philips\", \"1024x900\", 24);\n        Teclado teclado = new Teclado(\"Negror\",90);\n\n        Ordenador ordenador = new Ordenador(procesador, teclado, monitor);\n        ordenador.getMonitor().dibujarPixel(34, 56);\n        ordenador.getProcesador().cargarPrograma(\"Demo\");\n        ordenador.getTeclado().pushKey('X');\n    }\n</code></pre>"},{"location":"ud5/2composicion/#ocultar-funcionalidad-de-los-objetos-parte","title":"Ocultar funcionalidad de los objetos parte","text":"<p>Otro escenario viable es el cual nos permita ocultar la funcionalidad, y no le permitamos al programa acceder directamente a los objetos que componen el todo. Para ello, lo primero que haremos ser\u00e1 modificar la visibilidad de los getters y ponerlos <code>private</code>, de manera que no se pueda acceder desde fuera a <code>Teclado</code>, <code>Monitor</code> o <code>Procesador</code> pero si podamos acceder internamente.</p> <pre><code>public class Ordenador {\n\n    private Procesador procesador;\n    private Teclado teclado;\n    private Monitor monitor;\n\n    public Ordenador(Procesador procesador, Teclado teclado, Monitor monitor) {\n        this.procesador = procesador;\n        this.teclado = teclado;\n        this.monitor = monitor;\n    }\n\n    private Procesador getProcesador() {\n        return procesador;\n    }\n\n    private Teclado getTeclado() {\n        return teclado;\n    }\n\n    private Monitor getMonitor() {\n        return monitor;\n    }\n}\n</code></pre> <p>Una vez oculta la informaci\u00f3n veamos como podemos acceder a ella en el main. Creamos un m\u00e9todo en la clase <code>Ordenador</code> que acceder\u00e1 a las distintas partes.</p> <pre><code>public class Ordenador {\n\n    private Procesador procesador;\n    private Teclado teclado;\n    private Monitor monitor;\n\n    public Ordenador(Procesador procesador, Teclado teclado, Monitor monitor) {\n        this.procesador = procesador;\n        this.teclado = teclado;\n        this.monitor = monitor;\n    }\n\n    public void encender() {\n        getProcesador().presionarBotonEncendido();\n        dibujarLogo();\n    }\n\n    private void dibujarLogo() {\n        monitor.dibujarPixel(12, 23);\n    }\n\n    private Procesador getProcesador() {\n        return procesador;\n    }\n\n    private Teclado getTeclado() {\n        return teclado;\n    }\n\n    private Monitor getMonitor() {\n        return monitor;\n    }\n}\n</code></pre> <p>En el <code>main</code> accederemos a este m\u00e9todo:</p> <pre><code>    public static void main(String[] args) {\n        Procesador procesador = new Procesador(\"Intel\", 2, 3);\n        Monitor monitor = new Monitor(\"Philips\", \"1024x900\", 24);\n        Teclado teclado = new Teclado(\"Negror\",90);\n\n        Ordenador ordenador = new Ordenador(procesador, teclado, monitor);\n        ordenador.encender();\n    }\n</code></pre>"},{"location":"ud5/3encapsulacion/","title":"Encapsulaci\u00f3n","text":"<p>El mecanismo que permite restringir el acceso a componentes en los objetos, es decir, ofrece protecci\u00f3n a los miembros de la clase de cualquier acceso externo no autorizado es la encapsulaci\u00f3n. No estamos hablando de seguridad, hablamos m\u00e1s bien, de restringir el acceso desde fuera al funcionamiento interno de una clase, es decir, ocultar el trabajo interno que se realiza en una clase.</p> <p>Veamos un ejemplo de una clase que no usa encapsulaci\u00f3n y as\u00ed nos permitir\u00e1 entender mejor porqu\u00e9 la encapsulaci\u00f3n en algo positivo. Luego veremos c\u00f3mo se har\u00eda con encapsulaci\u00f3n.</p>"},{"location":"ud5/3encapsulacion/#ejemplo-de-programa-sin-encapsulacion","title":"Ejemplo de programa SIN encapsulaci\u00f3n","text":""},{"location":"ud5/3encapsulacion/#acceso-a-la-clase-y-modificacion-de-funcionalidad","title":"Acceso a la clase y modificaci\u00f3n de funcionalidad","text":"<p>Primero creamos una clase <code>Player</code> con los siguiente campos:</p> <p></p> <pre><code>public class Player {\n    //propiedades p\u00fablicas\n    public String name;\n    public int health;\n    public String weapon;\n\n    public void applyDamage(int damage) {\n        this.health -= damage;\n        if (this.health &lt;= 0 ) {\n            System.out.println(\"Player died\");\n        }\n    }\n\n    public int getActualHealth() {\n        return health;\n    }\n}\n</code></pre> <p>Ahora implementamos el <code>main</code> en otra clase:</p> <pre><code>public class Main {\n\n    public static void main(String[] args) {\n        Player player = new Player();\n        player.name = \"Patricia\";\n        player.health = 50;\n        player.weapon = \"flamethrower\";\n\n        int damage = 30;\n        player.applyDamage(damage);\n        System.out.println(\"The actual health is \" + player.getActualHealth());\n\n        damage = 10;\n        player.health = 100;\n        player.applyDamage(damage);\n        System.out.println(\"The actual health is \" + player.getActualHealth());\n    }\n}\n</code></pre> <p>Observamos que podemos inicializar directamente los campos del objeto <code>Player</code> a trav\u00e9s de clase externa porque hemos establecido la visibilidad como <code>public</code>. Adem\u00e1s, vemos que podemos causar da\u00f1o al jugador, pero seguidamente podemos darle m\u00e1s vida puesto que tenemos control sobre los atributos del jugador. Por lo que, al poder acceder a esos campos directamente potencialmente estamos abriendo la aplicaci\u00f3n y permitiendo cambiar el comportamiento. Ya que nosotros no queremos que se le pueda dar vida. Solo aplicar da\u00f1o.</p>"},{"location":"ud5/3encapsulacion/#consecuencias-de-cambios-internos-de-la-clase","title":"Consecuencias de cambios internos de la clase","text":"<p>Imagina que queremos que el name se guarde en may\u00fasculas siempre, si el campo es p\u00fablico para su asignaci\u00f3n, el usuario de la clase no tiene  que conocer que las especificaciones de la clase es que se guarde el nombre en may\u00fasculas. </p> <pre><code>    Player player = new Player();\n    //error en la especificaciones de la clase\n    player.name = \"pepito\";\n</code></pre> <p>Importante</p> <p>La clase tiene que ser responsable del mantenimiento correcto de sus propiedades</p>"},{"location":"ud5/3encapsulacion/#garantizar-que-los-valores-cumplan-la-especificaciones-de-la-clase","title":"Garantizar que los valores cumplan la especificaciones de la clase","text":"<p>Como no hemos definido un constructor, puede ser que la clase externa que usa <code>Player</code> no defina las variables de forma v\u00e1lida. Por tanto, no podemos garantizar que el uso del objeto jugador ser\u00e1 correcto.</p> <p>Imagina que al crear un objeto de la clase <code>Player</code> nos olvidamos de darle valor al campo de <code>health</code>:</p> <p></p> <p>Al intentar aplicar da\u00f1o no se aplicar\u00e1 de forma correcta. Por tanto, es conveniente definir un constructor para garantizar que el objeto se construye de forma correcta y adem\u00e1s si queremos agregar alg\u00fan tipo de validaci\u00f3n tambi\u00e9n podr\u00edamos realizarla en el constructor.</p>"},{"location":"ud5/3encapsulacion/#ejemplo-de-programa-con-encapsulacion","title":"Ejemplo de programa con encapsulaci\u00f3n","text":"<p>Vamos a ver cu\u00e1l es la forma correcta realizar el ejemplo anterior usando encapsulaci\u00f3n:</p> <ul> <li>Las propiedades tienen que ser privadas</li> <li>La asignaci\u00f3n de las propiedades y la correcci\u00f3n de los datos se realizar\u00e1 mediante setters y constructores</li> <li>La lectura de propiedades, si es necesario, se realizar\u00e1 mediante getters</li> </ul> <p></p> <pre><code>public class Player {\n\n    //propiedades privadas\n    private String name;\n    //valor por defecto\n    private int health = 100;\n    private String weapon;\n    private String status=\"vivo\";\n\n    public Player(String name, int health, String weapon) {\n        //guardamos el nombre en may\u00fasculas. Los setter controlan la entrada correcta\n        setName(name);\n        if (0&lt;health  &amp;&amp; health &lt;= 100) {\n            this.health = health;\n        }\n        this.weapon = weapon;\n    }\n\n    public void applyDamage(int damage) {\n        this.health -= damage;\n        if (this.health &lt;= 0 ) {\n            System.out.println(\"Player died\");\n            status=\"muerto\";\n        }\n    }\n    //getter y setter\n    public void setName(String name) {\n        //controlamos que siempre se guarde en may\u00fasculas\n        this.name = name.toUpperCase();\n    }\n\n    public int getHealth() {\n        return health;\n    }\n    //podemos saber el estado del personaje, pero no modificarlo directamente\n    public String getStatus() {\n        return status;\n    }\n}\n</code></pre>"},{"location":"ud5/4polimorfismo%20copy/","title":"Polimorfismo","text":"<p>El Polimorfismo es uno de los 4 pilares de la programaci\u00f3n orientada a objetos (POO) junto con la Abstracci\u00f3n, Encapsulaci\u00f3n y Herencia. Para entender que es el polimorfismo es muy importante que teng\u00e1is bastante claro el concepto de la Herencia.</p> <p>Polimorfismo significa \"que tiene muchas formas\", es la capacidad que tienen los objetos de una clase en ofrecer respuesta distinta e independiente en funci\u00f3n de los par\u00e1metros (diferentes implementaciones) utilizados durante su invocaci\u00f3n.</p> <p>Veamos un ejemplo para entender de forma m\u00e1s clara c\u00f3mo funciona el polimorfismo.</p> <p>Crearemos unas clases que heredan de la clase padre <code>Pelicula</code>:</p> <pre><code>class Pelicula {\n    private String titulo;\n\n    public Pelicula(String titulo) {\n        this.titulo = titulo;\n    }\n\n    public String trama() {\n        return \"No hay trama\";\n    }\n}\n\nclass Spiderman extends Pelicula {\n    public Spiderman() {\n        super(\"Spiderman\");\n    }\n\n    @Override\n    public String trama() {\n        return \"Un hombre que le muerde una ara\u00f1a y adquiere sus poderes.\";\n    }\n}\n\nclass Batman extends Pelicula {\n    public Batman() {\n        super(\"Batman\");\n    }\n\n    @Override\n    public String trama() {\n        return \"Un hombre que le muerde un murci\u00e9lago y adquiere sus poderes.\";\n    }\n}\n\nclass Zombieland extends Pelicula {\n    public Zombieland() {\n        super(\"Zombieland\");\n    }\n\n    @Override\n    public String trama() {\n        return \"Un pu\u00f1ado de humanos convertidos en zombies tratan de hacerse con el mundo\";\n    }\n}\n\nclass StarWars extends Pelicula {\n    public StarWars() {\n        super(\"StarWars\");\n    }\n\n    @Override\n    public String trama() {\n        return \"Las fuerzas imperiales tratan de hacerse con control del mundo\";\n    }\n}\n\nclass PeliRandom extends Pelicula {\n    public PeliRandom() {\n        super(\"PeliRandom\");\n    }\n}\n</code></pre> <p>Ahora vamos a crear un m\u00e9todo est\u00e1tico que nos va a devolver un objeto de tipo <code>Pelicula</code> en la clase <code>Main</code>, es decir, nos devolver\u00e1 una pel\u00edcula de manera aleatoria:</p> <pre><code>    public static Pelicula peliculaAleatoria() {\n        int numero = (int) (Math.random()*5) + 1; //genera un n\u00famero aleatorio entre 1 - 5\n        System.out.println(numero);\n        switch (numero) {\n            case 1:\n                return new Spiderman();\n            case 2:\n                return new Batman();\n            case 3:\n                return new Zombieland();\n            case 4:\n                return new StarWars();\n            case 5:\n                return new PeliRandom();\n        }\n        return null;\n    }\n</code></pre> <p>Gracias a la herencia, podemos devolver un tipo de la clase padre <code>Pelicula</code> aunque en realidad hayamos creado un objeto de una clase hija.</p> <p>Ahora vamos a ver el polimorfismo, para ello vamos a crear un bucle en el main de la siguiente forma:</p> <pre><code>    public static void main(String[] args) {\n        for (int i = 0; i &lt; 10; i ++) {\n            Pelicula pelicula = peliculaAleatoria();\n            System.out.println(\"Pelicula \" + i + \" \" + pelicula.getTitulo() + \" \\n\" + pelicula.trama());\n        }\n    }\n</code></pre> <p>Gracias al polimorfismo tenemos la capacidad de llamar al m\u00e9todo <code>trama</code> con el mismo tipo de objeto, en este caso de tipo <code>Pelicula</code> y obtener diferentes resultados, ya que Java autom\u00e1ticamente ve qu\u00e9 tipo de hijo es e imprime el correspondiente m\u00e9todo <code>trama</code>. Para el caso de que no se haya sobreescrito el m\u00e9todo llamar\u00e1 al de la clase padre Es decir, dependiendo del tipo de objeto invocado se realizan acciones diferentes, teniendo en cuenta, que todas las clases heredan de <code>Pelicula</code> eso es el polimorfismo.</p>"},{"location":"ud5/4polimorfismo%20copy/#importante","title":"Importante","text":"<p>Una variable puede contener una referencia a un objeto cuya clase es descendiente de la clase de la variable. Ejemplo:</p> <pre><code>    //La variable a es una referencia a un objeto Perro que es descendiente de Animal. \n    Animal a = new Perro();\n</code></pre> <p>Un descendiente de una clase es un hijo de esa clase, o un hijo de un hijo de esa clase, y as\u00ed sucesivamente. Los hermanos no son descendientes entre s\u00ed.</p> <p>NO podemos asignar un objeto de referencia de padre a una variable de clase hijo (Perro p = new Animal()). Si queremos convertir un padre en hijo, la variable tiene que ser creada de tipo hijo. Si queremos convertir un hijo en padre tendremos que hacer un Upcasting, y al rev\u00e9s tendr\u00edamos un Downcasting:</p> <p></p> <p>Ejemplo</p> <pre><code>    //NO SE PUEDE HACER\n    Perro p = new Animal(); //no compila\n    Perro p = (Perro) new Animal(); // compila pero da error de ejecuci\u00f3n\n\n    //DOWNCASTING, convertir padre en hijo\n    Animal a = new Perro();\n    Perro pe = (Perro)a;\n\n    //UPCASTING, convertir hijo en padre\n    Animal a = (Animal) new Perro();\n</code></pre>"},{"location":"ud5/4polimorfismo/","title":"Polimorfismo","text":"<p>El Polimorfismo es uno de los 4 pilares de la programaci\u00f3n orientada a objetos (POO) junto con la Abstracci\u00f3n, Encapsulaci\u00f3n y Herencia. Para entender que es el polimorfismo es muy importante que teng\u00e1is bastante claro el concepto de la Herencia.</p> <p>Polimorfismo significa \"que tiene muchas formas\", es la capacidad que tienen los objetos de una clase en ofrecer respuesta distinta e independiente en funci\u00f3n de los par\u00e1metros (diferentes implementaciones) utilizados durante su invocaci\u00f3n.</p> <p>Veamos un ejemplo para entender de forma m\u00e1s clara c\u00f3mo funciona el polimorfismo.</p> <p>Queremos crear un juego en la que tenemos animales de diferentes especies y que puedan hablar cada una en su propio lenguaje de su especie.</p> <p></p> <p>El an\u00e1lisis del problema puede darnos un diagrama de clases como el que sigue</p> <p></p> <p>Cada animal tiene su nombre y tenemos un m\u00e9todo hablar() que cada especie tiene que implementar.</p> <p>Crearemos unas clases que heredan de la clase padre <code>Animal</code>:</p> <p><pre><code>class Animal {\n    private String nombre;\n\n    public Animal(String nombre) {\n        this.nombre = nombre;\n    }\n\n    public void hablar() {\n        System.out.println( nombre+ \" dice: ....\";\n    }\n}\n\nclass Gato extends Animal {\n    public Gato(String nombre) {\n        super(nombre);\n    }\n\n    @Override\n    public void hablar() {\n        System.out.println( nombre+ \" dice: Miaaauuuuuu....\");\n    }\n}\n\nclass Perro extends Animal {\n    public Perro(String nombre) {\n        super(nombre);\n    }\n\n    @Override\n    public void hablar() {\n        System.out.println( nombre+ \" dice: Guuuaaaaaaauuuuu.....\");\n    }\n}\n\nclass Persona extends Animal {\n    public Persona(String nombre) {\n        super(nombre);\n    }\n\n    @Override\n    public void hablar() {\n        System.out.println( nombre+ \" dice: Blablablabla....\");\n    }\n}\n</code></pre> Cada uno de los animales habla su propio idioma al sobrescribir el m\u00e9todo <code>hablar()</code></p> <p>En nuestro fant\u00e1stico juego, queremos que los animales de la habitaci\u00f3n tengan una conversaci\u00f3n, el c\u00f3digo puede ser algo parecido a los siguiente. </p> <p><pre><code>    Gato gato1=new Gato(\"Garfiel\");\n    Perro perro1=new Perro(\"Laika\");\n    Persona persona1=new Persona(\"Pirico\")\n\n    public  void conversar() {\n        gato1.hablar();\n        perro1.hablar();\n        persona1.hablar();\n    }\n</code></pre> Cada uno de los personajes hablar\u00e1 en su idioma al llamar a <code>conversar()</code>.</p> <pre><code>Garfield  dice: Miaaauuuuuu....\nLaika dice: Guuuaaaaaaauuuuu.....\nPerico dice: Blablablabla....\n</code></pre> <p>Pero en nuestro juego no sabemos ni cuantos animales ni el tipo de animal que pueden haber en la habitaci\u00f3n, todo depende del desarrollo del juego por parte del jugador. Pero tenemos que hacer que todos los animales de la habitaci\u00f3n hablen.</p> <p>La potencia del polimorfismo nos permite tener en una variable del tipo de la clase padre, en nuestro caso <code>Animal</code> una instancia de las clases hijas y cuando llamamos al m\u00e9todo <code>hablar()</code> llamar\u00e1 al m\u00e9todo de la clase hija.</p> <p><pre><code>    Animal animal=new Gato(\"Garfiel\");\n    animal.hablar();\n</code></pre> muestra</p> <pre><code>Garfield  dice: Miaaauuuuuu....\n</code></pre> <p>Esto nos permite una soluci\u00f3n m\u00e1s abierta manteniendo una lista de tipo Animal, donde guardamos los diferentes animales y recorremos para que hablen todos los animales, cada uno en su idioma.</p> <p><pre><code>//creamos la lista de tipo Animal\n    ArrayList&lt;Animal&gt; animales=new ArrayList&lt;&gt;();\n    //a\u00f1adimos animales de los tipos descendientes\n    animales.add(new Gato(\"Garfiel\"));\n    animales.add(Perro(\"Laika\"));\n    animales.add(new Persona(\"Pirico\"));\n\n    public  void conversar() {\n         for (Animal animal:animales) {\n            //llamar\u00e1 al m\u00e9todo correspondiente del tipo de la instancia\n            animal.hablar();\n        }\n    }\n</code></pre> </p> <p>De esta forma, podr\u00edamos a\u00f1adir en un futuro nuevos tipos de animal y que no afectara al c\u00f3digo del m\u00e9todo <code>conversar()</code>.</p> <pre><code>animales.add(new Raton(\"Mickey\"));\n</code></pre> <p>Resumen</p> <p>La sobrescritura de m\u00e9todos y las conversiones entre clases de la jerarqu\u00eda sientan las bases para el polimorfismo. Es necesario entender bien estos conceptos para comprender el polimorfismo. Este se puede definir como la cualidad que tienen los objetos para responder de distinto modo a un mismo mensaje. </p> <p>El programa tiene que cumplir</p> <ul> <li>Los m\u00e9todos deben estar declarados (m\u00e9todos abstractos) y a veces tambi\u00e9n pueden estar implementados (m\u00e9todos no abstractos) en la clase base.</li> <li>Los m\u00e9todos deben estar redefinidos en las clases derivadas.</li> <li>Los objetos deben ser manipulados utilizando referencias a la clase base.</li> </ul>"},{"location":"ud5/4polimorfismo/#upcasting-downcasting","title":"Upcasting, Downcasting","text":"<p>Una variable puede contener una referencia a un objeto cuya clase es descendiente de la clase de la variable. Ejemplo:</p> <pre><code>    //La variable animal es una referencia a un objeto Perro que es descendiente de Animal. \n    Animal animal = new Perro();\n</code></pre> <p>Un descendiente de una clase es un hijo de esa clase, o un hijo de un hijo de esa clase, y as\u00ed sucesivamente. Los hermanos no son descendientes entre s\u00ed.</p> <p>NO podemos asignar un objeto de referencia de padre a una variable de clase hijo (Perro p = new Animal()). Si queremos convertir un padre en hijo, la variable tiene que ser creada de tipo hijo. Si queremos convertir un hijo en padre tendremos que hacer un Upcasting, y al rev\u00e9s tendr\u00edamos un Downcasting:</p> <p></p> <p>Ejemplo</p> <pre><code>    //NO SE PUEDE HACER: ERROR\n    Perro p = new Animal(); //no compila\n    Perro p = (Perro) new Animal(); // compila pero da error de ejecuci\u00f3n\n\n    //DOWNCASTING, convertir padre en hijo\n    Animal a = new Perro();\n    Perro pe = (Perro)a;\n\n    //UPCASTING, convertir hijo en padre\n    Animal a = (Animal) new Perro();\n</code></pre>"},{"location":"ud5/4polimorfismo/#el-operador-instanceof","title":"El operador <code>instanceof</code>","text":"<p>Las operaciones entre clases y en particular el downcasting requieren que las clases sean de tipos compatibles. Para asegurarnos de ello podemos utilizar el operador <code>instanceof</code>. Por otro lado, podemos tener la necesidad de tomar decisiones en funci\u00f3n del tipo del objeto</p> <p>instanceof devuelve true si el objeto es instancia de la clase y false en caso contrario. La sintaxis es:</p> <p>Objecto instanceof Clase</p> <pre><code>Animal animal=new Gato(\"ConBotas\");\nif(animal instanceof Gato)\n    System.out.println(\"soy un gato\");\n</code></pre> <p>El nuevo switch de java 17 nos permite tomar decisiones en funci\u00f3n del tipo de objeto</p> <p><pre><code>String queSoy=switch(animal){\n    case Gato g -&gt; \"soy un gato\";\n    case Perro p -&gt; \"soy un perro\";\n    case Persona p -&gt; \"soy una persona\";\n    default -&gt;  \"no se que quien soy\";\n}\n</code></pre> Es una caracter\u00edstica que hay que activar en java 17 pero que ya est\u00e1 disponible en la versi\u00f3n 21</p>"},{"location":"ud5/4polimorfismo/#ejemplo-de-polimorfismo-de-minecraft","title":"Ejemplo de polimorfismo de Minecraft","text":"<p>La capacidad del polimorfismo de la POO permite en los videojuegos programar la gran dificultad de manejar la variedad de los diferentes personajes, pantallas, posibles ampliaciones futuras ...</p> <p></p> <p>Vamos a ver un ejemplo b\u00e1sico del famoso videojuego Minecraft en el que simulamos la programaci\u00f3n de la reacci\u00f3n ante la destrucci\u00f3n individual de un bloque, en el que cada tipo de bloque tiene una reacci\u00f3n diferente</p> <p>Un posible dise\u00f1o puede ser el siguiente</p> <p></p> <p>Definimos un m\u00e9todo abstracto <code>destruir</code> que tendr\u00e1 que ser sobrescrito en cada uno de las nuevas clases de bloques que crearemos</p> <p>Cada nueva bloque proporciona una implementaci\u00f3n espec\u00edfica del m\u00e9todo destruir() para simular el comportamiento de los bloques en Minecraft.</p> <p>Polimorfismo: En el bucle <code>for</code> del m\u00e9todo <code>main()</code>, se llama al m\u00e9todo <code>destruir()</code> de cada objeto, y Java selecciona autom\u00e1ticamente la implementaci\u00f3n correcta basada en el tipo del objeto.</p> <pre><code>// Clase base Bloque\nabstract class Bloque {\n    public abstract void destruir(); // M\u00e9todo abstracto para destruir un bloque\n}\n\n// Subclase Tierra\nclass Tierra extends Bloque {\n    @Override\n    public void destruir() {\n        System.out.println(\"Has destruido un bloque de Tierra. Se convierte en tierra suelta.\");\n    }\n}\n\n// Subclase Piedra\nclass Piedra extends Bloque {\n    @Override\n    public void destruir() {\n        System.out.println(\"Has destruido un bloque de Piedra. Se convierte en adoqu\u00edn.\");\n    }\n}\n\n// Subclase Diamante\nclass Diamante extends Bloque {\n    @Override\n    public void destruir() {\n        System.out.println(\"Has destruido un bloque de Diamante. \u00a1Obtienes un diamante!\");\n    }\n}\n\n// Subclase Madera\nclass Madera extends Bloque {\n    @Override\n    public void destruir() {\n        System.out.println(\"Has destruido un bloque de Madera. Obtienes tablones.\");\n    }\n}\n\n// Clase principal\npublic class MinecraftPolimorfismo {\n    public static void main(String[] args) {\n        // Crear un array de bloques\n        Bloque[] bloques = {\n            new Tierra(),\n            new Piedra(),\n            new Diamante(),\n            new Madera()\n        };\n\n        // Destruir cada bloque de forma polim\u00f3rfica\n        for (Bloque bloque : bloques) {\n            bloque.destruir();\n        }\n    }\n}\n</code></pre>"},{"location":"ud5/5interfaces/","title":"\u2695\ufe0fInterfaces","text":""},{"location":"ud5/5interfaces/#definicion","title":"\u2747\ufe0f Definici\u00f3n","text":"<p>Una interfaz es una clase que define m\u00e9todos pero no los implementa. La idea es proporcionar un comportamiento com\u00fan que pueda ser utilizado por varias clases que implemente una interfaz. No se pueden instanciar.</p> <p>Te permiten definir tipos cuyos comportamientos pueden ser compartidos por varias clases que no est\u00e1n relacionadas, con el fin de crear instancias que se adapten a un dominio espec\u00edfico.</p> <p>Las interfaces juegan un papel fundamental en la creaci\u00f3n de aplicaciones Java ya que permiten interactuar a objetos no relacionados entre s\u00ed. Utilizando interfaces es posible que clases no relacionadas, situadas en distintas jerarqu\u00edas de clases sin relaciones de herencia, tengan comportamientos comunes</p> <p>Una interfaz es una lista de constantes y signaturas de m\u00e9todos. Los m\u00e9todos no est\u00e1n implementados en la interfaz (no hay cuerpo de m\u00e9todo).</p>"},{"location":"ud5/5interfaces/#por-que-se-utilizan-las-interfaces","title":"\u2747\ufe0f \u00bfPor qu\u00e9 se utilizan las interfaces?","text":"<p>Hay principalmente tres razones para usar la interfaz.</p> <ul> <li>Para lograr la abstracci\u00f3n.</li> <li>Dan algunas ventajas de herencia m\u00faltiple, sin las desventajas de la herencia.</li> <li>Para obtener un mayor desacoplamiento del c\u00f3digo.</li> </ul> <p>Las interfaces son muy usadas, de hecho, muchas de las librer\u00edas de Java hacen un uso extensivo de las interfaces.</p> <p>Sabemos que Java tiene herencia \u00fanica, es decir, una clase hija hereda solo de una clase padre. Esto, por lo general, es suficiente para codificar nuestras aplicaciones. Aunque a veces ser\u00eda conveniente la herencia m\u00faltiple, donde una clase hija pudiera heredar caracter\u00edsticas de varias clases padres. Pero esto puede llegar a ser confuso. \u00bfQu\u00e9 sucede cuando dos padres tienen diferentes versiones del mismo m\u00e9todo?</p> <p>Una interfaz describe aspectos de una clase distintos de los que hereda de su padre. Una interfaz es un conjunto de requisitos que la clase debe implementar.</p>"},{"location":"ud5/5interfaces/#interfaz-vs-herencia","title":"\u2747\ufe0f Interfaz vs Herencia","text":"<p>Una clase puede extender de una clase padre para heredar los m\u00e9todos y las variables de instancia de ese padre. </p> <p>Una clase tambi\u00e9n puede implementar una interfaz al incluir m\u00e9todos y constantes adicionales. Sin embargo, los m\u00e9todos en la interfaz deben escribirse expl\u00edcitamente como parte de la definici\u00f3n de la clase. La interfaz es una lista de requisitos que debe incluir la definici\u00f3n de clase (a trav\u00e9s de c\u00f3digo expl\u00edcito, no a trav\u00e9s de herencia).</p> <p>Por ejemplo, una clase <code>Coche</code> podr\u00eda extender de la clase <code>Vehiculo</code>. La herencia le da todos los m\u00e9todos y variables de instancia. Pero si <code>Coche</code> tambi\u00e9n implementa la interfaz <code>Impuestos</code>, entonces su definici\u00f3n debe contener c\u00f3digo para TODOS los m\u00e9todos enumerados en <code>Impuestos</code>.</p> <p>Los nombres de las interfaces suelen acabar en able aunque no es necesario: <code>configurable, arrancable, dibujable, etc</code>.</p> <p>Una clase extiende de un solo padre, pero puede implementar varias interfaces.</p>"},{"location":"ud5/5interfaces/#como-crear-una-interfaz","title":"\u2747\ufe0f C\u00f3mo crear una interfaz","text":"<p>Para crear una interfaz en IntelliJ, haremos lo siguiente:</p> <ol> <li>Bot\u00f3n derecho en el paquete de nuestra aplicaci\u00f3n \u2192 New ---&gt; Java class y seleccionamos Interface.</li> </ol> <p></p> <p></p> <p>En Java, los nombres de las interfaces, por lo general, deber\u00edan ser adjetivos o nombres que describen el concepto abstracto que representa la interfaz. La primera letra de cada palabra separada en may\u00fascula. En algunos casos, las interfaces tambi\u00e9n pueden ser sustantivos cuando presentan una familia de clases, p. <code>List</code> o <code>Map</code>.</p> <p></p> <p>Una vez creada la interfaz definiremos los m\u00e9todos que desarrollar\u00e1n las clases que implementen esta interfaz teniendo en cuenta que, el compilador de Java agrega las palabras clave:</p> <ul> <li><code>public abstract</code> cuando se define un m\u00e9todo, por lo que se puede omitir en los encabezados de los m\u00e9todos. </li> <li><code>public static final</code> en el caso de las constantes.</li> </ul> <p></p> <p>Warning</p> <p>Los m\u00e9todos abstractos NO pueden ser PRIVATE ni PROTECTED.</p> <p>Se estructura de forma que primero se sit\u00faan las constantes y luego los m\u00e9todos.</p> <p>Si ponemos <code>public</code> IntelliJ nos avisa:</p> <p></p> <p></p>"},{"location":"ud5/5interfaces/#relaciones-entre-interfaces-y-clases","title":"\u2747\ufe0f Relaciones entre interfaces y clases","text":"<p>Tenemos tres tipos de relaciones:</p> <ul> <li><code>classB</code> extends <code>classA</code>: una clase B hereda de una clase A.</li> <li><code>class</code> implements <code>interface1</code>, <code>interface2</code>, ...: una clase puede implementar una o varias interfaces, para ello usaremos la palabra reservada implements.</li> <li><code>interfaceB</code> extends <code>interfaceA</code>, <code>interfaceC</code>, ...: una interfaz B puede heredar los m\u00e9todos de una o varias interfaces. Una interfaz NO PUEDE heredar de una clase.</li> </ul> <p>Tambi\u00e9n podemos combinar algunas relaciones:</p> <ul> <li><code>classB</code> extends <code>classA</code> implements <code>interface1</code>, <code>interface2</code>, ...:  una clase B hereda de una clase A y tambi\u00e9n implementa los m\u00e9todos definidos en las interfaces. (Simulaci\u00f3n de la herencia m\u00faltiple)</li> </ul>"},{"location":"ud5/5interfaces/#ejemplo-de-codigo","title":"\u2747\ufe0f Ejemplo de c\u00f3digo","text":"<p>Por ejemplo, vamos a crear la clase TelefonoMovil:</p> <p></p> <p>Observamos que IntelliJ nos genera un error, ya que debemos definir o implementar los m\u00e9todos que hab\u00edamos declarado en la interfaz. Si hacemos click en el error, IntelliJ nos ofrece crearlos:</p> <p></p> <p></p> <p>IntelliJ nos ha creado TODOS los m\u00e9todos que hab\u00edamos definido en la interfaz, como vemos con la anotaci\u00f3n <code>@Override</code>, ya que los est\u00e1 sobreescribiendo puesto que estaban declarados en la interfaz.</p> <p>Note</p> <p>TODOS los m\u00e9todos definidos en la interfaz se han de implementar en la clase, no podr\u00edamos implementar solo algunos.</p> <p>Veamos como probar el c\u00f3digo en nuestra clase <code>Main</code>:</p> <pre><code>public class MainTelefono {\n\n    public static void main(String[] args) {\n        Impuesto impuesto = new TelefonoMovil(123456789);\n        impuesto.imprimirImpuesto();\n    }\n}\n</code></pre> <p>Warning</p> <p>Las interfaces NO PUEDEN INSTANCIARSE, es decir, no podemos crear objetos de interfaces. Hay que usar una clase que haya implementado la funcionalidad definida por la interfaz.</p>"},{"location":"ud5/5interfaces/#otro-ejemplo-con-herencia-e-interface","title":"\u2747\ufe0fOtro ejemplo con herencia e interface","text":"<p>Queremos crear un videojuego en el que tenemos pieza de cubo que el usuario las utilizar\u00e1 para construir un mundo. Algunas de las piezas(no todas) cuando se toquen pueden explotar y otras pueden quemarse, otras pueden quemarse y explotar. </p> <p></p> <p>Por otro lado, tenemos otros elementos que puedes explotar, como puede ser una Nave. El diagrama de clases puedes ser</p> <p></p> <pre><code>//*********Clase padre****\npublic class Cubo {\n     String nombre;\n    public Cubo(String nombre) {\n        this.nombre = nombre;\n    } \n\n}\n//********Interfaces**************\npublic interface Inicinerable {\n    void incinerar();\n}\n//******************************\npublic interface Explotable {\n    void explotar();\n}\n\n//******Clases hijas************\npublic class Cesped extends Cubo{\n    public Cesped(String nombre) {\n        super(nombre);\n    }\n}\n//******************************\npublic class Dinamita extends Cubo implements Explotable{\n    public Dinamita(String nombre) {\n        super(nombre);\n    }\n\n    @Override\n    public void explotar() {\n        System.out.println(\"Boooo!!!\");\n    }\n}\n//********************************\npublic class Madera extends Cubo implements Inicinerable{\n    public Madera(String nombre) {\n        super(nombre);\n    }\n\n    @Override\n    public void incinerar() {\n        System.out.println(\"fuegooooo!!!\");\n    }\n}\n//********************************\npublic class Butano extends Cubo implements Inicinerable,Explotable{\n    public Butano(String nombre) {\n        super(nombre);\n    }\n\n    @Override\n    public void explotar() {\n         System.out.println(\"Bataboooo!!!);\n    }\n\n    @Override\n    public void incinerar() {\n        System.out.println(\"Fuegoonnnn!!!);\n    }\n}\n//********************\npublic class Nave implements Explotable{\n    String nombre;\n    @Override\n    public void explotar() {\n        System.out.println(\"Exxxxxploooosiooooon!!!!\");\n    }\n}\n//********************\npublic static void main(String[] args) {\n    //podemos crear un dinamita y explotarla\n    Dinamita dim1=new Dinamita(\"DinamitaCat1\");\n    dim1.explotar();\n    //podemos crear madera y quemarla\n    Madera mad1=new Madera(\"Pino\");\n    mad1.incinerar();\n    //podemos crear butano y explotarlo y quemarlo\n    Butano but1=new Butano(\"But10Litros\");\n    but1.incinerar();\n    but1.explotar();\n    //pero no podemos crear cesped que se queme o explote\n    Cesped cesp1=new Cesped(\"artificial\");\n\n}\n</code></pre> <p>Suponer que queremos que el usuario pueda generar grandes explosiones o grandes fuegos amontonando cubos Explotables o Incinerables. </p> <p>Con las Interface ocurre lo mismo que con las clases abstractas, podemos instanciar un objeto que implemente la interface sobre una variable del tipo que implementa. <pre><code>   Explotable explotable=new Dinamita(\"DinamitaCat1\");\n</code></pre></p> <p>De esta forma, podemos tener un array de objetos explotables <pre><code>public static void granExplosion(Explotable[] explotables){\n    for (Explotable explotable:explotables) {\n        //cada tipo de objeto genera su propia explosi\u00f3n\n        explotable.explotar();\n    }\n}\n    public static void main(String[] args) {\n        //creamos array de explotables\n        Explotable[] miGranExplosion=new Explotable[3];\n        //creamos explotables de diferente tipo\n        miGranExplosion[0]=new Dinamita(\"DinamitaCat1\");\n        miGranExplosion[1]=new Butano(\"But10Litros\");\n        miGranExplosion[2]=new Nave();\n        //llamamos a la gran explosion\n        granExplosion(miGranExplosion);\n    }\n</code></pre></p>"},{"location":"ud5/5interfaces/#clase-anonimas","title":"\u2747\ufe0f Clase an\u00f3nimas","text":"<p>Lo m\u00e1s com\u00fan es que las interfaces sean implementadas por distintas clases que adem\u00e1s, se crear\u00e1n diversos objetos. Pero en muchas ocasiones, la creaci\u00f3n de una interface es solo necesaria en una ocasi\u00f3n en ese lugar y no deseamos crear una clase para ese prop\u00f3sito.</p> <p>Para estos casos tenemos las clases an\u00f3nimas. Son clases sin nombre que implementan un interface y que utilizan el nombre de la Interface como constructor.</p> <p>Vamos a suponer que en un momento del juego, queremos generar una explosi\u00f3n exclusiva que no est\u00e1 asociada a ning\u00fan objeto. Podemos crear una objeto de la clase an\u00f3nima de la siguiente forma</p> <pre><code>Explotable miExplosion=new Explotable() {\n            @Override\n            public void explotar() {\n                System.out.println(\"boonnobooonnnoboonnnobonnbonn!\");\n            }\n        };\n//No hay una clase espec\u00edfica\nmiExplosion.explotar();\n</code></pre>"},{"location":"ud5/5interfaces/#clase-anonimas-y-desarrollo-en-entornos-graficos","title":"\u2747\ufe0f Clase an\u00f3nimas y desarrollo en entornos gr\u00e1ficos","text":"<p>En el desarrollo de aplicaciones en entornos gr\u00e1ficos orientados a eventos, las clases an\u00f3nimas se utilizan constantemente, ya que para definir los diferentes eventos como puede ser realizar una acci\u00f3n cuando hace click sobre un bot\u00f3n, el m\u00e9todo correspondiente para asignar el evento al bot\u00f3n espera un objeto de una clase que implemente cierta interface, y como solamente defines una vez lo que tiene que hacerse cuando se pulsa el bot\u00f3n, no creas una clase concreta, creas una clase an\u00f3nima que implementa la interface.</p> <p>Por ejemplo, en JavaFx, podemos tener un bot\u00f3n que haga algo <pre><code>Button boton= new Button();\n</code></pre> Para asignar el evento al bot\u00f3n vemos el tipo de objeto que necesita</p> <p></p> <p>Y vemos que <code>EventHandler</code> es una interface</p> <p></p> <p>De esta forma, creamos una clase an\u00f3nima que implementa la interface con la acci\u00f3n que realizar el bot\u00f3n</p> <pre><code>Button boton= new Button();\n//creamos objeto de clase an\u00f3nima que implementa EventHandler\nEventHandler&lt;? super MouseEvent&gt; eventHandler = new EventHandler&lt;MouseEvent&gt;() {\n        @Override\n        public void handle(MouseEvent mouseEvent) {\n                //hacer algo....\n        }\n};\n//lo asignamos a la acci\u00f3n del  bot\u00f3n\nboton.setOnMouseClicked(eventHandler);\n</code></pre> <p>y solemos verlo simplificada de la siguiente forma</p> <pre><code> Button boton= new Button();\nboton.setOnMouseClicked(new EventHandler&lt;MouseEvent&gt;() {\n        @Override\n        public void handle(MouseEvent mouseEvent) {\n                //hacer algo....\n        }\n});\n</code></pre>"},{"location":"ud5/5interfaces/#interfaz-comparable","title":"\u2747\ufe0f Interfaz Comparable","text":"<p>En programaci\u00f3n hay ciertas operaciones que son tan comunes que se han desarrollado en la Api de Java. Una de estas operaciones es determinar el orden de una lista de objetos de la misma clase.</p> <p>En Java, la interfaz <code>Comparable</code> es una interfaz gen\u00e9rica que se utiliza para definir el orden natural de los objetos de una clase. Esta interfaz se encuentra en el paquete <code>java.lang</code> y tiene un \u00fanico m\u00e9todo llamado <code>compareTo()</code> . </p> <p>La idea es que una clase que implementa la interfaz <code>Comparable</code> puede ser comparada con otras instancias de la misma clase y se puede saber si es menor, mayor o igual.</p> <p>La clase que implementa <code>Comparable</code> tiene que implementar el m\u00e9todo <code>compareTo()</code> que devuelve un entero</p> <p>int compareTo(Object ob)</p> <p>De tal manera que</p> <p>ob1.compareTo(ob2) &lt; 0  si ob1 va antes que ob2</p> <p>ob1.compareTo(ob2) &gt; 0  si ob2 va antes que ob1</p> <p>ob1.compareTo(ob2) = 0  si ob1 es igual que ob2</p> <p>En este ejemplo, la comparaci\u00f3n se realiza en funci\u00f3n de la edad de las personas. Puedes personalizar la l\u00f3gica dentro del m\u00e9todo <code>compareTo()</code> seg\u00fan los criterios de orden que desees establecer para tus objetos.</p> <p><pre><code>public class Persona implements Comparable&lt;Persona&gt; {\n    private String nombre;\n    private int edad;\n\n    // Constructor y otros m\u00e9todos de la clase\n\n    @Override\n    public int compareTo(Persona otraPersona) {\n        // Comparaci\u00f3n basada en la edad\n        return this.edad - otraPersona.edad;\n    }\n\n    public static void main(String[] args) {\n        Persona persona1 = new Persona(\"Juan\", 25);\n        Persona persona2 = new Persona(\"Maria\", 30);\n\n        if (persona1.compareTo(persona2) &lt; 0) {\n            System.out.println(persona1.getNombre() + \" es menor que \" + persona2.getNombre());\n        } else if (persona1.compareTo(persona2) &gt; 0) {\n            System.out.println(persona1.getNombre() + \" es mayor que \" + persona2.getNombre());\n        } else {\n            System.out.println(persona1.getNombre() + \" tiene la misma edad que \" + persona2.getNombre());\n        }\n    }\n}\n</code></pre> De esta manera, la Api de Java tiene clases que utilizan la interface <code>Comparable</code> para ordenar. Por ejemplo la clase Arrays.</p> <p><pre><code>public static void main(String[] args) {\n        Persona persona1 = new Persona(\"Juan\", 25);\n        Persona persona2 = new Persona(\"Maria\", 30);\n        Persona persona3 = new Persona(\"Carlos\", 22);\n\n        Persona[] personas = {persona1, persona2, persona3};\n        imprimirArray(personas);\n        // Ordenar el array utilizando Arrays.sort()\n        Arrays.sort(personas);\n\n        System.out.println(\"\\nArray de personas despu\u00e9s de ordenar por edad:\");\n        imprimirArray(personas);\n    }\n    // M\u00e9todo para imprimir el array de personas\n    private static void imprimirArray(Persona[] personas) {\n        for (Persona persona : personas) {\n            System.out.println(persona.getNombre() + \" - Edad: \" + persona.getEdad());\n        }\n    }\n</code></pre> o para ordenar un ArrayList</p> <pre><code>public static void main(String[] args) {\n        // Crear objetos Persona\n        Persona persona1 = new Persona(\"Juan\", 25);\n        Persona persona2 = new Persona(\"Maria\", 30);\n        Persona persona3 = new Persona(\"Carlos\", 22);\n\n        // Crear ArrayList y agregar personas\n        ArrayList&lt;Persona&gt; listaPersonas = new ArrayList&lt;&gt;();\n        listaPersonas.add(persona1);\n        listaPersonas.add(persona2);\n        listaPersonas.add(persona3);\n\n        System.out.println(\"ArrayList de personas antes de ordenar:\");\n        imprimirArrayList(listaPersonas);\n\n        // Ordenar el ArrayList utilizando Collections.sort()\n        Collections.sort(listaPersonas);\n\n        System.out.println(\"\\nArrayList de personas despu\u00e9s de ordenar por edad:\");\n        imprimirArrayList(listaPersonas);\n    }\n\n    // M\u00e9todo para imprimir el ArrayList de personas\n    private static void imprimirArrayList(ArrayList&lt;Persona&gt; listaPersonas) {\n        for (Persona persona : listaPersonas) {\n            System.out.println(persona.getNombre() + \" - Edad: \" + persona.getEdad());\n        }\n    }\n</code></pre>"},{"location":"ud5/5interfaces/#interface-comparator","title":"\u2747\ufe0f Interface Comparator","text":"<p>Mediante la interface <code>Comparable</code> hemos visto que otras clases pueden ordenar un conjunto de objetos de una clase por una condici\u00f3n(en el ejemplo, por la edad), pero podemos tener la necesidad de tener que ordenar por otras condiciones(por ejemplo por el nombre).</p> <p>Si vemos la a Api de Java para la clase Arrays, tenemos el m\u00e9todo <code>sort</code> sobrecargado, y una de las sobrecargas es</p> <p>sort(T[] a, Comparator&lt;? super T&gt; c)</p> <p>Vemos que acepta un objeto que implementa <code>Comparator</code>. Esto nos permite ordenar por otras condiciones determinadas por <code>Comparator</code></p> <p>Por ejemplo, queremos ordenar un array de Personas por nombre, har\u00edamos lo siguiente</p> <p><pre><code>public static void main(String[] args) {\n    Persona[] personas = new Persona[3];\n    personas[0]= new Persona(\"Pepe\", 25);\n    personas[1]= new Persona(\"Maria\", 30);\n    personas[2]= new Persona(\"Fernan\", 20);\n\n    // Usando Comparator para ordenar por edad de forma ascendente, creamos una clase an\u00f3nima\n    Comparator&lt;Persona&gt; comparadorNombreAscendente = new Comparator&lt;Persona&gt;() {\n        @Override\n        public int compare(Persona per1, Persona per2) {\n            //aprovechamos que String implementa Comparable\n            return per1.getNombre().compareTo(per2.getNombre());\n        }\n    };\n    //ordenamos por nombre\n    Arrays.sort(personas,comparadorNombreAscendente);\n\n    // Imprimiendo la lista ordenada ascendente\n    for (Persona persona : personas) {\n        System.out.println(persona.nombre + \" - \" + persona.edad);\n    }\n}\n</code></pre> El mismo ejemplo pero con un <code>ArrayList</code>.</p> <p><pre><code>//suponemos que personas es un ArrayList\nCollections.sort(personas, comparadorNombreAscendente);\n</code></pre> De esta forma, podremos ordenar nuestros datos seg\u00fan diferentes criterios</p> <pre><code>//ordenar por nombre de forma descendente\n Comparator&lt;Persona&gt; comparadorNombreDescendente = new Comparator&lt;Persona&gt;() {\n        @Override\n        public int compare(Persona per1, Persona per2) {\n            //descendente por nombre\n            return per2.getNombre().compareTo(per1.getNombre());\n        }\n    };\n Arrays.sort(personas,comparadorNombreDescendente);\n</code></pre>"},{"location":"ud5/5interfaces/#comparable-vs-comparator","title":"Comparable vs Comparator","text":"<p><code>Comparable</code> nos va a permitir ordenar por un criterio principal el conjunto de objetos de una clase y <code>Comparator</code> nos permitir\u00e1 ordenar por otros criterios los objetos de la clase</p> <pre><code>//ordenamos por edad mediante Comparable\nArrays.sort(personas);\n//ordenamos por nombre ascendente por Comparator\nArrays.sort(personas,comparadorNombreAscendente);\n//ordenamos por nombre descendente por Comparator\nArrays.sort(personas,comparadorNombreDescendente);\n</code></pre>"},{"location":"ud5/5interfaces/#novedades","title":"\u2747\ufe0f Novedades","text":"<p>Desde Java 8 podemos incluir en una interfaz:</p> <ul> <li> <p>m\u00e9todos con cuerpo o implementaci\u00f3n: se denominan default methods. Estos m\u00e9todos se heredan como cualquier m\u00e9todo ordinario m\u00e1s y se pueden sobrescribir en la clase que implementa esa interfaz o sobrescribir en la interfaz que hereda de esa interfaz.</p> </li> <li> <p>m\u00e9todos est\u00e1ticos con cuerpo o implementaci\u00f3n. Estos m\u00e9todos no pueden ser sobreescritos o cambiar en ninguna clase que implemente la interfaz. Aunque si se heredan.</p> </li> </ul> Impuesto.java<pre><code>public interface Impuesto {\n\n    //constantes\n    double TASA_DE_IMPUESTO = 0.06;\n\n    //m\u00e9todos abstractos\n    double calcularImpuestoAnual();\n\n    void imprimirImpuesto();\n\n    //default methods\n    default void imprimirTasa() {\n        System.out.println(\"La tasa de impuesto es \" + TASA_DE_IMPUESTO);\n    }\n\n    //m\u00e9todos est\u00e1ticos\n    static double tax(int precio) {\n        return TASA_DE_IMPUESTO * precio;\n    }\n}\n</code></pre>"},{"location":"ud5/5interfaces/#por-que-el-uso-de-default-o-static-methods-en-el-interior-de-una-interfaz","title":"\u269c\ufe0f \u00bfPor qu\u00e9 el uso de default o static methods en el interior de una interfaz?","text":"<p>Imagina que creamos una interfaz en el proyecto. Pasado un tiempo, un gran n\u00famero de clases implementan esa interfaz.</p> <p>Si ahora a\u00f1adimos un nuevo m\u00e9todo a esta interfaz, desencadena en que, todas las clases que implementen esa interfaz se ver\u00e1n afectadas con errores, hasta que implementen o le den cuerpo a ese nuevo m\u00e9todo. Aunque no es una tarea complicada puede llegar a ser tediosa, o que no sepamos todav\u00eda como implementarlo en todas las clases.</p> <p>Para solventar esto, Java introdujo los default methods y m\u00e9todos est\u00e1ticos.</p> <ul> <li>Desde Java 9, podemos tener m\u00e9todos privados en una interfaz.</li> </ul> <p>Los m\u00e9todos privados se pueden implementar est\u00e1ticos o no. </p> <p>\u00bfCu\u00e1les son las ventajas de tener m\u00e9todos privados?</p> <p>Las interfaces pueden usar m\u00e9todos privados para ocultar detalles sobre la implementaci\u00f3n de las clases que implementan la interfaz. Como resultado, uno de los principales beneficios de tenerlos en las interfaces es la encapsulaci\u00f3n.</p> Impuesto.java<pre><code>public interface Impuesto {\n\n    //constantes\n    double TASA_DE_IMPUESTO = 0.06;\n\n    //m\u00e9todos abstractos\n    double calcularImpuestoAnual();\n\n    void imprimirImpuesto();\n\n    //default methods\n    default void imprimirTasa() {\n        System.out.println(\"La tasa de impuesto es \" + TASA_DE_IMPUESTO);\n    }\n\n    default void aumentarTasa() {\n        duplicarTasa();\n    }\n\n    //m\u00e9todos privados de instancia\n    private double duplicarTasa() {\n        return TASA_DE_IMPUESTO * 2;\n    }\n\n    //m\u00e9todos est\u00e1ticos\n    static double tax(int precio) {\n        mostrarPrecio(precio);\n        return TASA_DE_IMPUESTO * precio;\n    }\n\n    //m\u00e9todos privados est\u00e1ticos\n    private static void mostrarPrecio(int precio) {\n        System.out.println(\"El precio es \" + precio);\n    }\n\n}\n</code></pre>"},{"location":"ud5/6abstraccion/","title":"Abstracci\u00f3n","text":"<p>La abstracci\u00f3n es un proceso de ocultar los detalles de implementaci\u00f3n y mostrar solo la funcionalidad al usuario.</p> <p>De otra manera, muestra solo las cosas esenciales para el usuario y oculta los detalles internos.</p> <p>Una clase abstracta es una clase que no se puede instanciar pero que puede ser el padre de otras clases. Esto es \u00fatil, por ejemplo, cuando tenemos un concepto abstracto o amplio como Veh\u00edculo o Animal pero en realidad los objetos reales ser\u00edan tipos espec\u00edficos como Coche, Avi\u00f3n, Perro, etc.</p> <p>Aunque no se puede instanciar, una clase abstracta define m\u00e9todos y variables que heredan las clases hijas.</p>"},{"location":"ud5/6abstraccion/#como-crear-una-clase-abstracta","title":"C\u00f3mo crear una clase abstracta","text":"<p>Para crear una clase abstracta en IntelliJ, haremos lo siguiente:</p> <ol> <li>Bot\u00f3n derecho en el paquete de nuestra aplicaci\u00f3n \u2192 New ---&gt; Java class y a\u00f1adimos la palabra reservada <code>abstract</code>:</li> </ol> <p></p>"},{"location":"ud5/6abstraccion/#metodos-abstractos","title":"M\u00e9todos abstractos","text":"<p>Las clases abstractas pueden opcionalmente contener m\u00e9todos abstractos. Tambi\u00e9n pueden contener m\u00e9todos no abstractos, que ser\u00e1n heredados por los hijos.</p> <p>Un m\u00e9todo abstracto no tiene cuerpo. (No tiene c\u00f3digo). Solo se escribe la signatura del m\u00e9todo con la palabra reservada abstract.</p> <p>Vamos a crear una clase abstracta <code>Animal</code>:</p> <p></p> <p>Si ahora creamos una clase hija que herede de <code>Animal</code> obtendremos un error:</p> <p></p> <p>Esto es debido a que una clase hija no abstracta hereda el m\u00e9todo o los m\u00e9todos abstractos del padre y debe desarrollarlos como m\u00e9todos no abstractos, es decir, con c\u00f3digo. Si no lo hace debe declararse como abstracta.</p> <p>Un hijo abstracto de un padre abstracto no tiene que definir m\u00e9todos no abstractos para los m\u00e9todos abstractas que hereda. Esto significa que puede haber varios pasos entre una clase base abstracta y una clase secundaria que no es completamente abstracta.</p> <p></p> <p></p> <p>No todo lo definido en una clase abstracta debe ser abstracto. Sin embargo, si una clase contiene incluso un m\u00e9todo abstracto, entonces la clase en s\u00ed debe declararse abstracta.</p> <p>Si a\u00f1adimos otra clase hija <code>Ave</code> que hereda de <code>Animal</code> y le agregamos un m\u00e9todo abstracto. El IntelliJ nos muestra un error.</p> <p></p> <p>Tenemos que crear la clase como abstracta, ya que contiene un m\u00e9todo abstracto.</p> <p>Una vez creada la clase <code>Ave</code> como abstracta podr\u00edamos heredar de ella y crear clases hijas que implementar\u00e1n el m\u00e9todo abstracto volar:</p> <p></p> <p>Las clases abstractas se utilizan para organizar programas. Agrupar las clases es importante para mantener un programa organizado y comprensible.</p> <p>La ventaja de usar una clase abstracta es que puede agrupar varias clases relacionadas como hermanas.</p> <p>Aunque no se puedan instanciar las clases abstractas tambi\u00e9n poseen constructores. La mayor\u00eda de las veces se utilizan cuando quieres realizar alguna inicializaci\u00f3n de los campos de la clase abstracta antes de la instanciaci\u00f3n de una clase hija.</p> <p>Warning</p> <p>Cuando se invoca un m\u00e9todo, es la clase del objeto (no de la variable) la que determina qu\u00e9 m\u00e9todo se ejecuta.</p>"},{"location":"ud5/6abstraccion/#interfaces-vs-clases-abstractas","title":"Interfaces vs Clases abstractas","text":"<ul> <li>Las clases abstractas pueden tener variables de instancia (atributos) que se heredan, al contrario que las interfaces, que no permiten definir variables solo constantes est\u00e1ticas.</li> <li>Ni las interfaces ni las clases abstractas se puede instanciar.</li> <li>Las interfaces no pueden tener constructores y las clases abstractas si.</li> <li>Todos los m\u00e9todos definidos en una interfaz son por defecto p\u00fablicos y abstractos, mientras que, en un clase abstracta podemos tener m\u00e9todos con diferentes visibilidades (<code>public</code>, <code>private</code> o <code>protected</code>) y abstractos o con cuerpo.</li> <li>Si implementas una interfaz debes sobreescribir todos sus m\u00e9todos, si heredas de una clase abstractas solo est\u00e1s obligado a sobreescribir los m\u00e9todos abstractos.</li> </ul>"},{"location":"ud5/7exceptions/","title":"Excepciones","text":""},{"location":"ud5/7exceptions/#introduccion","title":"Introducci\u00f3n","text":"<p>En el proceso de ejecuci\u00f3n de un programa, pueden surgir errores que como programadores pueden ser dif\u00edciles de controlar. Por ejemplo</p> <ul> <li>cuando tenemos que leer un fichero y este no existe</li> <li>cuando el usuario tiene que introducir un n\u00famero e introduce un texto</li> <li>cuando hacemos una petici\u00f3n a una base de datos y no contesta...</li> </ul> <p>Por ejemplo, las siguientes muestras de c\u00f3digo provocan la parada del programa</p> <pre><code>int[] numeros={1,2,3,4};\n//provocar\u00e1 un error porque nos salimos tama\u00f1o del array\nSystem.out.println(numeros[6]);// java.lang.ArrayIndexOutOfBoundsException\n\nString s=\"Hola\";\n//provocar\u00e1 un error al convertir el string a entero\nint numero=Integer.parseInt(s);//java.base/java.lang.NumberFormatException\n\n//provocar\u00e1 error al dividir por cero\nint resultado=12/0;//java.lang.ArithmeticException: / by zero\n\nint[] lista;\n//provocar\u00e1 error nullPointerException, el objeto no existe\nint size= lista.length\n</code></pre> <p>Los programas tienes que ser robustos y recuperarse ante errores. Para manejar los errores y que los programas no se queden \u201ccolgados\u201d y sigan su funcionamiento  tenemos el manejo de excepciones. </p> <p>Si el error no se trata, el manejador de excepciones realiza lo siguiente:</p> <ul> <li>Muestra la descripci\u00f3n de la excepci\u00f3n.</li> <li>Muestra la traza de la pila de llamadas.</li> <li>Provoca el final del programa</li> </ul> <p></p>"},{"location":"ud5/7exceptions/#excepcion","title":"Excepci\u00f3n","text":"<p>Las excepciones son un mecanismo especial para gestionar errores. Permiten separar el tratamiento de errores del c\u00f3digo normal de un programa.</p> <p>Una excepci\u00f3n es un evento que ocurre durante la ejecuci\u00f3n de una aplicaci\u00f3n e interrumpe el flujo normal de las instrucciones del programa.</p> <p></p> <p>Class Exception y class Error extienden Throwable. </p> <p>La clase Error est\u00e1 relacionada con errores de la m\u00e1quina virtual de Java. Generalmente estos errores no dependen del programador, por lo que no nos debemos preocupar por tratarlos, por ejemplo, <code>OutOfMemoryError</code>, <code>StackOverflowError</code>, errores de hardware, etc.</p> <p>En la clase Exception se encuentran las excepciones que se pueden lanzar en una aplicaci\u00f3n</p> <p>Las excepciones son diferentes de los errores porque se pueden escribir programas para recuperarse de excepciones, pero no se pueden escribir programas para recuperarse de errores.</p> <p>Las excepciones pueden ser detectadas por una parte del programa que intenta recuperarse del problema.</p>"},{"location":"ud5/7exceptions/#que-ocurre-cuando-se-produce-una-excepcion","title":"Qu\u00e9 ocurre cuando se produce una excepci\u00f3n","text":"<ul> <li>La M\u00e1quina Virtual Java crea un objeto excepci\u00f3n y lo lanza. El objeto excepci\u00f3n creado contiene informaci\u00f3n sobre el error. La ejecuci\u00f3n normal del programa se detiene.</li> <li>El sistema busca en el m\u00e9todo donde se ha producido la excepci\u00f3n un manejador de excepciones que capture(catch) ese objeto y trate la excepci\u00f3n.</li> <li> <p>Si el m\u00e9todo no contiene un manejador para la excepci\u00f3n se busca en el m\u00e9todo que llam\u00f3 a este y as\u00ed sucesivamente en toda la pila de llamadas.</p> </li> <li> <p>Cuando se encuentra un manejador apropiado se le pasa la excepci\u00f3n. Un manejador de excepciones es considerado apropiado si el tipo de objeto excepci\u00f3n lanzado es compatible al tipo que puede manejar.</p> </li> <li>Si no se encuentra un manejador adecuado la M\u00e1quina Virtual Java muestra el error y acaba el programa.  Por ejemplo, si tenemos un programa que tiene una serie de llamadas a m\u00e9todos para hacer una divisi\u00f3n y finalmente el usuario introduce un 0 en el denominador </li> </ul> <pre><code>public class ExcepPiladellamadas {\n\n    static void incluirNumerador(){\n        Scanner sc = new Scanner(System.in);\n        System.out.print(\"Indica el numerador: \");\n        int num = sc.nextInt();\n        incluirDenominador(num);\n    }\n    static void incluirDenominador(int n){\n        Scanner sc = new Scanner(System.in);\n        System.out.print(\"Indica el denominador: \");\n        int den = sc.nextInt();//si se introduce un 0\n        realizarDivisi\u00f3n(n, den);\n    }\n\n    static void realizarDivisi\u00f3n(int n, int d){\n        System.out.println(\"La divisi\u00f3n es: \" + n/d);\n    }\n\n    public static void main(String[] args) {\n        incluirNumerador();\n    }\n\n}\n</code></pre> <p></p>"},{"location":"ud5/7exceptions/#jerarquia-de-excepciones","title":"Jerarqu\u00eda de Excepciones","text":"<p>En la clase <code>Exception</code> se encuentran las excepciones que se pueden lanzar en una aplicaci\u00f3n. Tiene varias subclases, entre ellas:</p> <ul> <li>RuntimeException: son excepciones lanzadas durante la ejecuci\u00f3n del programa. Por ejemplo: ArithmeticException, NullPointerException, ArrayIndexOutOfBoundsException, etc. y pertenecen al paquete java.lang.</li> <li>IOException: son excepciones lanzadas al ejecutar una operaci\u00f3n de entrada-salida. Pertenecen al paquete java.io.</li> <li>ClassNotFoundException: excepci\u00f3n lanzada cuando una aplicaci\u00f3n intenta cargar una clase, pero no se encuentra el fichero .class correspondiente.</li> </ul> <p>Podemos ver un resumen</p> <p></p>"},{"location":"ud5/7exceptions/#tratamiento-de-excepciones","title":"Tratamiento de excepciones","text":"<p>Un programa que trate una excepci\u00f3n, tiene  un bloque del tipo <code>try/catch</code> <pre><code>try {\n    //Instrucciones que se intentan ejecutar, si se produce una\n    //situaci\u00f3n inesperada se lanza una excepci\u00f3n\n} \ncatch(tipoExcepcion e){\n    //Instrucciones para tratar esta excepci\u00f3n\n}\ncatch(otroTipoExcepcion e){ \n    //Instrucciones para tratar esta excepci\u00f3n\n}\n    //Se pueden escribir tantos bloques catch como sean necesarios\nfinally{//opcional\n    //instrucciones que se ejecutar\u00e1n siempre despu\u00e9s de un bloque try,\n    //se haya producido o no una excepci\u00f3n\n}\n</code></pre></p> <p>Bloque try: dentro del bloque try se coloca el c\u00f3digo que podr\u00eda generar una excepci\u00f3n. </p> <p>Bloques catch: capturan y tratan una excepci\u00f3n cuando esta ocurre. Pueden existir varios bloques catch. Estos se definen directamente despu\u00e9s del bloque try. Ning\u00fan c\u00f3digo puede estar entre el final del bloque try y el comienzo del primer bloque catch. Los catch se eval\u00faan por orden, si un catch atrapa la excepci\u00f3n que ha ocurrido, se ejecuta y los dem\u00e1s no.</p> <p>Bloque finallly: es opcional e incluye c\u00f3digo que se ejecuta siempre, independientemente si se ha producido una excepci\u00f3n o no</p>"},{"location":"ud5/7exceptions/#ejemplos","title":"Ejemplos","text":"<p>El siguiente programa lee un n\u00famero entero y lo muestra. Si en la instrucci\u00f3n sc.nextInt() se introduce un n\u00famero de otro tipo o un car\u00e1cter, se lanza una excepci\u00f3n InputMismatchException que es capturada por el bloque <code>catch</code>. En este bloque se realizan las instrucciones necesarias para resolver la situaci\u00f3n y que el programa pueda continuar.</p> <p><pre><code>public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n;\n    do{\n        try{\n            System.out.print(\"Introduce un n\u00famero entero &gt; 0: \");\n            n = sc.nextInt();\n            System.out.println(\"N\u00famero introducido: \" + n);\n        }\n        catch(InputMismatchException e){\n            sc.nextLine();//retorna la tecla enter\n            n = 0;\n            System.out.println(\"Debe introducir un n\u00famero entero \"\n            + e.toString());\n        }\n    }while(n&lt;=0);\n}\n</code></pre> El siguiente ejemplo captura dos excepciones, por un lado se espera la entrada de dos enteros y por otro que el segundo no sea cero</p> <pre><code>try{\n    //produce error si no se introduce un entero\n    System.out.print(\"Introduce dividendo: \");\n    n1 = sc.nextInt();\n    System.out.println();\n    System.out.print(\"Introduce divisor: \");\n    n2 = sc.nextInt();\n    //produce un error si n2 es 0\n    System.out.println(n1/n2);            \n        }\ncatch (InputMismatchException e){\n    System.out.println(\"Error: hay que introducir un entero\");\n}\ncatch (ArithmeticException e){\n    System.out.println(\"Error: no se puede dividir por 0\");\n}\n</code></pre> <p>Importante</p> <p>Cuando se lanza una excepci\u00f3n se captura por el primer bloque catch cuyo par\u00e1metro sea de la misma clase que el objeto excepci\u00f3n o de una clase base directa o indirecta. Por este motivo, es importante el orden en que se coloquen los bloques catch.</p> <p>Las excepciones m\u00e1s gen\u00e9ricas se deben capturar al final. </p> <p>Si no es necesario tratar excepciones concretas de forma espec\u00edfica, se puede poner un bloque <code>catch</code> de una clase base que las capture todas y las trate de forma general. Esto se conoce como captura gen\u00e9rica de excepciones.</p> <p>En el siguiente ejemplo, en el \u00faltimo <code>catch</code>, se captura cualquier posible error que surja</p> <pre><code>public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int [] array = {4,2,6,7};\n    int n;\n    boolean repetir = false;\n    do{\n        try{\n            repetir = false;\n            System.out.print(\"Introduce un n\u00famero entero &gt; 0 y &lt; \" +\n                    array.length +\n                    \" \");\n            n = sc.nextInt();\n            System.out.println(\"Valor en la posici\u00f3n \" + n + \": \" +\n                    array[n]);\n        }\n        catch(InputMismatchException e){\n            sc.nextLine();\n            n = 0;\n            System.out.println(\"Debe introducir un n\u00famero entero \");\n            repetir = true;\n        }\n        catch(IndexOutOfBoundsException e){\n            System.out.println(\"Debe introducir un n\u00famero entero &gt; 0 y &lt;\" + array.length + \" \");\n            repetir = true;\n        }\n        // resto de excepciones de tipo Exception y derivadas\n        catch(Exception e){ \n            System.out.println(\"Error inesperado \" + e.toString());\n            repetir = true;\n        }\n    }while(repetir);\n}\n</code></pre>"},{"location":"ud5/7exceptions/#tipo-de-exepciones","title":"Tipo de exepciones","text":"<p>En Java, hay dos tipos de excepciones:</p> <ul> <li>Checked exceptions (Excepciones verificadas).</li> <li>Unchecked exceptions (Excepciones no verificadas).</li> </ul> <p></p>"},{"location":"ud5/7exceptions/#checked-exceptions","title":"Checked exceptions","text":"<p>Estas son las excepciones que se comprueban en tiempo de compilaci\u00f3n, es decir, un m\u00e9todo debe hacer algo al respecto sino el programa no compila. El programador est\u00e1 obligado a tratarla. </p> <p>No son culpa del programador de Java. Por ejemplo, un programa que debe acceder a una imagen en una carpeta. Si esa imagen no se encuentra en la ubicaci\u00f3n esperada porque alguien la ha movido, borrado o cambiado el nombre, dar\u00e1 error, no siendo responsabilidad del programador.</p> <p>Si alg\u00fan c\u00f3digo dentro de un m\u00e9todo arroja una excepci\u00f3n verificada, entonces el m\u00e9todo puede una de las dos posibilidades:</p> <ol> <li>Manejar la excepci\u00f3n en un bloque <code>try-catch{}</code></li> </ol> <pre><code>public void leerFichero(String[] a) {\n   try {\n           //c\u00f3digo java manejo de ficheros\n    } catch (IOException e) {\n        // Capturamos la excepci\u00f3n en caso de que ocurra y manejamos el error\n        System.err.println(\"Error de entrada/salida (IOException): \" + e.getMessage());\n        e.printStackTrace();\n    }\n}\n</code></pre> <ol> <li><code>throws</code> (lanzar) la excepci\u00f3n al que invoca el m\u00e9todo.</li> </ol> <pre><code>public void leerFichero(String[] a) throws IOException {\n    //c\u00f3digo java manejo de ficheros\n}\n</code></pre> <p>En el ejemplo, <code>IOException</code> es una checked exception. Este m\u00e9todo lanza una IOException cuando hay un problema de lectura.</p> <p>La palabra reservada <code>throws</code> dice que este m\u00e9todo no captura la excepci\u00f3n <code>IOException</code> con un <code>catch</code>, sino que cuando ocurra una, se lanzar\u00e1 al m\u00e9todo que llama el m\u00e9todo <code>leerFichero</code>.</p> <p>Si hici\u00e9ramos esto en un m\u00e9todo <code>main</code>, podemos capturar la excepci\u00f3n lanzada por el m\u00e9todo.</p> <pre><code>public static void main(String[] args) throws IOException {\n    try {\n          leerFichero();\n    } catch (IOException e) {\n        // Capturamos la excepci\u00f3n en caso de que ocurra y manejamos el error\n        System.err.println(\"Error de entrada/salida (IOException): \" + e.getMessage());\n        e.printStackTrace();\n    }\n\n}\n</code></pre>"},{"location":"ud5/7exceptions/#unchecked-exceptions","title":"Unchecked exceptions","text":"<p>Ocurren en tiempo de compilaci\u00f3n, es decir, no se verifican por el compilador. En Java, las excepciones en las clases RunTimeException y Error y sus subclases son unchecked exceptions todo lo dem\u00e1s es es checked.</p> <p>Depende de los programadores especificar o detectar las excepciones unchecked. Por ejemplo, imagina que tenemos el siguiente programa Java se compila sin erorres:</p> <pre><code>public static void main(String[] args) {\n    int x = 0;\n    int y = 10;\n    int z = y / x;\n}\n</code></pre> <p>El compilador nos deja compilar la aplicaci\u00f3n porque <code>ArithmeticException</code> es una excepci\u00f3n no verificada, pero al ejecutar el programa se lanza la excepci\u00f3n, por tanto, nosotros tendremos que darnos cuenta y controlar este tipo de excepciones.</p>"},{"location":"ud5/7exceptions/#diferencias-entre-checked-y-unchecked-exceptions","title":"Diferencias entre checked y unchecked exceptions","text":"<ul> <li>Una checked exception se detecta en tiempo de compilaci\u00f3n, mientras que una unchecked exception en tiempo de ejecuci\u00f3n.</li> <li>Una checked exception debe manejarse o bien con volvi\u00e9ndola a lanzar con un <code>throw</code> o con un bloque <code>try catch</code>, mientras que una unchecked exception no requiere ser manejada.</li> <li>Una unchecked exception es un error de programaci\u00f3n y es fatal, mientras que una checked exception es una condici\u00f3n de excepci\u00f3n dentro de la l\u00f3gica de su c\u00f3digo y se puede recuperar o volver a intentar.</li> </ul>"},{"location":"ud5/7exceptions/#throwable","title":"Throwable","text":"<p><code>Throwable</code> es la superclase de todas las excepciones y errores. Se podria capturar en un bloque <code>try-catch</code>, \u00a1pero nunca se debe hacer!, ya que, no solo capturar\u00e1 todas las excepciones; sino que tambi\u00e9n har\u00e1 lo mismo con todos los errores que genere la aplicacion.</p> <p>La JVM arroja errores para indicar problemas graves que no est\u00e1n destinados a ser manejados por una aplicaci\u00f3n.</p> <p>Ejemplos t\u00edpicos de eso son <code>OutOfMemoryError</code> o <code>StackOverflowError</code>. Ambos son causados por situaciones que est\u00e1n fuera del control de la aplicaci\u00f3n y no se pueden manejar.</p> <p>Por lo tanto, es mejor que NUNCA captures un Throwable.</p>"},{"location":"ud5/7exceptions/#relanzar-una-excepcion","title":"Relanzar una excepci\u00f3n","text":"<p>Java permite al programador lanzar excepciones mediante la palabra reservada throw:</p> <p>throw objetoExcepcion;</p> <p>La excepci\u00f3n que se lanza es un objeto, por lo que hay que crearlo como cualquier otro objeto mediante new.</p> <pre><code>if (n==0) throw new ArithmeticException(\u201cDivisi\u00f3n por cero\u201d);\n</code></pre>"},{"location":"ud5/7exceptions/#argumentos-protegidos-mediante-excepciones","title":"Argumentos protegidos mediante excepciones","text":"<p>Los m\u00e9todos y los setter de una clase pueden necesitar ciertas caracter\u00edsticas que se deben cumplir debido a las especificaciones del problema. Por ejemplo, al introducir una nota de un alumno tiene que estar en el rango de 0..10</p> <p>Enviar un mensaje desde la propia clase al usuario puede que no sea procedente ya que la clase tiene que ocuparse de que los datos sean correctos pero no de interactuar con el usuario. Piensa en un entorno gr\u00e1fico.</p> <p>Podemos lanzar excepciones cuando se trate de introducir un valor ilegal y que se trate el error m\u00e1s arriba</p> <p><pre><code>public class Nota {\n    String asignatura;\n    int nota;\n\n    public Nota(String asignatura) {\n        this.asignatura = asignatura;\n    }\n\n    public int getNota() {\n        return nota;\n    }\n\n    public void setNota(int nota) {\n        //si la nota no cumple las especificaciones, lanzamos una excepci\u00f3n\n        if(nota&lt;0 || nota &gt;10)\n            throw new IllegalArgumentException(\"La nota tiene que estar en el rango 0..10\");\n        this.nota = nota;\n    }\n\n    public static void main(String[] args) {\n        Nota programacion=new Nota(\"Programaci\u00f3n\");\n        programacion.setNota(11);\n    }\n}\n</code></pre> En este ejemplo, el programa termina porque no se ha capturado la excepci\u00f3n</p> <p></p> <p>Lo correcto es controlar la  excepci\u00f3n. De esta forma, podemos leer del usuario la nota y controlar mediante excepciones el valor correcto</p> <pre><code>public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    Nota programacion = new Nota(\"Programaci\u00f3n\");\n    boolean esCorrecto = true;\n    int valorNota;\n    do {//mientras la nota no sea correcta salta la excepci\u00f3n\n        esCorrecto = true;\n        try {\n            System.out.println(\"Introduzca una nota entre 0..10\");\n            valorNota = sc.nextInt();\n            //si no es correcta, salta la excepci\u00f3n\n            programacion.setNota(valorNota);\n\n        } catch (IllegalArgumentException e) {\n            esCorrecto = false;\n        }\n    } while (!esCorrecto);\n\n}\n</code></pre>"},{"location":"ud5/7exceptions/#throws-incluir-en-la-firma-del-metodo-la-excepcion","title":"throws: Incluir en la firma del m\u00e9todo la excepci\u00f3n","text":"<p>Podemos indicar en la firma del m\u00e9todo que puede lanzar una excepci\u00f3n. Esto se indica con la palabra clave <code>throws</code></p> <p><pre><code> public void setNota(int nota) throws IllegalArgumentException {\n    //si la nota no cumple las especificaciones, lanzamos una excepci\u00f3n\n    if(nota&lt;0 || nota &gt;10)\n        throw new IllegalArgumentException(\"La nota tiene que estar en el rango 0..10\");\n    this.nota = nota;\n}\n</code></pre> \u00bfEs obligatorio poner <code>throws</code>?</p> <ul> <li><code>unchecked exception</code>: No, no es obligatorio si es una excepci\u00f3n no comprobada  . Pero es conveniente para que se vea en la firma  y sepa que puede lanzar una excepci\u00f3n</li> </ul> <p></p> <ul> <li><code>checked exceptions</code>: S\u00ed, en el caso de excepciones comprobadas. Para excepciones como <code>IOException</code>, es obligatorio declararlas con <code>throws</code></li> </ul>"},{"location":"ud5/7exceptions/#excepciones-personalizadas","title":"Excepciones personalizadas","text":"<p>Aunque las excepciones de Java cubren casi todas las excepciones generales que est\u00e1n obligadas a ocurrir en la programaci\u00f3n. Sin embargo, a veces necesitamos complementar estas excepciones est\u00e1ndar con las nuestras.</p> <p>Estas son las principales razones para introducir excepciones personalizadas:</p> <ul> <li>A\u00f1adir excepciones que son espec\u00edficas de la l\u00f3gica de nuestra aplicaci\u00f3n o empresa. Ayudan a los usuarios de la aplicaci\u00f3n o a los desarrolladores a comprender cu\u00e1l es el problema exacto.</li> <li>Para capturar y proporcionar un tratamiento espec\u00edfico a un subconjunto de excepciones de Java existentes.</li> <li>A\u00f1adir nuevos m\u00e9todos o atributos que no son parte de las excepciones est\u00e1ndar.</li> </ul>"},{"location":"ud5/7exceptions/#buenas-practicas-para-definir-excepciones-personalizadas","title":"Buenas pr\u00e1cticas para definir excepciones personalizadas","text":""},{"location":"ud5/7exceptions/#haz-que-tenga-sentido","title":"Haz que tenga sentido","text":"<p>Proporciona informaci\u00f3n o funcionalidad que no forma parte de las excepciones est\u00e1ndar de Java.</p> <p>Esa es la esencia de la primera y m\u00e1s importante recomendaci\u00f3n. De lo contrario, su excepci\u00f3n no brinda ning\u00fan beneficio en comparaci\u00f3n con la gran cantidad de excepciones que ya proporciona el JDK.</p> <p>Si no puede proporcionar ning\u00fan beneficio, es mejor que use una de las excepciones est\u00e1ndar, como UnsupportedOperationException o IllegalArgumentException. Todos los desarrolladores de Java ya conocen estas excepciones. Eso hace que su c\u00f3digo y API sean m\u00e1s f\u00e1ciles de entender.</p>"},{"location":"ud5/7exceptions/#sigue-la-convencion-de-nomenclatura-estandar","title":"Sigue la convenci\u00f3n de nomenclatura est\u00e1ndar","text":"<p>Cuando obsevamos las clases de excepci\u00f3n proporcionadas por el JDK, r\u00e1pidamente nos damos cuenta que todos sus nombres terminan con <code>Exception</code>. Esta convenci\u00f3n de nomenclatura general se utiliza en todo el sistema de Java. Y su excepci\u00f3n personalizada tambi\u00e9n deber\u00eda seguirlo, por ejemplo, <code>ImpresoraException</code>.</p>"},{"location":"ud5/7exceptions/#anade-javadoc-a-tu-clase-de-excepcion-personalizada","title":"A\u00f1ade Javadoc a tu clase de excepci\u00f3n personalizada","text":"<p>Las API no documentadas son muy dif\u00edciles de usar.</p> <p>Las clases de excepci\u00f3n pueden no ser la parte m\u00e1s obvia de tu API, pero siguen siendo parte de ella. Tan pronto como uno de sus m\u00e9todos orientados al cliente arroja una excepci\u00f3n, la clase de excepci\u00f3n se convierte en parte de la API. Eso implica que requiere documentaci\u00f3n y un buen Javadoc.</p> <p>El Javadoc debe describir el significado general de la excepci\u00f3n y las situaciones en las que podr\u00eda ocurrir. El objetivo es ayudar a otros desarrolladores a comprender su API y evitar escenarios de error comunes.</p>"},{"location":"ud5/7exceptions/#proporciona-un-constructor","title":"Proporciona un constructor","text":"<p>Normalmente, nuestro c\u00f3digo detectar\u00e1 una excepci\u00f3n est\u00e1ndar antes de lanzar nuestra excepci\u00f3n personalizada. Esto, no debe ocultarse ya que la excepci\u00f3n capturada generalmente contendr\u00e1 informaci\u00f3n esencial que necesitaremos para analizar el incidente.</p> <p>En el siguiente ejemplo, <code>NumberFormatException</code> proporciona informaci\u00f3n detallada sobre el error. Perder\u00e1 esta informaci\u00f3n si no la configura como la causa de <code>MyException</code>.</p> <pre><code>public void methodA(String entrada) throws MyException {\n    try {\n        // c\u00f3digo\n    } catch (NumberFormatException e) {\n        throw new MyException(\"Mensaje que describe el error.\", e, ErrorCode.INVALID_ENTRY);\n    }\n}\n</code></pre> <p><code>Exception</code> y <code>RuntimeException</code> proporcionan constructores que aceptan un <code>Throwable</code> que describe la causa de la excepci\u00f3n. Por tanto, nuestra excepci\u00f3n deber\u00eda hacer lo mismo. Debemos implementar al menos un constructor que obtenga el Throwable causante como par\u00e1metro y lo establezca en la superclase.</p>"},{"location":"ud5/7exceptions/#pasos-para-implementar-una-excepcion-personalizada","title":"Pasos para implementar una excepci\u00f3n personalizada","text":"<ol> <li>Debemos extender de la clase <code>java.lang.Exception</code>.</li> <li>Se debe proporcionar un constructor que establezca la excepci\u00f3n causante y brinde un beneficio en comparaci\u00f3n con las excepciones est\u00e1ndar disponibles.</li> </ol> <p>Ejemplo:</p> <p></p> <p></p> <p><code>MyException</code> usa un enum personalizado para almacenar un c\u00f3digo de error que identifica el problema de nuestra aplicaci\u00f3n. Los clientes pueden usar el c\u00f3digo de error para mostrar mensajes de error localizados o decirle al usuario que incluya este c\u00f3digo en un ticket de soporte.</p> <p>Para usar <code>MyException</code> en nuestra aplicaci\u00f3n o programa necesitaremos especificarlo como parte de la signatura de un m\u00e9todo o simplemente capturarla con un bloque <code>try-catch</code>.</p> <p></p> <p>Note</p> <p>Si queremos crear una excepci\u00f3n personalizada de tipo unchecked exception realizaremos el mismo procedimiento con la diferencia de que tendremos que extender de la clase <code>java.lang.RuntimeException</code>.</p>"},{"location":"ud6/1list/","title":"Estructuras de datos","text":"<p>La estructura de datos es una forma de almacenar y organizar datos de manera eficiente, de modo que las operaciones requeridas en ellos se puedan realizar de manera eficiente con respecto al tiempo y la memoria. Simplemente, la estructura de datos se utiliza para reducir la complejidad (principalmente la complejidad del tiempo) del c\u00f3digo.</p> <p>Las estructuras de datos pueden ser de dos tipos:</p> <ol> <li>Estructura de datos est\u00e1tica</li> <li>Estructura de datos din\u00e1mica</li> </ol>"},{"location":"ud6/1list/#estructuras-de-datos-estaticos","title":"Estructuras de datos est\u00e1ticos","text":"<p>En la estructura de datos est\u00e1tica, el tama\u00f1o de la estructura es fijo. El contenido de la estructura de datos se puede modificar pero sin cambiar el espacio de memoria que se le asigna. Un ejemplo de estas estructuras son los arrays que vimos en la unidad 5.</p> <p></p> <p>Aunque los arrays son muy \u00fatiles como hemos estudiado, tenemos varios inconvenientes:</p> <ul> <li>Dif\u00edcil de adaptar al tama\u00f1o del problema: Se ha de conocer el tama\u00f1o al crear el array, implica que o se pierde algo de espacio o es posible que se quede peque\u00f1o\u2026</li> <li>Posibles problemas de memoria:  En caso de gran cantidad de objetos a gestionar se ha de reservar memoria contigua, y en ocasiones esto no es sencillo.</li> <li>Manejo complejo: La inserci\u00f3n y borrado  de elementos es compleja.</li> </ul>"},{"location":"ud6/1list/#estructuras-de-datos-dinamicas","title":"Estructuras de datos din\u00e1micas","text":"<p>En la estructura de datos din\u00e1mica, el tama\u00f1o de la estructura no es fijo y puede modificarse durante las operaciones realizadas en \u00e9l. Las estructuras de datos din\u00e1micas est\u00e1n dise\u00f1adas para facilitar el cambio en tiempo de ejecuci\u00f3n y resoluci\u00f3n de muchos algoritmos. Algunas de estas estructuras son:</p>"},{"location":"ud6/1list/#listas-lineales","title":"Listas lineales","text":"<p>Una lista es una colecci\u00f3n, originalmente vac\u00eda, de elementos u objetos de cualquier tipo no necesariamente consecutivos en memoria, que durante la ejecuci\u00f3n del programa pueden crecer o decrecer elemento a elemento seg\u00fan las necesidades previstas en el mismo. Una lista est\u00e1 formada por un n\u00famero variable de datos (elementos) de un mismo tipo, ordenados seg\u00fan una secuencia lineal. Cada elemento, salvo el primero, tiene un predecesor en la lista. Todos los elementos, salvo el \u00faltimo, tienen un sucesor.</p> <p>En funci\u00f3n de la informaci\u00f3n que cada elemento de la lista almacene respecto a la localizaci\u00f3n de sus antecesores y/o predecesores, las listas pueden clasificarse en: </p> <ul> <li>listas lineales simplemente enlazadas</li> <li>listas lineales doblemente enlazadas</li> <li>listas circulares simplemente enlazadas</li> <li>listas circulares doblemente enlazadas.</li> </ul> <p>Elegir el tipo de lista depende de las necesidades del problema, con mayor coste de memoria para las estructuras m\u00e1s complejas</p> <p></p>"},{"location":"ud6/1list/#pilas","title":"Pilas","text":"<p>Una pila es una lista en la que todas las inserciones y supresiones se hacen en un extremo de la lista. Un ejemplo de esta estructura es una pila de platos. En ella, el a\u00f1adir o quitar platos se hace siempre por la parte superior de la pila. Esta estructura utiliza el principio LIFO (last-in first-out), \u00faltimo en entrar, primero en salir</p> <p></p> <p>Son estructuras necesarias en la resoluci\u00f3n de muchos algoritmos, como puede ser la evaluaci\u00f3n de expresiones matem\u00e1ticas, manejo de llamadas a funciones.</p>"},{"location":"ud6/1list/#colas","title":"Colas","text":"<p>Una cola es una lista lineal en la que todas las inserciones se hacen por un extremo de la lista (por el final) y todas las supresiones se hacen por el otro extremo (por el principio). Por ejemplo, una fila en la caja del supermercado. Este tipo de listas recibe tambi\u00e9n el nombre de listas FIFO (first in first out \u2013 primero en entrar, primero en salir)</p> <p></p> <p>Tanto pilas como colas, son utilizadas en muchos algoritmos en sistemas operativos entre otros</p>"},{"location":"ud6/1list/#arboles","title":"Arboles","text":"<p>La estructura de datos \u00e1rbol al contrario que las listas es una estructura de datos no lineal. Las listas tienen un orden impuesto en sus elementos teniendo como mucho un predecesor y un sucesor. Los \u00e1rboles pueden tener dos o m\u00e1s sucesores.</p> <p>Un \u00e1rbol consiste en un conjunto de nodos o v\u00e9rtices y un conjunto de aristas</p> <p></p> <p>Permiten crear algoritmos muy eficientes de b\u00fasqueda y ordenaci\u00f3n, as\u00ed como resoluci\u00f3n de problemas de IA entre otros.</p>"},{"location":"ud6/1list/#grafos","title":"Grafos","text":"<p>Los grafos son estructuras de datos no lineales que representan relaciones entre objetos. Debido a que no son estructuras lineales, no existe jerarqu\u00eda en las relaciones. Un grafo G(V,A) es un conjunto de v\u00e9rtices (V) y arcos (A).</p> <p></p> <p>Permiten resolver problemas como puede ser el camino m\u00e1s corto o algoritmos para los motores de b\u00fasqueda de p\u00e1ginas web. En la Api de Java no existen los Grafos, pero si que tenemos librer\u00edas que las implementan</p>"},{"location":"ud6/1list/#list","title":"List","text":"<p>Documentaci\u00f3n oficial Collections Java</p> <p></p> <p>Una lista se puede ver como un array ya que es una secuencia de elementos o colecci\u00f3n ordenada que te permite tener elementos en posiciones consecutivas.</p> <p>En Java <code>List</code> es una interfaz Java.util.List que extiende de <code>Collection</code>. Siempre conserva el orden de los elementos. Los elementos contenidos en una lista se pueden insertar, acceder, iterar y eliminar de acuerdo con el orden en que aparecen internamente en la lista. El orden de los elementos es la raz\u00f3n por la cual esta estructura de datos se llama <code>List</code>. Cada elemento en una lista de Java tiene un \u00edndice, al igual que ocurr\u00eda con los arrays.</p> <p>La interfaz de lista se implementa mediante las clases <code>ArrayList</code>, <code>LinkedList</code>, <code>Vector</code> y <code>Stack</code>. Es decir, dado que <code>List</code> es una interfaz, no se puede crear una instancia directamente. Sin embargo, uno puede crear objetos de aquellas clases que han implementado esta interfaz e instanciarlos. Por ejemplo:</p> <pre><code>List a = new ArrayList();\nList b = new LinkedList();\nList c = new Vector(); \nList d = new Stack(); \n</code></pre> <p>De estas implementaciones, <code>ArrayList</code> es la m\u00e1s utilizada.</p>"},{"location":"ud6/1list/#arraylist","title":"ArrayList","text":"<p>La primera clase de la que vamos a hablar es <code>ArrayList</code>. Un <code>ArrayList</code> como su nombre indica basa su implementaci\u00f3n de una lista en un array. Es un array din\u00e1mico en tama\u00f1o (es decir, de tama\u00f1o variable), pudiendo agrandarse el n\u00famero de elementos o disminuirse de forma autom\u00e1tica. Implementa todos los m\u00e9todos de la interfaz List y permite incluir elementos null.</p> <p>Un <code>ArrayList</code> no permite almacenar tipos de datos primitivos, solo puede almacenar objetos. Al contrario que un array que permit\u00eda almacenar ambos. Sin embargo, desde Java 5, las primitivas se convierten autom\u00e1ticamente en objetos, gracias a los Wrappers.</p> <p></p> <p><code>ArrayList</code> forma parte de <code>Collection</code> en Java. Por lo tanto, a diferencia de los arrays que para acceder a los elementos se hac\u00eda usando [], en <code>ArrayList</code> tenemos un  conjunto de m\u00e9todos para acceder a los elementos y modificarlos.</p>"},{"location":"ud6/1list/#crear-un-arraylist","title":"Crear un <code>ArrayList</code>","text":"<p>Para crear un <code>ArrayList</code> en IntelliJ escribimos:</p> <p></p> <p>Si nos fijamos nos aparece una <code>&lt;E&gt;</code>, esto quiere decir que cuando creamos un <code>ArrayList</code> no le estamos diciendo el tipo como hac\u00edamos con los arrays: <code>int[] array;</code>. Por tanto, para crear un <code>ArrayList</code> que almacena objetos necesitamos decirle qu\u00e9 tipo de datos vamos a almacenar en nuestra lista. <pre><code>// Crear una ArrayList de personas\nArrayList&lt;Persona&gt; personas = new ArrayList&lt;&gt;();\n//creamos un ArrayList de String\nArrayList&lt;String&gt; hobbies=new ArrayList&lt;String&gt;();\n//Error---&gt; No se puede definir con tipos primitivos\nArrayList&lt;int&gt; listaEntero= new ArrayList&lt;int&gt;();\n//Hay que utilizar las clases Wrapper\nArrayList&lt;Integer&gt; listaEntero= new ArrayList&lt;Integer&gt;();\n</code></pre></p> <p>En el ejemplo hemos creado una lista que contendr\u00e1 elementos de tipo <code>String</code>. Y si nos fijamos no le hemos especificado ning\u00fan tama\u00f1o como hac\u00edamos en los arrays puesto que Java maneja el tama\u00f1o por nosotros autom\u00e1ticamente.</p> <p>En muchas ocasiones veremos definido el tipo de la instancia como la interface <code>List</code></p> <pre><code>// Crear una ArrayList de personas\nList&lt;Persona&gt; personas = new ArrayList&lt;&gt;();\n//creamos un ArrayList de String\nList&lt;String&gt; hobbies=new ArrayList&lt;&gt;();\n//Hay que utilizar las clases Wrapper\nList&lt;Integer&gt; listaEntero= new ArrayList&lt;&gt;();\n</code></pre> <p>Si no indicamos el tipo, estamos creando un ArrayList de tipo <code>Object</code>, en el que cabe cualquier elemento</p> <pre><code>ArrayList lista=new ArrayList();\nlista.add(\"hola\");\nlista.add(3);\nlista.add(new Persona(\"Maria\",23));\n</code></pre>"},{"location":"ud6/1list/#metodos-principales-de-arraylist","title":"M\u00e9todos principales de ArrayList","text":"M\u00c9TODO DESCRIPCI\u00d3N size() Devuelve el n\u00famero de elementos (int). add(x) A\u00f1ade el objeto X al final. Devuelve true. add(posici\u00f3n, X) Inserta el objeto X en la posici\u00f3n indicada desplazando hacia adelante el resto de elementos de la colecci\u00f3n. get(posici\u00f3n) Devuelve el elemento que est\u00e1 en la posici\u00f3n indicada. remove(posici\u00f3n) Elimina el elemento que se encuentra en la posici\u00f3n indicada desplazando hacia atr\u00e1s el resto de los elementos de la colecci\u00f3n. Devuelve el elemento eliminado. remove(X) Elimina la primera ocurrencia del objeto X. Devuelve true si el elemento est\u00e1 en la lista. clear() Elimina todos los elementos. set(posici\u00f3n, X) Sustituye el elemento que se encuentra en la posici\u00f3n indicada por el objeto X. Devuelve el elemento sustituido. contains(x) Comprueba si la colecci\u00f3n contiene al objeto X. Devuelve true o false. indexOf() Devuelve la primera posici\u00f3n del objeto X. Si no existe devuelve -1. lastIndexOf(X) Devuelve la \u00faltima posici\u00f3n del objeto X. Si no existe devuelve -1."},{"location":"ud6/1list/#anadir-item-al-arraylist","title":"A\u00f1adir \u00edtem al <code>ArrayList</code>","text":"<p>Partimos de la siguiente clase</p> <pre><code>class Persona {\n    private String nombre;\n    private int edad;\n\n    public Persona(String nombre, int edad) {\n        this.nombre = nombre;\n        this.edad = edad;\n    }\n\n    public String getNombre() {\n        return nombre;\n    }\n\n    public int getEdad() {\n        return edad;\n    }\n\n    @Override\n    public String toString() {\n        return \"Persona [nombre=\" + nombre + \", edad=\" + edad + \"]\";\n    }\n</code></pre> <p>Para agregar un \u00edtem tenemos el m\u00e9todo <code>add</code> de la interface <code>List</code>:</p> <pre><code> // Crear una ArrayList de personas\nArrayList&lt;Persona&gt; personas = new ArrayList&lt;&gt;();       \n\n// Agregar algunas personas a la lista\npersonas.add(new Persona(\"Juan\", 25));\npersonas.add(new Persona(\"Maria\", 30));\npersonas.add(new Persona(\"Carlos\", 22));\n</code></pre> <p>El m\u00e9todo <code>add</code> agrega autom\u00e1ticamente el elemento en la lista. <code>ArrayList</code> es el que tiene toda la funcionalidad sobre d\u00f3nde guardarlo (posici\u00f3n) y cantidad de espacio para asignar. Eso es abstracto para nosotros y no tenemos que preocuparnos por ello.</p>"},{"location":"ud6/1list/#recorrer-los-elementos-del-arraylist","title":"Recorrer los elementos del <code>ArrayList</code>","text":"<p>Como ocurre con el Array, podemos recorrer la lista de varias formas:</p> <pre><code>// Mostrar la lista mediante foreach\n\nSystem.out.println(\"Lista de Personas:\");\nfor (Persona persona : listaPersonas) {\n    System.out.println(persona);\n}\n\n//Mostrar la lista mediante for\n\nSystem.out.println(\"Lista de Personas:\");\nfor(int i=0;i&lt;listaPersonas.size();i++)\n    System.out.println(listaPersonas.get(i));\n</code></pre>"},{"location":"ud6/1list/#interface-iterator-iterar-por-la-lista","title":"Interface Iterator: iterar por la lista","text":"<p>Si nos fijamos en la jerarqu\u00eda de clases para Colletions, vemos que tambi\u00e9n tenemos en la cabeza la interface Iterator.</p> <p></p> <p>Iterator proporciona un mecanismo para iterar sobre los elementos de una colecci\u00f3n de manera secuencial, permitiendo acceder a los elementos de la colecci\u00f3n uno a uno sin exponer la estructura interna de la colecci\u00f3n.</p> <p>La interfaz Iterator generalmente consta de tres m\u00e9todos clave:</p> <p><code>hasNext()</code>: Este m\u00e9todo devuelve un valor booleano que indica si hay m\u00e1s elementos en la colecci\u00f3n para ser iterados. Si devuelve true, significa que hay al menos un elemento m\u00e1s para ser recuperado; de lo contrario, si devuelve false, se ha alcanzado el final de la iteraci\u00f3n.</p> <p><code>next()</code>: Este m\u00e9todo devuelve el pr\u00f3ximo elemento de la colecci\u00f3n durante la iteraci\u00f3n. Cada llamada a este m\u00e9todo avanza la iteraci\u00f3n al siguiente elemento. </p> <p><code>remove()</code>: Algunas implementaciones de Iterator tambi\u00e9n incluyen el m\u00e9todo remove(), que elimina el elemento actual de la colecci\u00f3n durante la iteraci\u00f3n.</p> <p></p> <p>De esta forma, cualquier esctructura que implemente Iterable, puede recorrerse de la siguiente forma</p> <pre><code>//obtenemos el iterador del ArrayList\nIterator&lt;Persona&gt; iterator=listaPersonas.iterator();\nPersona persona;\n//mientras queden elementos\nwhile (iterator.hasNext()){\n    //elemento siguiente\n    persona=iterator.next();\n    System.out.println(persona);\n}\n</code></pre>"},{"location":"ud6/1list/#iterator-foreach-for","title":"Iterator-foreach-for","text":"<p>En Java, un <code>iterator</code> se utiliza en lugar de un bucle <code>foreach</code>  en ciertos casos debido a las limitaciones  de este \u00faltimo en t\u00e9rminos de modificaci\u00f3n de la colecci\u00f3n durante el recorrido. Aqu\u00ed hay algunas razones para preferir un iterator en ciertos escenarios:</p> <ul> <li>Modificaci\u00f3n durante el recorrido:El bucle foreach no permite modificar la colecci\u00f3n mientras se est\u00e1 iterando. Si intentas agregar o eliminar elementos durante un bucle foreach, se lanzar\u00e1 una excepci\u00f3n <code>ConcurrentModificationException</code>. </li> </ul> <pre><code>//----MAL----\n//el siguiente c\u00f3digo genera un error cuando borramos\n ArrayList&lt;String&gt; lugares = new ArrayList&lt;&gt;();\nlugares.add(\"Roma\");\nlugares.add(\"Toronto\");\nlugares.add(\"Amsterdam\");\nlugares.add(\"Par\u00eds\");\nlugares.add(\"Rodas\");\nfor(String s: lugares)\n    if(s.toLowerCase().contains(\"ro\"))\n        lugares.remove(s);\n</code></pre> <p>Por otro lado, si intentamos hacerlo con un for, aunque no se produzcan errores se producen situaciones inesperadas</p> <p><pre><code>//----MAL----\nArrayList&lt;String&gt; lugares = new ArrayList&lt;&gt;();\nlugares.add(\"Roma\");//a eliminar\nlugares.add(\"Toronto\");//a eliminar\nlugares.add(\"Amsterdam\");\nlugares.add(\"Par\u00eds\");\nlugares.add(\"Rodas\");//a eliminar\n//eliminamos aquello que contengan 'ro'\nfor(int i=0;i&lt;lugares.size();i++){\n    //cuando elimina 'Roma', la posici\u00f3n de 'Toronto' pasa a la posici\u00f3n 0, por lo que se lo salta\n    //cuando el siguiente ciclo es i=1\n    if(lugares.get(i).toLowerCase().contains(\"ro\"))\n        lugares.remove(i);\n}\nSystem.out.println(lugares);\n//[Toronto, Amsterdam, Par\u00eds]...toronto no tendr\u00eda que aparecer\n</code></pre> La soluci\u00f3n la encontramos con <code>iterator</code> * El <code>iterator</code>, en cambio, proporciona m\u00e9todos espec\u00edficos (<code>remove()</code>) que permiten modificar la colecci\u00f3n de manera segura durante el recorrido.</p> <pre><code>//----CORRECTO---\nArrayList&lt;String&gt; lugares = new ArrayList&lt;&gt;();\nlugares.add(\"Roma\");\nlugares.add(\"Toronto\");\nlugares.add(\"Amsterdam\");\nlugares.add(\"Par\u00eds\");\nlugares.add(\"Rodas\");\n\nIterator&lt;String&gt; it=lugares.iterator();\nwhile(it.hasNext()){\n    String s=it.next();\n    if(s.toLowerCase().contains(\"ro\"))\n        it.remove();\n}\nSystem.out.println(lugares);\n//[Amsterdam, Par\u00eds]\n</code></pre> <ul> <li>Personalizaci\u00f3n del recorrido: El <code>iterator</code> proporciona m\u00e1s flexibilidad en t\u00e9rminos de personalizaci\u00f3n del recorrido. Puedes utilizar m\u00e9todos como hasNext(), next(), y remove() para controlar el flujo del recorrido de manera m\u00e1s detallada.</li> <li>Compatibilidad con tipos espec\u00edficos: En algunas situaciones, es posible que desees utilizar un <code>iterator</code> espec\u00edfico para un tipo particular de colecci\u00f3n, como un <code>ListIterator</code> para listas. Esto permite acceder a m\u00e9todos adicionales que son espec\u00edficos de esa implementaci\u00f3n de colecci\u00f3n.</li> </ul> <p>A pesar de estas ventajas, en muchos casos, el bucle foreach es m\u00e1s simple, m\u00e1s conciso y m\u00e1s legible. Por lo tanto, la elecci\u00f3n entre un <code>iterator</code> y un bucle <code>foreach</code> depende del contexto y de los requisitos espec\u00edficos de la manipulaci\u00f3n de la colecci\u00f3n en tu c\u00f3digo.</p> <p>Ten en cuenta que las estructuras compatibles con el bucle foreach tienen implementado Iterable</p>"},{"location":"ud6/1list/#modificar-un-item-en-una-posicion-del-arraylist","title":"Modificar un \u00edtem en una posici\u00f3n del <code>ArrayList</code>","text":"<p>Para modificar sustituir un elemento de la lista, tenemos <code>set</code>, al que le pasamos el indice y el objeto</p> <pre><code>// Agregar algunas personas a la lista\nlistaPersonas.add(new Persona(\"Juan\", 25));\nlistaPersonas.add(new Persona(\"Maria\", 30));\nlistaPersonas.add(new Persona(\"Carlos\", 22));\n\nPersona teresa=new Persona(\"Teresa\",24);\n//sustituye Carlos por Teresa. Recuerda que el primer indice empiza por 0\nlistaPersonas.set(2,teresa);\n</code></pre>"},{"location":"ud6/1list/#eliminar-un-item-de-un-arraylist","title":"Eliminar un \u00edtem de un <code>ArrayList</code>","text":"<p>El m\u00e9todo <code>remove</code> elimina el elemento de la lista. Tenemos dos opciones:</p> <ul> <li> <p>Eliminar por \u00edndice: Indicamos la posici\u00f3n del elemento a eliminar <pre><code> // Agregar algunas personas a la lista\nlistaPersonas.add(new Persona(\"Juan\", 25));\nlistaPersonas.add(new Persona(\"Maria\", 30));\nlistaPersonas.add(new Persona(\"Carlos\", 22));\n\nSystem.out.println(\"tama\u00f1o lista: \"+listaPersonas.size());//3\n//Eliminamos a Juan\nlistaPersonas.remove(0);\nSystem.out.println(\"tama\u00f1o lista: \"+listaPersonas.size());//2\n</code></pre></p> </li> <li> <p>Eliminar por objeto: En este caso, la clase base del ArrayList tiene que tener sobrecargado el m\u00e9todo <code>equal</code> para que la clase ArrayList pueda encontrar el primer objeto igual al pasado por par\u00e1metro. En nuestro caso, vamos indicar que la clase Persona que dos personas son iguales si su nombre es igual</p> </li> </ul> <p><pre><code>class Persona {\n    //.....\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Persona persona = (Persona) o;\n        return Objects.equals(nombre, persona.nombre);\n    }\n}\n</code></pre> Eliminamos una persona que ArrayList encontrar\u00e1 utilizando en m\u00e9todo anterior</p> <pre><code>// Agregar algunas personas a la lista\nlistaPersonas.add(new Persona(\"Juan\", 25));\nlistaPersonas.add(new Persona(\"Maria\", 30));\nlistaPersonas.add(new Persona(\"Carlos\", 22));\n\nSystem.out.println(\"tama\u00f1o lista: \"+listaPersonas.size());//3\n//Eliminamos a Juan\nPersona juan=new Persona(\"Juan\",31);\nlistaPersonas.remove(juan);\nSystem.out.println(\"tama\u00f1o lista: \"+listaPersonas.size());//2\n</code></pre>"},{"location":"ud6/1list/#encontrar-un-elemento-en-el-arraylist","title":"Encontrar un elemento en el ArrayList","text":"<p>Como ocurre con el anterior, es necesario que la clase base tenga el m\u00e9todo <code>equals</code></p> <p>El m\u00e9todo <code>contains</code> permite saber si existe el item en el ArrayList</p> <p><pre><code>Persona juan=new Persona(\"Juan\",31);\n//si no existe, lo inserta en la lista\nif(!listaPersonas.contains(juan))\n    listaPersonas.add(juan);\n</code></pre> El m\u00e9todo <code>indexof</code> permite averiguar la posisi\u00f3n de un objeto en la lista. Si no existe, devuelve -1</p> <pre><code>Persona tere=new Persona(\"Tere\",31);\n//si no existe, devuelve -1\nint pos=listaPersonas.indexOf(tere);\n\nif(pos&gt;=0)\n    System.out.println(listaPersonas.get(pos));\n</code></pre>"},{"location":"ud6/1list/#copiar-todo-el-contenido-del-un-arraylist-a-otro","title":"Copiar todo el contenido del un <code>ArrayList</code> a otro","text":"<p>Se puede hacer de varias formas:</p> <pre><code>//Forma 1\n    ArrayList&lt;Persona&gt; otraLista = new ArrayList&lt;Persona&gt;();\n    otraLista.addAll(listaPersonas);\n\n//Forma 2\n    ArrayList&lt;Persona&gt; otraLista2 = new ArrayList&lt;Persona&gt;(listaPersonas);\n\n//Forma 3 - Copiar un ArrayList a un Array\n    Persona[] otroArray = new Persona[listaPersonas.size()];\n    otroArray = listaPersonas.toArray(otroArray);\n</code></pre>"},{"location":"ud6/1list/#ordenar-un-arraylist","title":"Ordenar un ArrayList","text":"<p>Como nos ocurr\u00eda con la clase Array, para ordenar una ArrayList, la clase base tiene que implementar la interface <code>Comparable</code> o pasarle un objeto de una clase que implemente <code>Comparator</code></p> <p>En nuestro caso, podemos indicar que las personas se comparan por su nombre</p> <p><pre><code>class Persona implements Comparable&lt;Persona&gt;{\n    //.....\n    @Override\n    public int compareTo(Persona p) {\n        return this.nombre.compareTo(p.nombre);\n    }\n</code></pre> Podemos ordenar f\u00e1cilmente  una lista de Personas</p> <pre><code> // Agregar algunas personas a la lista\nlistaPersonas.add(new Persona(\"Juan\", 25));\nlistaPersonas.add(new Persona(\"Maria\", 30));\nlistaPersonas.add(new Persona(\"Carlos\", 22));\n//ordenamos\nCollections.sort(listaPersonas);\n</code></pre> <p>En el apartado de Interface se ve con m\u00e1s detalle</p> <p>Comparable</p> <p>Comparator</p>"},{"location":"ud6/1list/#ejemplo-completo-con-arraylist-de-string","title":"Ejemplo completo con ArrayList de String","text":"<pre><code>public class ProductList {\n\n    private ArrayList&lt;String&gt; productosList = new ArrayList&lt;String&gt;();\n\n    public void addProduct(String item) {\n        productosList.add(item);\n    }\n\n    public void printProductList() {\n        System.out.println(\"Tenemos \"  + productosList.size() + \" elementos en el arrayList\");\n        for(int i = 0; i &lt; productosList.size(); i++) {\n            System.out.println(productosList.get(i));\n        }\n    }\n\n    public void modifyProductItem(int index, String newItem) {\n        productosList.set(index, newItem);\n    }\n\n    public void removeProductItem(int index) {\n        String item = productosList.get(index);\n        productosList.remove(item);\n    }\n\n    public boolean existsItem(String searchItem) {\n        return productosList.contains(searchItem);\n    }\n\n    public String findItem(String searchItem) {\n        int index = productosList.indexOf(searchItem);\n        if (index &gt;= 0) {\n            return productosList.get(index);\n        }\n        return null;\n    }\n}\n</code></pre>"},{"location":"ud6/1list/#main","title":"Main","text":"<p>Vamos a crear una clase principal <code>Main</code> con un m\u00e9todo <code>main</code>que imprimir\u00e1 un men\u00fa de opciones relacionadas con la lista de productos y realizar\u00e1 sus respectivas acciones.</p> <pre><code>public class MainList {\n\n    private static Scanner scanner = new Scanner(System.in);\n    private static ProductList productList = new ProductList();\n\n    public static void imprimirMenu() {\n        System.out.println(\"0 - Para imprimir menu\");\n        System.out.println(\"1 - Para imprimir productos\");\n        System.out.println(\"2 - Para a\u00f1adir\");\n        System.out.println(\"3 - Para modificar\");\n        System.out.println(\"4 - Para eliminar\");\n        System.out.println(\"5 - Para salir\");\n    }\n\n    public static void addItem() {\n        System.out.println(\"Inserta el producto: \");\n        productList.addProduct(scanner.nextLine());\n    }\n\n    public static void modifyItem() {\n        System.out.println(\"Inserta n\u00famero de posici\u00f3n: \");\n        int index = scanner.nextInt();\n        scanner.nextLine();\n        System.out.println(\"Escribe el nuevo producto:\");\n        String newItem = scanner.nextLine();\n        productList.modifyProductItem(index, newItem);\n    }\n\n    public static void removeItem() {\n        System.out.println(\"Inserta n\u00famero de posici\u00f3n: \");\n        int index = scanner.nextInt();\n        scanner.nextLine();\n        productList.removeProductItem(index);\n    }\n\n    public static void main(String[] args) {\n        boolean continuar = true;\n        int opcion = 0;\n        imprimirMenu();\n\n        while(continuar) {\n            System.out.println(\"Elige una opci\u00f3n: \");\n            opcion = scanner.nextInt();\n            scanner.nextLine();\n\n            switch (opcion) {\n                case 0:\n                    imprimirMenu();\n                    break;\n                case 1:\n                    productList.printProductList();\n                    break;\n                case 2:\n                    addItem();\n                    break;\n                case 3:\n                    modifyItem();\n                    break;\n                case 4:\n                    removeItem();\n                    break;\n                case 5:\n                    continuar = false;\n                    break;\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"ud6/1list/#buenas-practicas","title":"Buenas pr\u00e1cticas","text":"<p>Si nos fijamos, el m\u00e9todo para modificar un \u00edtem de la lista espera recibir un \u00edndice o posici\u00f3n donde se encuentra el elemento. Pero eso puede se peligroso, puesto que, sabemos que las posiciones empiezan por 0, pero a lo mejor el usuario no lo sabe y piensan que empiezan por 1. Por tanto, no sabemos a qu\u00e9 posici\u00f3n apunta realmente el \u00edndice que recibimos.</p> <p>Una buena pr\u00e1ctica es crear otro m\u00e9todo que se le pase el nombre, buscarlo y devolver la posici\u00f3n en la lista:</p> <pre><code>public void modifyProductItem(String newItem) {\n    int index = findItem(newItem);\n    if (index &gt;= 0) {\n        modifyProductItem(index, newItem);\n    }\n}\n\nprivate void modifyProductItem(int index, String newItem) {\n    productosList.set(index, newItem);\n}\n\npublic int findItem(String searchItem) {\n    return productosList.indexOf(searchItem);\n}\n</code></pre> <p>Ejercicio. Haz lo mismo con el m\u00e9todo de eliminar elemento.</p>"},{"location":"ud6/2linkedlist/","title":"<code>LinkedList</code>","text":"<p>Una <code>LinkedList</code> en Java es una implementaci\u00f3n de lista doblemente enlazada. Admite duplicados.</p> <p>Cada elemento de la lista almacena el enlace real al siguiente elemento de la lista as\u00ed como tambi\u00e9n el valor real que se desea almacenar.</p> <p><code>LinkedList</code> no es un array, sino una cola de dos extremos de elementos conectados entre s\u00ed. El primer elemento apunta al segundo, que apunta al tercero, y as\u00ed sucesivamente. Internamente, LinkedList se implementa utilizando la estructura de datos de lista doblemente enlazada. La principal diferencia entre una lista enlazada normal y una lista doblemente enlazada es que una lista doblemente enlazada contiene un puntero adicional, normalmente llamado puntero anterior, junto con el puntero siguiente y los datos que est\u00e1n en la lista enlazada individualmente.</p> <p></p> <p>ArrayList contiene un \u00fanico array para el almacenamiento de datos. LinkedList necesita una estructura de datos personalizada. Esta estructura de datos personalizada es conocida como Nodo. Es una peque\u00f1a clase interna que sirve como envoltorio para cada elemento.</p> <p>El primer puntero conocido como head, apunta al primer nodo y se actualiza cada vez que se inserta un nuevo nodo al principio. El puntero que apunta al \u00faltimo nodo es conocido como tail y tambi\u00e9n se actualiza cada vez que se agrega un nuevo elemento al final.</p>"},{"location":"ud6/2linkedlist/#metodos","title":"M\u00e9todos","text":""},{"location":"ud6/2linkedlist/#metodos-principales-de-linkedlist-en-java","title":"M\u00e9todos principales de LinkedList en Java","text":"Nombre del M\u00e9todo Descripci\u00f3n Ejemplo <code>add(E e)</code> A\u00f1ade un elemento al final de la lista. <code>lista.add(\"A\");</code> <code>add(int index, E e)</code> Inserta un elemento en una posici\u00f3n espec\u00edfica. <code>lista.add(1, \"B\");</code> <code>addFirst(E e)</code> Agrega un elemento al inicio de la lista. <code>lista.addFirst(\"X\");</code> <code>addLast(E e)</code> Agrega un elemento al final de la lista. <code>lista.addLast(\"Y\");</code> <code>remove()</code> Elimina el primer elemento de la lista. <code>lista.remove();</code> <code>remove(int index)</code> Elimina el elemento en la posici\u00f3n dada. <code>lista.remove(2);</code> <code>removeFirst()</code> Elimina el primer elemento de la lista. <code>lista.removeFirst();</code> <code>removeLast()</code> Elimina el \u00faltimo elemento de la lista. <code>lista.removeLast();</code> <code>get(int index)</code> Obtiene el elemento en la posici\u00f3n dada. <code>lista.get(1);</code> <code>getFirst()</code> Obtiene el primer elemento de la lista. <code>lista.getFirst();</code> <code>getLast()</code> Obtiene el \u00faltimo elemento de la lista. <code>lista.getLast();</code> <code>set(int index, E e)</code> Reemplaza el elemento en la posici\u00f3n dada. <code>lista.set(1, \"Z\");</code> <code>size()</code> Devuelve el n\u00famero de elementos en la lista. <code>lista.size();</code> <code>contains(Object o)</code> Verifica si un elemento est\u00e1 en la lista. <code>lista.contains(\"A\");</code> <code>isEmpty()</code> Comprueba si la lista est\u00e1 vac\u00eda. <code>lista.isEmpty();</code> <code>clear()</code> Elimina todos los elementos de la lista. <code>lista.clear();</code> <code>indexOf(Object o)</code> Devuelve la primera posici\u00f3n de un elemento. <code>lista.indexOf(\"B\");</code> <code>lastIndexOf(Object o)</code> Devuelve la \u00faltima posici\u00f3n de un elemento. <code>lista.lastIndexOf(\"B\");</code> <code>iterator()</code> Devuelve un iterador sobre los elementos. <code>Iterator&lt;String&gt; it = lista.iterator();</code> <code>listIterator()</code> Devuelve un <code>ListIterator</code> para recorrer la lista. <code>ListIterator&lt;String&gt; it = lista.listIterator();</code>"},{"location":"ud6/2linkedlist/#crear-y-anadir-items-en-una-linkedlist","title":"Crear y a\u00f1adir \u00edtems en una <code>LinkedList</code>","text":"<pre><code>LinkedList&lt;String&gt; lugares = new LinkedList&lt;String&gt;();\nlugares.add(\"Roma\");\nlugares.add(\"Par\u00eds\");\nlugares.add(\"Amsterdam\");\nlugares.add(\"Toronto\");\nlugares.add(\"Miami\");\nString primero = lugares.getFirst();\nString ultimo = lugares.getLast();\n</code></pre>"},{"location":"ud6/2linkedlist/#iterar-una-linkedlist","title":"Iterar una <code>LinkedList</code>","text":"<p>Para iterar una lista vamos a usar el concepto de iterador. Un iterador es una forma de acceder a cada uno de los elementos de una lista, arrayList, linkedlist, etc. Es el equivalente a un bucle for que hemos estado usando hasta ahora.</p> <pre><code>public static void printList(LinkedList&lt;String&gt; lugares) {\n    Iterator&lt;String&gt; it = lugares.iterator();\n    while (it.hasNext()) {\n        System.out.println(\"Nodo: \" + it.next());\n    }\n    System.out.println(\"-----\");\n}\n</code></pre> <p><code>i.next()</code>: primero devuelve el nodo actual y luego se mueve al siguiente elemento. Hasta que no usamos .next() no se sit\u00faa en el primer nodo. La primera l\u00ednea de c\u00f3digo solo es para montar y establecer el iterador.</p>"},{"location":"ud6/2linkedlist/#insertar-elementos-en-orden","title":"Insertar elementos en orden","text":"<p>Para insertar elementos en un orden espec\u00edfico se usa un <code>ListIterator</code> ya que proporcionar mayor flexibilidad y est\u00e1 creado para situaciones como esa. Te permite volver a los elementos anteriores.</p> <pre><code>private static boolean addInOrder(LinkedList&lt;String&gt; lugares, String newItem) {\n    ListIterator&lt;String&gt; it = lugares.listIterator();\n    while (it.hasNext()) {\n        int comparacion = it.next().compareTo(newItem);\n        if (comparacion == 0) {\n            //no queremos a\u00f1adir porque no queremos tener duplicados\n            System.out.println(\"el lugar \" + newItem + \" ya est\u00e1 incluido\");\n            return false;\n        } else if (comparacion &gt; 0) { //newItem es m\u00e1s peque\u00f1o\n            it.previous();\n            it.add(newItem);\n            return true;\n        }\n    }\n    it.add(newItem);\n    return true;\n}\n</code></pre>"},{"location":"ud6/2linkedlist/#ejemplo-de-clase-de-visitar-lugares","title":"Ejemplo de clase de Visitar Lugares","text":"<p>Utilizamos un list iterator para ir hacia adelante y hacia atr\u00e1s.</p> <pre><code>public static void visitarLugar(LinkedList&lt;String&gt; lugares) {\n        Scanner scanner = new Scanner(System.in);\n        boolean continuar = true;\n        ListIterator&lt;String&gt; it = lugares.listIterator();\n\n        if (lugares.isEmpty()) {\n            System.out.println(\"No hay lugares visitados\");\n            return;\n        } else {\n            System.out.println(\"Visitando \" + it.next());\n            imprimirMenu();\n        }\n\n        boolean haciaAdelante = true;\n        while(continuar) {\n            int opcion = scanner.nextInt();\n            scanner.nextLine();\n            switch (opcion) {\n                case 0:\n                    System.out.println(\"Se acabaron las vacaciones\");\n                    continuar = false;\n                    break;\n                case 1:\n                    if (!haciaAdelante) {\n                        if (it.hasNext())\n                            it.next();\n                        haciaAdelante = true;\n                    }\n                    if (it.hasNext()) {\n                        System.out.println(\"Visitando \" + it.next());\n                    } else {\n                        System.out.println(\"Ya no hay m\u00e1s ciudades\");\n                        haciaAdelante = false;\n                    }\n                    break;\n                case 2:\n                    if(haciaAdelante) {\n                        if (it.hasPrevious())\n                            it.previous();\n                        haciaAdelante = false;\n                    }\n                    if (it.hasPrevious()) {\n                        System.out.println(\"Visitando \" + it.previous());\n                    } else {\n                        System.out.println(\"Primera ciudad\");\n                        haciaAdelante = true;\n                    }\n                    break;\n                case 3:\n                    imprimirMenu();\n                    break;\n            }\n        }\n    }\n\n    public static void imprimirMenu() {\n        System.out.println(\"0 - Para salir\\n\" +\n                \"1 - para ir a la siguiente ciudad\\n\" +\n                \"2 - para ir a la ciudad anterior\\n\" +\n                \"3 - imprimir el men\u00fa\");\n    }\n</code></pre>"},{"location":"ud6/2linkedlist/#arraylist-vs-linkedlist","title":"ArrayList vs LinkedList","text":"<p>A nivel de programaci\u00f3n tenemos pocas diferencias. Pero internamente son diferentes y es importante tenerlo en cuanta cuando trabajamos con gran cantidad de datos donde el rendimiento puede verse afectado con la elecci\u00f3n de una u otra estructura.</p> Caracter\u00edstica <code>ArrayList</code> <code>LinkedList</code> Acceso por \u00edndice (<code>get(index)</code>) \ud83d\ude80 R\u00e1pido <code>O(1)</code> \ud83d\udc22 Lento <code>O(n)</code> Inserci\u00f3n al final (<code>add(E e)</code>) \ud83d\ude80 R\u00e1pido <code>O(1)</code> \ud83d\ude80 R\u00e1pido <code>O(1)</code> Inserci\u00f3n en el medio (<code>add(index, E e)</code>) \ud83d\udc22 Lento <code>O(n)</code> \ud83d\ude80 R\u00e1pido <code>O(1)</code> Eliminaci\u00f3n en el medio (<code>remove(index)</code>) \ud83d\udc22 Lento <code>O(n)</code> \ud83d\ude80 R\u00e1pido <code>O(1)</code> Uso de memoria \ud83d\ude80 Menor \ud83d\udc22 Mayor (por punteros) Iteraci\u00f3n (<code>for-each</code>, <code>iterator</code>) \ud83d\ude80 R\u00e1pida \ud83d\udc22 M\u00e1s lenta"},{"location":"ud6/2linkedlist/#usa-arraylist-si","title":"Usa ArrayList si:","text":"<ul> <li> <p>Accedes frecuentemente a los elementos por \u00edndice (get(index)). ArrayList permite acceso r\u00e1pido, ya que internamente usa un array.</p> </li> <li> <p>El tama\u00f1o de la lista no cambia demasiado (pocas inserciones/eliminaciones en medio). Las operaciones <code>add</code> al final son eficientes. Pero eliminar o insertar en el medio es costoso  porque hay que desplazar elementos.</p> </li> <li> <p>Necesitas eficiencia en iteraciones (for-each, for, ListIterator). ArrayList es m\u00e1s eficiente que LinkedList en iteraciones simples.</p> </li> </ul>"},{"location":"ud6/2linkedlist/#usa-linkedlist-si","title":"Usa LinkedList si:","text":"<ul> <li> <p>Realizas muchas inserciones/eliminaciones en cualquier posici\u00f3n. LinkedList es eficiente en add(index, E e) y remove(index). No requiere mover elementos, solo cambiar referencias de nodos.</p> </li> <li> <p>Trabajas con estructuras tipo pila (Stack) o cola (Queue). M\u00e9todos como <code>addFirst</code>(), <code>addLast</code>(), <code>removeFirst</code>(), <code>removeLast</code>() funcionan bien.</p> </li> <li> <p>Necesitas iteraciones con modificaciones en la lista (ListIterator). LinkedList es m\u00e1s eficiente al modificar elementos durante la iteraci\u00f3n.</p> </li> </ul>"},{"location":"ud6/3innerclass/","title":"Clases anidadas (Nested classes)","text":"<p>En Java, al igual que los m\u00e9todos, las variables de una clase tambi\u00e9n pueden tener otra clase como miembro. Java permite escribir una clase dentro de otra. La clase escrita dentro se denomina clase anidada o clase interna, y la clase que contiene la clase interna se denomina clase externa.</p>"},{"location":"ud6/3innerclass/#sintaxis","title":"Sintaxis","text":"<p>La clase <code>Outer_Demo</code> es la clase externa y la clase <code>Inner_Demo</code> es la clase interna.</p> <pre><code>class Outer_Demo {\n   class Inner_Demo {\n   }\n}\n</code></pre> <p>Las clases anidadas se dividen en dos tipos:</p> <ul> <li>Clases anidadas no est\u00e1ticas: son las llamadas clases internas (inner classes).</li> <li>Clases est\u00e1ticas anidadas.</li> </ul> <pre><code>class OuterClass {\n    ...\n    class InnerClass {\n        ...\n    }\n    static class StaticNestedClass {\n        ...\n    }\n}\n</code></pre> <p></p> <p>Una clase anidada es un miembro de su clase envolvente. Las clases anidadas no est\u00e1ticas (clases internas) tienen acceso a otros miembros de la clase envolvente, incluso si se declaran como privadas. Las clases anidadas est\u00e1ticas no tienen acceso a otros miembros de la clase envolvente. Como miembro de <code>OuterClass</code>, una clase anidada se puede declarar <code>private</code>, <code>public</code>, <code>protected</code>.</p>"},{"location":"ud6/3innerclass/#por-que-usar-clases-anidadas","title":"\u00bfPor qu\u00e9 usar clases anidadas?","text":"<ol> <li> <p>Es una forma de agrupar l\u00f3gicamente las clases que solo se usan en un lugar: si una clase es \u00fatil solo para otra clase, entonces es l\u00f3gico incrustarla en esa clase y mantener las dos juntas. Anidar tales \"clases de ayuda\" hace que su paquete sea m\u00e1s optimizado.</p> </li> <li> <p>Aumenta la encapsulaci\u00f3n: sabemos que una clase no se puede declarar <code>private</code>, pero si tenemos la clase como miembro de otra clase, entonces la clase interna se puede hacer privada. Y esto tambi\u00e9n se usa para acceder a los miembros privados de una clase.</p> </li> <li> <p>Puede conducir a un c\u00f3digo m\u00e1s legible y mantenible: anidar clases peque\u00f1as dentro de clases de nivel superior coloca el c\u00f3digo m\u00e1s cerca de donde se usa.</p> </li> </ol>"},{"location":"ud6/3innerclass/#clase-interna-inner-class-no-estatica-clase-anidada","title":"Clase Interna (Inner Class) - No est\u00e1tica clase anidada","text":"<p>Al igual que con los m\u00e9todos y variables de instancia, una clase interna est\u00e1 asociada con una instancia de su clase envolvente y tiene acceso directo a los m\u00e9todos y campos de ese objeto. Adem\u00e1s, debido a que una clase interna est\u00e1 asociada con una instancia, no puede definir ning\u00fan miembro est\u00e1tico en s\u00ed misma.</p> <p>Las clases internas son de tres tipos dependiendo de c\u00f3mo y d\u00f3nde se definan:</p> <ol> <li>Clase  - Inner Class</li> <li>Clase interna de m\u00e9todo local - Method-local Inner Class</li> <li>Clase interna an\u00f3nima - Anonymous Inner Class</li> </ol>"},{"location":"ud6/3innerclass/#inner-class","title":"Inner class","text":"<p>Crear una clase interna es bastante simple. Solo hay que escribir una clase dentro de una clase. A diferencia de una clase, una clase interna puede ser privada y una vez que declaras privada una clase interna, no se puede acceder a ella desde un objeto fuera de la clase.</p> <p>Los objetos que son instancias de una clase interna existen dentro de una instancia de la clase externa.</p> <pre><code>class OuterClass {\n\n    private int num = 32;\n\n    class InnerClass {\n\n        public int getNum() {\n            return num;\n        }\n\n    }\n}\n\npublic class Main {\n\n   public static void main(String args[]) {\n      OuterClass outer = new OuterClass();\n\n      OuterClass.InnerClass inner = outer.new InnerClass();\n      System.out.println(inner.getNum());\n   }\n}\n</code></pre> <p>Una instancia de <code>InnerClass</code> solo puede existir dentro de una instancia de <code>OuterClass</code> y tiene acceso directo a los m\u00e9todos y campos de su instancia adjunta.</p> <p>Para instanciar una clase interna, primero debe instanciar la clase externa.</p>"},{"location":"ud6/3innerclass/#clase-interna-de-metodo-local","title":"Clase interna de m\u00e9todo local","text":"<p>En Java, podemos escribir una clase dentro de un m\u00e9todo y esta ser\u00e1 de tipo local. Al igual que las variables locales, el alcance de la clase interna est\u00e1 restringido dentro del m\u00e9todo.</p> <p>Una clase interna local de m\u00e9todo solo se puede instanciar dentro del m\u00e9todo donde se define la clase interna.</p> <pre><code>public class Outerclass {\n\n    void my_Method() {\n        int num = 23;\n\n        // method-local inner class\n        class MethodInner_Demo {\n            public void print() {\n                System.out.println(\"This is method inner class \"+num);\n            }   \n        } // end of inner class\n\n        // Accessing the inner class\n        MethodInner_Demo inner = new MethodInner_Demo();\n        inner.print();\n   }\n\n   public static void main(String args[]) {\n      Outerclass outer = new Outerclass();\n      outer.my_Method();\n   }\n}\n</code></pre>"},{"location":"ud6/3innerclass/#clase-interna-anonima","title":"Clase interna an\u00f3nima","text":"<p>Una clase interna declarada sin un nombre de clase se conoce como clase interna an\u00f3nima. En el caso de clases internas an\u00f3nimas, las declaramos y las instanciamos al mismo tiempo. Por lo general, se utilizan siempre que necesite anular el m\u00e9todo de una interfaz o clase abstracta.</p> <p>Las clases an\u00f3nimas permiten hacer el c\u00f3digo m\u00e1s conciso. Permiten declarar e instanciar una clase al mismo tiempo. Son como clases locales excepto que no tienen nombre. Se usa si se necesita usar una clase local solo una vez.</p>"},{"location":"ud6/3innerclass/#ejemplo-1","title":"Ejemplo 1","text":"<pre><code>interface Greeting {\n    public void greet();\n    public void greetSomeone(String someone);\n}\n\nclass Main {\n    public static void main(String[] args) {\n        //Anonymous class\n        Greeting frenchGreeting = new Greeting() {\n            String name = \"tout le monde\";\n            public void greet() {\n                greetSomeone(\"tout le monde\");\n            }\n            public void greetSomeone(String someone) {\n                name = someone;\n                System.out.println(\"Salut \" + name);\n            }\n        };\n    }\n}\n</code></pre>"},{"location":"ud6/3innerclass/#ejemplo-2","title":"Ejemplo 2","text":"<pre><code>abstract class AnonymousInner {\n   public abstract void mymethod();\n}\n\npublic class OuterClass {\n\n   public static void main(String args[]) {\n\n      AnonymousInner inner = new AnonymousInner() {\n         public void mymethod() {\n            System.out.println(\"This is an example of anonymous inner class\");\n         }\n      };\n      inner.mymethod();\n   }\n}\n</code></pre>"},{"location":"ud6/3innerclass/#clases-anidadas-estaticas","title":"Clases Anidadas Est\u00e1ticas","text":"<p>Una clase interna est\u00e1tica es una clase anidada que es un miembro est\u00e1tico de la clase externa. Se puede acceder a ella sin instanciar la clase externa, usando otros miembros est\u00e1ticos. Al igual que los miembros est\u00e1ticos, una clase anidada est\u00e1tica no tiene acceso a las variables de instancia ni a los m\u00e9todos de la clase externa.</p> <pre><code>class MyOuter {\n   static class NestedDemo {\n   }\n}\n</code></pre> <p>Crear una instancia de una clase anidada est\u00e1tica es un poco diferente de crear una instancia de una clase interna.</p> <pre><code>class Outer {\n    private int x = 0;\n\n    static class Inner {\n        private int y = 9;\n\n        public int getY() {\n            return y;\n        }\n    }\n}\npublic class StaticNestedClass {\n    public static void main(String[] args) {\n        Outer.Inner inner = new Outer.Inner();\n        System.out.println(inner.getY());\n    }\n}\n</code></pre>"},{"location":"ud6/3innerclass/#ejemplo-combinado-clase-interna-y-clase-estatica-interna","title":"Ejemplo combinado Clase interna y clase est\u00e1tica interna","text":"<pre><code>class OuterClass {\n\n    private String outerField = \"Outer field\";\n    private static String staticOuterField = \"Static outer field\";\n\n    class InnerClass {\n        void accessMembers() {\n            System.out.println(outerField);\n            System.out.println(staticOuterField);\n        }\n    }\n\n    static class StaticNestedClass {\n        void accessMembers(OuterClass outer) {\n            // Compiler error: Cannot make a static reference to the non-static\n            //     field outerField\n            //System.out.println(outerField);\n            System.out.println(outer.outerField);\n            System.out.println(staticOuterField);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Inner class:\");\n        System.out.println(\"------------\");\n        OuterClass outerObject = new OuterClass();\n        OuterClass.InnerClass innerObject = outerObject.new InnerClass();\n        innerObject.accessMembers();\n\n        System.out.println(\"\\nStatic nested class:\");\n        System.out.println(\"--------------------\");\n        StaticNestedClass staticNestedObject = new StaticNestedClass();\n        staticNestedObject.accessMembers(outerObject);\n    }\n}\n</code></pre>"},{"location":"ud6/4map/","title":"Map","text":"<p>Aunque las estructura de datos <code>Map</code> no forma parte dentro de la jerarqu\u00eda de la interfaz <code>Collection</code>, se considera una interfaz de colecci\u00f3n principal de Java Collections Framework.</p> <p></p> <p>Un <code>Map</code> es un objeto que asigna claves a valores. Un mapa no puede contener claves duplicadas: cada clave puede asignarse a un valor como m\u00e1ximo. Sin embargo, los valores asignados a la clave pueden tener valores duplicados. La interfaz <code>Map</code> incluye m\u00e9todos para operaciones b\u00e1sicas (como put, get, remove, containsKey, containsValue, size, y empty) entre muchos otros.</p> <p></p> <p>La plataforma Java contiene tres implementaciones de <code>Map</code>: <code>HashMap</code>, <code>TreeMap</code> y <code>LinkedHashMap</code>.</p>"},{"location":"ud6/4map/#crear-un-mapa","title":"Crear un Mapa","text":"<p>Para crear un objeto <code>Map</code> podemos usar cualquiera de las implementaciones para esta interfaz (<code>HashMap</code>, <code>TreeMap</code> y <code>LinkedHashMap</code>), por ejemplo:</p> <pre><code>Map&lt;String, String&gt; idiomas = new HashMap&lt;&gt;();\n</code></pre>"},{"location":"ud6/4map/#anadir-claves-y-valores-en-un-mapa","title":"A\u00f1adir claves y valores en un mapa","text":"<p>Para a\u00f1adir un par de clave-valor al mapa usamos el m\u00e9todo <code>put</code>:</p> <pre><code>public class MainMap {\n\n    public static void main(String[] args) {\n        Map&lt;String, String&gt; idiomas = new HashMap&lt;&gt;();\n        idiomas.put(\"es\", \"Espa\u00f1ol\");\n        idiomas.put(\"en\", \"English EEUU\");\n        idiomas.put(\"ca\", \"English Canad\u00e1\");\n        idiomas.put(\"de\", \"Aleman\");\n        idiomas.put(\"fr\", \"Franc\u00e9s\");\n        idiomas.put(\"it\", \"Italian\");\n    }\n}\n</code></pre> <p>Las claves de los mapas son \u00fanicas, si intentamos a\u00f1adir un nuevo valor para una clave que ya existe, el valor es sobreescrito.</p> <p>Para saber si estamos agregando una nueva clave o solo modificando el valor, el m\u00e9todo <code>put</code> nos ayuda, ya que devuelve el valor anterior asociado con la clave, o <code>null</code> si no hubo asignaci\u00f3n para la clave antes.</p> <p>Ejemplo:</p> <pre><code>Map&lt;String, String&gt; idiomas = new HashMap&lt;&gt;();\n\nidiomas.put(\"es\", \"Espa\u00f1ol\");\nidiomas.put(\"en\", \"English EEUU\");\nidiomas.put(\"ca\", \"English Canad\u00e1\");\nidiomas.put(\"de\", \"Aleman\");\nidiomas.put(\"fr\", \"Franc\u00e9s\");\nSystem.out.println(idiomas.put(\"it\", \"Italian\")); //devuelve null\nSystem.out.println(idiomas.put(\"it\", \"Italiano\")); //devuelve el valor previo \"Italian\", lo que significa que se ha sobreescrito\n</code></pre>"},{"location":"ud6/4map/#obtener-el-valor-para-una-clave","title":"Obtener el valor para una clave","text":"<p>Para obtener el valor asociado a una clave usamos el m\u00e9todo <code>get</code>:</p> <pre><code>String valor = idiomas.get(\"it\");\n</code></pre>"},{"location":"ud6/4map/#comprobar-si-una-clave-o-valor-existe","title":"Comprobar si una clave o valor existe","text":"<pre><code>if (idiomas.containsKey(\"es\")) {\n    System.out.println(\"La clave es ya existe\");\n}\n\nif (idiomas.containsValue(\"Espa\u00f1ol\")) {\n    System.out.println(\"El idioma espa\u00f1ol ya existe\");\n}\n</code></pre>"},{"location":"ud6/4map/#imprimir-todos-los-valores-del-map","title":"Imprimir todos los valores del <code>Map</code>","text":"<p>Lo haremos de la siguiente forma:</p> <pre><code>for(String key: idiomas.keySet()) {\n    System.out.println(key + \" \" + idiomas.get(key));\n}\n</code></pre> <p>Al imprimir vemos que las claves no aparecen en ning\u00fan orden, ni en el que las hemos introducido ni en orden alfab\u00e9tico. Los elementos del <code>HashMap</code> no est\u00e1n ordenados.</p>"},{"location":"ud6/4map/#imprimir-cada-una-de-las-entradas-del-mapa","title":"Imprimir cada una de las entradas del mapa","text":"<p>Si queremos recorrer las entradas del mapa usaremos:</p> <pre><code>for (Map.Entry&lt;String, String&gt; entradaMapa: idiomas.entrySet()) {\n    System.out.println(entradaMapa.getKey() + \" \" + entradaMapa.getValue());\n}\n</code></pre>"},{"location":"ud6/4map/#eliminar-una-entrada-clave-valor-de-un-map","title":"Eliminar una entrada clave-valor de un <code>Map</code>","text":"<p>Tenemos dos formas de eliminar:</p> <ol> <li>Eliminar desde una clave existente, o</li> <li>Eliminar un par clave-valor existente.</li> </ol> <pre><code>//Forma 1\nboolean eliminado = idiomas.remove(\"fr\");\n\n//Forma 2\nif (idiomas.remove(\"de\", \"Ingles\")) {\n    System.out.println(\"de ha sido eliminado\");\n} else {\n    System.out.println(\"No existe un par clave-valor con de-Ingles\");\n}\n</code></pre>"},{"location":"ud6/4map/#reemplazar-el-valor-de-una-clave","title":"Reemplazar el valor de una clave","text":"<pre><code>idiomas.replace(\"es\", \"Spain\");\nidiomas.replace(\"en\", \"English\", \"English EEUU\");//Reemplazo el antiguo valor por el nuevo, pero antes me aseguro que el antiguo valor sea ese dato antes de cambiarlo\n</code></pre>"},{"location":"ud6/4map/#hashmap","title":"<code>HashMap</code>","text":"<p><code>HashMap</code> es una estructura de datos que implementa la <code>Map&lt;Key,Value&gt;</code> interfaz y se basa en el principio de hash.</p> <p>Una funci\u00f3n hash es una funci\u00f3n que convierte datos de entrada de cualquier tama\u00f1o (generalmente grande) en datos de tama\u00f1o fijo, generalmente compactos. El resultado de esta funci\u00f3n de trabajo se llama c\u00f3digo hash.</p> <p>Cada objeto Java tiene un c\u00f3digo hash. Suele ser un n\u00famero y se calcula utilizando el m\u00e9todo hashCode de la clase Object.</p>"},{"location":"ud6/5set/","title":"Set (Conjunto)","text":"<p>La interfaz <code>Set</code> est\u00e1 contenida en el paquete java.util y extiende de la interfaz Collection, es una colecci\u00f3n desordenada de objetos en los que no se pueden almacenar valores duplicados. Esta interfaz contiene los m\u00e9todos heredados de la interfaz Collection y agrega una funci\u00f3n que restringe la inserci\u00f3n de elementos duplicados.</p> <p></p> <p>La interfaz <code>Set</code> define los m\u00e9todos b\u00e1sicos de a\u00f1adir, eliminar, comprobar tama\u00f1o, si est\u00e1 vac\u00edo, tambi\u00e9n podemos verificar si un elemento existe en el conjunto (Set). Pero no hay forma de obtener un elemento del conjunto. Es decir, podemos comprobar que algo existe y podemos iterar sobre los elementos del conjunto, pero no es posible obtener, por ejemplo, el elemento 3 del conjunto.</p> <p>Dado que <code>Set</code> es una interfaz, debe instanciar una implementaci\u00f3n concreta de la interfaz para poder usarla. Puede elegir entre las siguientes implementaciones de Set en la API de colecciones de Java:</p> <ul> <li>java.util.EnumSet</li> <li>java.util.HashSet</li> <li>java.util.LinkedHashSet</li> <li>java.util.TreeSet</li> </ul> <p>Una de las mejores implementaciones (con mejor rendimiento) de la interfaz <code>Set</code> es la clase <code>HashSet</code>, que utiliza tablas hashes para almacenar los elementos. Es muy parecido a la clase <code>HashMap</code> que hemos utilizado anteriormente.</p>"},{"location":"ud6/5set/#crear-un-set","title":"Crear un Set","text":"<p>Puedo crearme <code>Set</code> gen\u00e9rico sin especificar el tipo:</p> <pre><code>        Set setA = new HashSet();\n        Set setB = new LinkedHashSet();\n        Set setC = new TreeSet();\n</code></pre> <pre><code>Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();\n</code></pre>"},{"location":"ud6/5set/#anadir-elementos-en-un-set","title":"A\u00f1adir elementos en un Set","text":"<pre><code>Set&lt;String&gt; setA = new HashSet&lt;&gt;();\n\nsetA.add(\"element 1\");\nsetA.add(\"element 2\");\nsetA.add(\"element 3\");\n</code></pre>"},{"location":"ud6/5set/#recorrer-los-elementos-de-un-set","title":"Recorrer los elementos de un Set","text":"<p>Hay dos formas de iterar los elementos de un Java Set:</p> <ul> <li>Utilizando un <code>Iterator</code> obtenido de la interfaz <code>Set</code>.</li> <li>Usando un bucle for-each.</li> </ul> <p>Al iterar los elementos en el <code>Set</code>, el orden de los elementos depende de la implementaci\u00f3n que utilicemos para crear el <code>Set</code>.</p>"},{"location":"ud6/5set/#con-iterator","title":"Con Iterator","text":"<pre><code>Set&lt;String&gt; setA = new HashSet&lt;&gt;();\n\nsetA.add(\"element 1\");\nsetA.add(\"element 2\");\nsetA.add(\"element 3\");\n\nIterator&lt;String&gt; iterator = set.iterator();\n\nwhile(iterator.hasNext(){\n  String element = iterator.next();\n}\n</code></pre>"},{"location":"ud6/5set/#con-bucle-for-each","title":"Con bucle for-each","text":"<pre><code>Set&lt;Integer&gt; set = new HashSet();\n\nfor(Integer num: set) {\n    System.out.println(num);\n}\n</code></pre> <p>Si me he creado un set gen\u00e9rico, tengo que hacer un cast del objeto:</p> <pre><code>Set set = new HashSet();\n\nfor(Object object : set) {\n    String element = (String) object;\n}\n</code></pre>"},{"location":"ud6/5set/#eliminar-elemento-de-un-set","title":"Eliminar elemento de un Set","text":"<pre><code>set.remove(\"object-to-remove\");\n</code></pre> <p>No hay forma de eliminar un objeto basado en el \u00edndice en un <code>Set</code>, ya que el orden de los elementos depende de la implementaci\u00f3n.</p>"},{"location":"ud6/5set/#eliminar-todos-los-elementos-de-un-set","title":"Eliminar todos los elementos de un Set","text":"<p>Para eliminar todos los elementos usamos el m\u00e9todo <code>clear()</code>:</p> <pre><code>set.clear();\n</code></pre>"},{"location":"ud6/5set/#tamano-de-un-set","title":"Tama\u00f1o de un Set","text":"<p>Para verificar el tama\u00f1o de un <code>Set</code> en Java se usa el m\u00e9todo size(). El tama\u00f1o de un Conjunto es el n\u00famero de elementos contenidos en el Conjunto.</p> <pre><code>Set&lt;String&gt; set = new HashSet&lt;&gt;();\n\nset.add(\"123\");\nset.add(\"456\");\nset.add(\"789\");\n\nint size = set.size();//el tama\u00f1o ser\u00e1 3\n</code></pre>"},{"location":"ud6/5set/#comprobar-si-esta-vacio","title":"Comprobar si est\u00e1 vac\u00edo","text":"<pre><code>Set&lt;String&gt; set = new HashSet&lt;&gt;();\n\nboolean isEmpty = set.isEmpty();\n</code></pre>"},{"location":"ud6/5set/#verificar-si-contiene-un-elemento","title":"Verificar si contiene un elemento","text":"<p>Para determinar si un conjunto contiene el elemento, se llama al m\u00e9todo <code>contains</code>, que internamente iterar\u00e1 sobre todos sus elementos y comparar\u00e1 cada elemento con el objeto pasado como par\u00e1metro. La comparaci\u00f3n utiliza el m\u00e9todo de <code>equals</code> de Java del elemento para verificar si el elemento es igual al par\u00e1metro.</p> <pre><code>Set&lt;String&gt; set = new HashSet&lt;&gt;();\n\nset.add(\"123\");\nset.add(\"456\");\n\nboolean contains123 = set.contains(\"123\");//devuelve true\n</code></pre> <p>Dado que es posible agregar valores nulos a un conjunto, tambi\u00e9n es posible verificar si el conjunto contiene un valor nulo. As\u00ed es como verifica si un conjunto contiene un valor nulo:</p> <pre><code>Set&lt;String&gt; set = new HashSet&lt;&gt;();\nset.add(null);\nboolean containsElement = set.contains(null);\n</code></pre>"},{"location":"ud6/5set/#convertir-set-en-list","title":"Convertir Set en List","text":"<p>Puede convertir los elementos de un <code>Set</code> en una <code>List</code> llamamos al m\u00e9todo addAll(), pasando el conjunto como par\u00e1metro.</p> <pre><code>Set&lt;String&gt; set = new HashSet&lt;&gt;();\nset.add(\"123\");\nset.add(\"456\");\n\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.addAll(set);\n</code></pre>"},{"location":"ud6/5set/#necesidad-de-sobreescribir-o-anular-metodo-equals-y-hashcode","title":"Necesidad de sobreescribir o anular m\u00e9todo <code>equals()</code> y <code>hashCode()</code>","text":"<p><code>HashMap</code> y <code>HashSet</code> usan el valor del c\u00f3digo hash de un objeto para averiguar c\u00f3mo se almacenar\u00eda el objeto en la colecci\u00f3n y, posteriormente, el c\u00f3digo hash se usa para ayudar a localizar el objeto en la colecci\u00f3n. La recuperaci\u00f3n de hash implica:</p> <ul> <li>Primero, encontrar el correcto lugar donde est\u00e1 almacenado usando hashCode().</li> <li>Segundo, buscar el elemento correcto usando equals().</li> </ul>"},{"location":"ud6/5set/#ejemplo","title":"Ejemplo","text":"<p>Cuando llamamos <code>map.put(g1, \u201cMARKETING\u201d);</code> generar\u00e1 un hash en alguna ubicaci\u00f3n y cuando llamemos a <code>map.put(g2, \"IT\");</code> generar\u00e1 el mismo valor hash (igual que g1) y reemplazar\u00e1 el primer valor por el segundo valor porque al iterar sobre la estructura encuentra que k.equals(g2) es verdadero, significa que la clave de b\u00fasqueda ya existe. Entonces, reemplaza el valor anterior de esa clave por un valor nuevo.</p> <p>Cuando Java compara dos objetos en estructuras de tipo hash (HashMap, HashSet etc) primero invoca al m\u00e9todo hashcode y luego el equals. Si los m\u00e9todos hashcode de cada objeto devuelven diferente hash no seguir\u00e1 comparando y considerar\u00e1 a los objetos distintos. En el caso en el que ambos objetos compartan el mismo hashcode Java invocar\u00e1 al m\u00e9todo equals() y revisar\u00e1 a detalle si se cumple la igualdad. De esta forma las b\u00fasquedas quedan simplificadas en estructuras hash.</p> <pre><code>class Persona {\n\n    private String name;\n    private int id;\n\n    Persona(String name, int id) {\n        this.name = name;\n        this.id = id;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Persona persona = (Persona) o;\n        return id == persona.id &amp;&amp; Objects.equals(nombre, persona.nombre);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(nombre, id);\n    }\n}\n\n\npublic static void main(String[] args) {\n    Persona p1 = new Persona(\"Patricia\", 1);\n    Persona p2 = new Persona(\"Patricia\", 1);\n\n    Set&lt;Persona&gt; conjunto = new HashSet&lt;Persona&gt;();\n    conjunto.add(p1);\n    conjunto.add(p2);\n\n    System.out.println(conjunto.contains(p1));\n}\n</code></pre>"},{"location":"ud6/5set/#operaciones-con-set","title":"Operaciones con <code>Set</code>","text":"<p>Dado que <code>Set</code> representa un conjunto, podemos realizar todas las operaciones matem\u00e1ticas b\u00e1sicas como intersecci\u00f3n, uni\u00f3n y diferencia.</p> <p>Supongamos que tenemos dos conjuntos, es decir, conjunto1 = [22, 45, 33, 66, 55, 34, 77] y conjunto2 = [33, 2, 83, 45, 3, 12, 55]. Podemos realizar la siguiente operaci\u00f3n en el Set:</p> <p></p> <ul> <li>Intersecci\u00f3n: La operaci\u00f3n de intersecci\u00f3n devuelve todos aquellos elementos que est\u00e1n presentes en ambos conjuntos. La intersecci\u00f3n de set1 y set2 ser\u00e1 [33, 45, 55].</li> <li>Uni\u00f3n: la operaci\u00f3n de uni\u00f3n devuelve todos los elementos de set1 y set2 en un solo conjunto, y ese conjunto puede ser set1 o set2. La uni\u00f3n de set1 y set2 ser\u00e1 [2, 3, 12, 22, 33, 34, 45, 55, 66, 77, 83].</li> <li>Diferencia: La operaci\u00f3n de diferencia elimina los valores del conjunto que est\u00e1n presentes en otro conjunto. La diferencia de set1 y set2 ser\u00e1 [66, 34, 22, 77].</li> </ul> <p>En <code>Set</code>, el m\u00e9todo <code>addAll()</code> se usa para realizar la uni\u00f3n, el m\u00e9todo de <code>retainAll()</code> se usa para realizar la intersecci\u00f3n y el m\u00e9todo <code>removeAll()</code> se usa para realizar la diferencia.</p>"},{"location":"ud6/6ordercollections/","title":"Colecciones ordenadas","text":"<p>Vamos a estudiar una variante del <code>HashMap</code> y <code>HashSet</code>, el <code>LinkedHashMap</code> y <code>LinkedHashSet</code>.</p> <p>Tambi\u00e9n est\u00e1n las versiones ordenadas del <code>HashMap</code> y el <code>HashSet</code> que son <code>TreeMap</code> y <code>TreeSet</code>.</p> <p>Como las operaciones entre <code>Map</code> y <code>Set</code> son muy similares nos centraremos en los mapas.</p>"},{"location":"ud6/6ordercollections/#linkedhashmap","title":"<code>LinkedHashMap</code>","text":"<p>La clase <code>LinkedHashMap</code> es como <code>HashMap</code> con una caracter\u00edstica adicional de mantener el orden de elementos insertados en ella.</p> <p><code>HashMap</code> proporciona la ventaja de una r\u00e1pida inserci\u00f3n, b\u00fasqueda y borrado, pero NO mantiene el orden en el que se insertan los elementos. Con <code>LinkedHashMap</code> se puede acceder a los elementos en su orden de inserci\u00f3n.</p>"},{"location":"ud6/6ordercollections/#caracteristicas","title":"Caracter\u00edsticas","text":"<ul> <li>Un LinkedHashMap contiene valores basados en la clave.Implementa la interfaz del mapa y extiende la clase HashMap.</li> <li>Contiene solo elementos \u00fanicos.</li> <li>Solo puede tener una clave nula pero varios valores nulos.</li> <li>Es lo mismo que <code>HashMap</code> con una caracter\u00edstica adicional que mantiene el orden de inserci\u00f3n.</li> </ul> <p>Los datos se almacenan en forma de nodos. La implementaci\u00f3n de <code>LinkedHashMap</code> es muy similar a una lista doblemente enlazada. Por lo tanto, cada nodo del LinkedHashMap est\u00e1 representado como:</p> <p></p> <ul> <li>Hash: Todas las claves (keys) de entrada se convierten en un hash, que es una forma m\u00e1s corta de la clave para que la b\u00fasqueda y la inserci\u00f3n sean m\u00e1s r\u00e1pidas.</li> <li>Key: Dado que esta clase extiende <code>HashMap</code>, los datos se almacenan en forma de par clave-valor. Este par\u00e1metro es la clave de los datos.</li> <li>Value: Para cada clave, hay un valor asociado con \u00e9l.</li> <li>After: Dado que LinkedHashMap almacena la orden de inserci\u00f3n, contiene la direcci\u00f3n al siguiente nodo de la lista.</li> <li>Before: Este par\u00e1metro contiene la direcci\u00f3n al nodo anterior de la lista.</li> </ul>"},{"location":"ud6/6ordercollections/#treemap","title":"<code>TreeMap</code>","text":"<p>Java TreeMap es una estructura de datos que implementa la interfaz <code>Map&lt;Key,Value&gt;</code>, se basa en un \u00e1rbol binario y ordena por clave.</p> <p><code>TreeMap</code> es una implementaci\u00f3n de Map que mantiene sus entradas ordenadas seg\u00fan el orden natural de sus claves. Para n\u00fameros significa orden ascendente, para cadenas, orden alfab\u00e9tico. Sin embargo, es posible utilizar un comparador si necesita cambiar la l\u00f3gica.</p> <p><code>HashMap</code> le permite almacenar una clave nula y varios valores nulos. <code>TreeMap</code> ordena los elementos en orden natural y no permite claves nulas porque el m\u00e9todo <code>compareTo()</code> arroja <code>NullPointerException</code> si se compara con nulo.</p>"},{"location":"ud6/7final/","title":"Keyword Final","text":"<p>Generalmente, usamos la palabra reservada <code>final</code> para definir valores constantes. Pero en realidad, los campos o atributos finales no son constantes porque pueden modificarse. Pero SOLO una vez y cualquier modificaci\u00f3n debe realizarse antes de que finalice el constructor de la clase.</p> <p>Ejemplo: Podemos asignarle final a un campo de la clase y declararlo por primera vez en el constructor.</p> <pre><code>public class TestFinal {\n\n    private final int numero;\n\n    public TestFinal(int n) {\n        numero = n;\n    }\n}\n</code></pre> <pre><code>public class TestFinal {\n\n    private final int numero = 0;\n\n    public TestFinal() {\n    }\n}\n</code></pre> <p>Ambos c\u00f3digos hacen lo mismo.</p> <p>Cuando declaramos un atributo como final, IntelliJ es listo y no nos deja implementar el m\u00e9todo setter de ese atributo.</p> <p>Cuando queremos crear una variable constante de la que ya conocemos su valor, normalmente usamos <code>static final</code> y la nombramos en may\u00fasculas. Pero una variable final que cambia para cada instancia de la clase, no se nombra en may\u00fasculas.</p>"},{"location":"ud6/7final/#final-en-la-definicion-de-clase","title":"Final en la definici\u00f3n de clase","text":"<p>Si a\u00f1adimos la palabra <code>final</code> al crear una clase, lo que hacemos es NO permitir que se pueda extender de esa clase. Es decir, no puede tener hijos que hereden de ella.</p> <p>Ejemplo:</p> <pre><code>public final class Coche {\n\n}\n</code></pre>"},{"location":"ud6/7final/#final-en-la-definicion-de-metodos","title":"Final en la definici\u00f3n de m\u00e9todos","text":"<p>A veces queremos, heredar de una clase, pero no queremos que se puedan sobreescribir o anular todos los m\u00e9todos de la clase padre en los hijos porque a lo mejor son m\u00e9todos que tienen una cierta funcionalidad que no cambia. Es decir, queremos prevenir que modifiquen su comportamiento. Para realizar esto declaramos los m\u00e9todos como final.</p> <p>{++Los \u00fanicos m\u00e9todos que no pueden declararse como final son los constructores, ya que no se heredan.++}</p> <pre><code>class Perro {\n\n    @Override\n    public void mover() {\n\n    }\n\n}\npublic class Animal {\n\n    public final void comer() {\n        //este m\u00e9todo no puede sobreescribirse en los hijos\n    }\n\n    public void mover() {\n        //este m\u00e9todo se puede sobreescribir\n    }\n}\n</code></pre>"},{"location":"ud6/7final/#bloque-estaticos","title":"Bloque est\u00e1ticos","text":"<p>El bloque est\u00e1tico se usa para inicializar las variables est\u00e1ticas. Este bloque se ejecuta cuando la clase se carga en la memoria. Una clase puede tener varios bloques est\u00e1ticos, que se ejecutar\u00e1n en la misma secuencia en la que se escribieron en el programa. Se ejecutan antes que los constructores.</p> <p>Los bloques est\u00e1ticos de inicializaci\u00f3n son equivalentes a los constructores. Los constructores como bien sabemos son constructores de instancias de la clase, como no son est\u00e1ticos, se ejecutan cada vez que se crea una nueva instancia de la clase.</p> <p>Como hemos dicho, el equivalente a los constructores en su versi\u00f3n est\u00e1tica, son los bloques est\u00e1ticos de inicializaci\u00f3n, la diferencia es que el bloque est\u00e1tico SOLO se ejecuta una vez cuando se carga la clase.</p> <p>Al igual que las variables finales pueden inicializarse en el constructor. Las variables est\u00e1ticas finales pueden hacerlo en los bloques est\u00e1ticos de inicializaci\u00f3n.</p> <pre><code>class Test {\n\n   private static int num;\n   private static final int x;\n\n   static{\n      num = 68;\n      x = 9;\n  }\n\n}\n</code></pre>"},{"location":"ud6/8hashcode_equals/","title":"Necesidad de Java Equals y Hashcode","text":"<p>Los m\u00e9todos Java <code>equals()</code> y <code>hashCode()</code> est\u00e1n presentes en la clase <code>Object</code>. Como todas las clases heredan de la clase Object de forma autom\u00e1tica reciben una implementaci\u00f3n predeterminada de equals() y hashCode() sino se sobreescribe.</p> <p>El m\u00e9todo equals() sirve para comparar instancias de clases entre s\u00ed. Si usamos colecciones como las que hemos visto en el tema: ArrayList, LinkedList... muchos de sus m\u00e9todos (contains, remove, indexOf, etc.) llaman al m\u00e9todo equals internamente para encontrar el objeto. Es decir, van comparando el objeto con los que hay en la lista.</p> <p>A veces cuando creamos colecciones donde el tipo de dato es un Objeto definido por nosotros, como Persona, Coche, etc. Necesitamos de alg\u00fan m\u00e9todo que nos permita comparar objetos de este tipo.</p> <p>Los m\u00e9todos Java hashCode() y equals() se utilizan conjuntamente en implementaciones basadas en tablas Hash en Java para almacenar y recuperar datos.</p>"},{"location":"ud6/8hashcode_equals/#equals","title":"Equals","text":"<p>Lo heredamos autom\u00e1ticamente de Object de la siguiente forma:</p> <pre><code>//Dos objetos son iguales, si son el mismo objeto\npublic boolean equals(Object obj) {\n    return (this == obj);\n}\n</code></pre> <p>En ocasiones, queremos cambiar la l\u00f3gica de la implementaci\u00f3n de <code>Object</code> por otra l\u00f3gica que nos diga si dos instancias de una clase son equivalentes a pesar de tratarse de distintos objetos. Por ejemplo, teniendo en cuenta los atributos de la clase que nosotros le indiquemos para ello.</p> <p>En el siguiente ejemplo tenemos la clase Client, en nuestra l\u00f3gica dos objetos de cliente son iguales si son del mismo tipo (Client) y comparten el mismo nombre.</p> Client.java<pre><code>public class Client {\n\n    private String name;\n    private int age;\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Client client = (Client) o;\n        return Objects.equals(name, client.name);\n    }\n}\n</code></pre>"},{"location":"ud6/8hashcode_equals/#contrato-equals-hashcode","title":"Contrato equals() - hashcode()","text":"<p>Cuando utilicemos estructuras de datos basadas en hash tables como HashMap, HashSet, LinkedHashMap, LinkedHashSet, Hashtable, ... necesitamos de un contrato equals - hashcode:</p> <p>Cuando sobreescribimos el m\u00e9todo equals() en nuestra clase para cambiar la l\u00f3gica que se hereda de la clase Object, tenemos que sobreescribir el m\u00e9todo hashCode() de manera que si dos instancias de nuestra clase son iguales seg\u00fan la nueva l\u00f3gica en equals(), el m\u00e9todo hashCode() deber\u00e1 retornar el mismo valor si lo llamo para dichas instancias.</p> <p>El m\u00e9todo <code>hashcode()</code> sirve para comparar objetos de una forma m\u00e1s r\u00e1pida en estructuras Hash ya que \u00fanicamente nos devuelve un n\u00famero entero. Cuando Java compara dos objetos en estructuras de tipo hash primero invoca al m\u00e9todo hashcode y luego el equals. Si los m\u00e9todos hashcode de cada objeto devuelven diferente hash no seguir\u00e1 comparando y considerar\u00e1 a los objetos distintos. En el caso en el que ambos objetos compartan el mismo hashcode Java invocar\u00e1 al m\u00e9todo equals() y revisar\u00e1 si se cumple la igualdad.</p>"},{"location":"ud6/8hashcode_equals/#ejemplo","title":"Ejemplo","text":"<p>Muchas veces se nos olvida que la invocaci\u00f3n a los m\u00e9todos equals y hashcode forma parte intr\u00ednseca del framework de colecciones. Por ejemplo si construimos dos objetos de tipo Client y los a\u00f1adimos a un HashSet, podemos comprobar que el cliente existe utilizando el m\u00e9todo contains dentro del conjunto.</p> Main.java<pre><code>public static void main(String[] args) {\n        Client p1= new Client();\n        p1.setName(\"Patricia\");\n\n        Client p2= new Client();\n        p2.setName(\"Chema\");\n\n        Client p3= new Client();\n        p3.setName(\"Patricia\");\n\n        HashSet&lt;Client&gt; conjunto = new HashSet&lt;&gt;();\n        conjunto.add(p1);\n        conjunto.add(p2);\n        conjunto.add(p3);\n        System.out.println(conjunto.contains(p1));//true\n        System.out.println(conjunto.size());//2\n    }\n</code></pre> <p>Esto nos devolver\u00e1 true ya que el HashSet contiene este elemento. Ahora bien si nosotros sobreescribimos de forma incorrecta el hashcode con el siguiente c\u00f3digo:</p> <pre><code>    @Override\n    public int hashCode() {\n        return (int)(Math.random()*100);\n    }\n\n    public static void main(String[] args) {\n        Client p1= new Client();\n        p1.setName(\"Patricia\");\n\n        Client p2= new Client();\n        p2.setName(\"Chema\");\n\n        Client p3= new Client();\n        p3.setName(\"Patricia\");\n\n        HashSet&lt;Client&gt; conjunto = new HashSet&lt;&gt;();\n        conjunto.add(p1);\n        conjunto.add(p2);\n        conjunto.add(p3);\n        System.out.println(conjunto.contains(p1));//false\n        System.out.println(conjunto.size());//3\n    }\n</code></pre> <p>Estaremos calculando al azar el hashcode y dos objetos iguales devolver\u00e1n hashcodes diferentes. El <code>HashSet</code> nos devolver\u00e1 false cuando invoquemos el m\u00e9todo contains aunque sabemos que el elemento existe en el conjunto. Y tambi\u00e9n agregar\u00e1 duplicado ya que no encuentra el elemento.</p>"},{"location":"ud7/1generics/","title":"Gen\u00e9ricos","text":"<p>Antes de Java 5 cuando introduc\u00edamos objetos en una colecci\u00f3n estos se guardaban como objetos de tipo <code>Object</code>, aprovechando el polimorfismo para poder introducir cualquier tipo de objeto en la colecci\u00f3n. Esto nos obligaba a hacer un casting al tipo original al obtener los elementos de la colecci\u00f3n.</p> <pre><code>public class Ejemplo {  \n  public static void main(String[] args) {  \n    List lista = new ArrayList();  \n    lista.add(\"Hola mundo\");  \n\n    String cadena = (String) lista.get(0);  \n    System.out.println(cadena);  \n  }  \n} \n</code></pre> <p>Esta forma de trabajar no solo nos ocasiona tener que escribir m\u00e1s c\u00f3digo innecesariamente, sino que es propenso a errores porque carecemos de un sistema de comprobaci\u00f3n de tipos. Si introdujeramos un objeto de tipo incorrecto el programa compilar\u00eda pero lanzar\u00eda una excepci\u00f3n en tiempo de ejecuci\u00f3n al intentar convertir el objeto en <code>String</code>:</p> <pre><code>public class Ejemplo {  \n  public static void main(String[] args) {  \n    List lista = new ArrayList();  \n    lista.add(22);  \n\n    String cadena = (String) lista.get(0);  \n    System.out.println(cadena);  \n  } \n} \n</code></pre> <p>Desde Java 5 contamos con una caracter\u00edstica llamada generics que puede solventar esta clase de problemas. Los generics son una mejora al sistema de tipos que nos permite programar abstray\u00e9ndonos de los tipos de datos.</p> <p>Gen\u00e9ricos significa tipos parametrizados. La idea es permitir que el tipo (<code>Integer</code>, <code>String</code>, etc., y tipos definidos por el usuario) sea un par\u00e1metro para m\u00e9todos, clases e interfaces. Utilizando Generics, es posible crear clases que trabajen con diferentes tipos de datos. Una entidad como clase, interfaz o m\u00e9todo que opera en un tipo parametrizado es una entidad gen\u00e9rica.</p> <p>Gracias a los gen\u00e9ricos podemos especificar el tipo de objeto que introduciremos en la colecci\u00f3n, de forma que el compilador conozca el tipo de objeto que vamos a utilizar, evit\u00e1ndonos as\u00ed el casting. Adem\u00e1s, gracias a esta informaci\u00f3n, el compilador podr\u00e1 comprobar el tipo de los objetos que introducimos, y lanzar un error en tiempo de compilaci\u00f3n si se intenta introducir un objeto de un tipo incompatible, en lugar de que se produzca una excepci\u00f3n en tiempo de ejecuci\u00f3n.</p>"},{"location":"ud7/1generics/#el-operador-diamond","title":"El operador Diamond &lt;&gt;","text":"<p>Para utilizar <code>generics</code> con nuestras colecciones tan solo tenemos que indicar el tipo entre el operador Diamond &lt;&gt; a la hora de crearla. A estas clases a las que podemos pasar un tipo como {\u00abpar\u00e1metro\u00bb+} se les llama clases parametrizadas, clases gen\u00e9ricas o simplemente gen\u00e9ricas (generics).</p> <pre><code>public class Ejemplo {  \n  public static void main(String[] args) {  \n    List&lt;String&gt; lista = new ArrayList&lt;String&gt;();  \n    lista.add(\"Hola mundo\");  \n\n    String cadena = lista.get(0);  \n    System.out.println(cadena);  \n  }  \n} \n</code></pre> <p>El c\u00f3digo anterior no compilar\u00eda, si intent\u00e1ramos insertar en la lista un n\u00famero <code>lista.add(14);</code>, nos dar\u00eda un error de compilaci\u00f3n de tipos.</p> <p>Note</p> <p>Algo a tener en cuenta es que el tipo par\u00e1metro debe ser una clase; no podemos utilizar tipos primitivos.</p>"},{"location":"ud7/1generics/#clases-genericas","title":"Clases gen\u00e9ricas","text":"<p>Al crear una clase que utiliza o contiene alg\u00fan atributo gen\u00e9rico, me obliga a a\u00f1adir este tipo de gen\u00e9rico en la definici\u00f3n de clase. Por convenci\u00f3n se suele utilizar una sola letra may\u00fascula para el tipo gen\u00e9rico.</p> <p>Es decir, si mi clase tiene un atributo <code>T elemento</code> gen\u00e9rico que no s\u00e9 qu\u00e9 tipo de dato va a ser, entero, double, float.... le pongo una letra y con esto le digo que ese atributo es de tipo gen\u00e9rico, puede ser cualquier tipo de dato.</p> <pre><code>public class Box&lt;T&gt; {\n\n  private T elemento;\n\n  public T get() { return elemento; }\n  public void set(T elemento) { this.elemento = elemento; }\n\n}\n</code></pre> <p>Seg\u00fan las convenciones los nombres de los par\u00e1metros de tipo usados com\u00fanmente son los siguientes:</p> <ul> <li>E: elemento de una colecci\u00f3n.</li> <li>K: clave.</li> <li>N: n\u00famero.</li> <li>T: tipo.</li> <li>V: valor.</li> <li>S, U, V etc: para segundos, terceros y cuartos tipos.</li> </ul> <p>En el momento de la instanciaci\u00f3n de un tipo gen\u00e9rico indicaremos el argumento para el tipo, en este caso Box contendr\u00e1 una referencia a un tipo Integer.</p> <pre><code>//Las dos formas son v\u00e1lidas:\nBox&lt;Integer&gt; integerBox1 = new Box&lt;Integer&gt;();\nBox&lt;Integer&gt; integerBox2 = new Box&lt;&gt;();\nintegerBox2.set(4);\nintegerBox1.set(6);\nint suma=integerBox1.get()+integerBox2.get();\n\nBox&lt;String&gt; textoBox = new Box&lt;&gt;();\ntextoBox.set(\"Hola mundo\");\n</code></pre> <p>Estamos creando objetos de la clase <code>Box</code>, tanto de tipo Integer como String.</p> <p>Nota</p> <p>La programaci\u00f3n gen\u00e9rica permite:</p> <ul> <li>Reutilizar c\u00f3digo, evitando tener que crear una clase diferente para cada de tipo de objeto que se quiera manejar, aunque el comportamiento vaya a ser el mismo.</li> <li>Reducir errores en tiempo de ejecuci\u00f3n, eludiendo la generaci\u00f3n de excepciones del tipo <code>ClassCastException</code>.</li> <li>Disminuir la necesidad de hacer conversiones de tipos primitivos, pues cuando el c\u00f3digo es extenso se vuelve engorroso.</li> </ul>"},{"location":"ud7/1generics/#metodos-genericos","title":"M\u00e9todos gen\u00e9ricos","text":"<p>Al igual que ocurre con las clases, si me creo un m\u00e9todo gen\u00e9rico, es decir, que recibe tipos de datos gen\u00e9ricos \u00fanicos que no est\u00e1n definidos en la clase, tengo que especificar en la signatura del m\u00e9todo esos gen\u00e9ricos:</p> <p>Ejemplo</p> <pre><code>public static &lt;T, R&gt; void executeFunction(List&lt;T&gt; lista, Function&lt;T,R&gt; function) {\n  for(T t: lista) {\n    System.out.println(function.apply(t));\n  }\n}\n</code></pre>"},{"location":"ud7/2lambda/","title":"Expresiones lambda","text":"<p>Las funciones lambdas es un t\u00e9rmino adoptado de la programaci\u00f3n funcional y corresponden con funciones de Java que normalmente son an\u00f3nimas y se escriben en l\u00ednea all\u00ed donde se usan.</p> <p>Una expresi\u00f3n lambda como cualquier funci\u00f3n recibe cero o m\u00e1s argumentos y devuelven uno o ning\u00fan valor de retorno. Como cualquier funci\u00f3n, puede consumir m\u00e9todos de otras clases y objetos. Al declararse al mismo tiempo en donde se usa, puede acceder a las variables locales del \u00e1mbito al que pertenece, pero s\u00f3lo podr\u00e1 usar estos como valores de s\u00f3lo lectura, impidiendo realizar alguna modificaci\u00f3n</p>"},{"location":"ud7/2lambda/#interfaces-funcionales","title":"Interfaces funcionales","text":"<p>Una interfaz funcional es aquella que contiene un \u00fanico m\u00e9todo abstracto. Esto NO quiere decir que no pueda contener otros m\u00e9todos static, default, etc. Java proporciona la notaci\u00f3n <code>@FunctionalInterface</code> que alertar\u00e1 al programador si por error ha incluido m\u00e1s de un m\u00e9todo abstracto en una interfaz considerada funcional.</p> <p>La API Java dispone de multitud de interfaces funcionales. Un ejemplo de ello es la interfaz <code>Comparator</code>, la cual contiene un \u00fanico m\u00e9todo abstracto (compare()).</p> <p><pre><code>@FunctionalInterface\npublic interface Comparator&lt;T&gt;\n</code></pre> Ya hemos visto como utilizar esta Interfaz, y como podemos crear clases an\u00f3nimas para manejar <code>Comparator</code> e implementar su m\u00e9todo <code>compare</code>. Veremos como las interfaces funcionales est\u00e1n relacionadas con las expresiones lambdas.</p>"},{"location":"ud7/2lambda/#sintaxis-de-lambda","title":"Sintaxis de lambda","text":"<p>Dado que las expresiones lambda son efectivamente solo m\u00e9todos, las expresiones lambda pueden tomar par\u00e1metros como los m\u00e9todos.</p> <p>La expresi\u00f3n lambda de Java consta de tres componentes.</p> <ol> <li> <p>Par\u00e1metros - lista de argumentos: una expresi\u00f3n lambda puede tener cero o cualquier n\u00famero de argumentos.</p> </li> <li> <p>Token de flecha(-&gt;): se utiliza para vincular la lista de argumentos y el cuerpo de la expresi\u00f3n.</p> </li> <li> <p>Cuerpo: Contiene expresiones y declaraciones para la expresi\u00f3n lambda.</p> </li> </ol> <p></p> <p>Las expresiones lambda se pueden almacenar en variables si el tipo de variable es una interface que tiene un solo m\u00e9todo. La expresi\u00f3n lambda debe tener la misma cantidad de par\u00e1metros y el mismo tipo de retorno que ese m\u00e9todo.</p>"},{"location":"ud7/2lambda/#ejemplos-de-lambdas","title":"Ejemplos de lambdas","text":""},{"location":"ud7/2lambda/#cero-parametros","title":"Cero par\u00e1metros","text":"<p>Los par\u00e9ntesis no tienen contenido en el medio. Eso es para indicar que la expresi\u00f3n lambda no recibe par\u00e1metros.</p> <p>() -&gt; {body}</p> <p><pre><code>//Si tenemos la siguiente interface\ninterface Saludo{  \n    public String say();  \n}  \n\npublic class Main {\n    //mediante clases an\u00f3nimas\n    Saludo holaSpain =new Saludo() {\n        @Override\n        public String say() {\n            return \"Hola...\";\n        }\n    };\n    //mediante lambdas\n    Saludo holaPortugues=()-&gt;{\n        return \"Ol\u00e1...\";\n    };\n    Saludo holaIngles=()-&gt; {\n        return \"Hello...\";\n    };\n    //llamamos al m\u00e9todo say\n    System.out.println(holaSpain.say());\n    System.out.println(holaPortugues.say());\n    System.out.println(holaIngles.say());\n}\n</code></pre> Cuando el cuerpo de la lambda solo tiene una l\u00ednea podemos abreviar</p> <pre><code>Saludo holaSpain = () -&gt; \"Hola...\";       \nSaludo holaPortugues=()-&gt;\"Ol\u00e1...\";\nSaludo holaIngles=()-&gt; \"Hello...\";\n</code></pre>"},{"location":"ud7/2lambda/#un-parametro","title":"Un par\u00e1metro","text":"<p>Cuando una expresi\u00f3n lambda recibe un solo par\u00e1metro, tambi\u00e9n se puede omitir los par\u00e9ntesis, de forma que quedar\u00eda as\u00ed:</p> <p>(p1) -&gt; {body}</p> <p>p1 -&gt; {body}</p> <pre><code>interface Saludo{  \n    public String say(String nombre);  \n}\n\npublic class Main {\n\n  public static void main(String[] args) { \n    //con parentesis\n    Saludo holaSpain = (nombre) -&gt; \"Hola...\"+nombre;\n    Saludo holaPortugues=(nombre)-&gt;\"Ol\u00e1...\"+nombre;\n    //sin parentesis\n    Saludo holaIngles=nombre-&gt; \"Hello...\"+nombre;\n\n    //llamamos al m\u00e9todo say\n    System.out.println(holaSpain.say(\"Pepe\"));\n    System.out.println(holaPortugues.say(\"Maria\"));\n    System.out.println(holaIngles.say(\"Pablo\"));\n    }  \n}\n</code></pre>"},{"location":"ud7/2lambda/#multiples-parametros","title":"M\u00faltiples par\u00e1metros","text":"<p>Si el m\u00e9todo con el que coincide su expresi\u00f3n lambda de Java recibe varios par\u00e1metros, los par\u00e1metros deben enumerarse entre par\u00e9ntesis. As\u00ed es como se ve en c\u00f3digo Java:</p> <p>(p1, p2) -&gt; {body}</p> <pre><code>interface Operar{  \n    int opera(int a,int b);  \n}  \n\npublic class Main {  \n    public static void main(String[] args) {  \n\n        Operar suma=(a,b)-&gt;(a+b);  \n        System.out.println(suma.opera(10,20));  \n\n        // con tipo de datos  \n        Operar mult=(int a,int b)-&gt;(a*b);  \n        System.out.println(mult.opera(100,200));  \n    }  \n} \n</code></pre>"},{"location":"ud7/2lambda/#tipo-de-parametros","title":"Tipo de par\u00e1metros","text":"<p>En ocasiones, puede ser necesario especificar tipos de par\u00e1metros para una expresi\u00f3n lambda si el compilador no puede inferir los tipos de par\u00e1metros del m\u00e9todo de interfaz funcional con el que coincide la lambda.</p> <pre><code>(Coche coche) -&gt; System.out.println(\"El coche es: \" + coche.getName());\n</code></pre>"},{"location":"ud7/2lambda/#comparable-y-comparator-mediante-lambdas","title":"Comparable y Comparator mediante lambdas","text":"<p>Las lambdas nos van a permitir manejar las interfaces de la API de Java de una forma mucho m\u00e1s reducida. Si recordamos los ejemplos que vimos en el cap\u00edtulo de Interface. Teniendo en cuenta que el m\u00e9todo sort espera una implementaci\u00f3n de <code>Comparator</code>, podemos reducir el c\u00f3digo mediante lambdas.</p> <pre><code>class Persona {\n     String nombre;\n     int edad;\n\n    public Persona(String nombre, int edad) {\n        this.nombre = nombre;\n        this.edad = edad;\n    }\n\n    public static void main(String[] args) {\n        // Crear una ArrayList de personas\n        ArrayList&lt;Persona&gt; listaPersonas = new ArrayList&lt;&gt;();\n\n        // Agregar algunas personas a la lista\n        listaPersonas.add(new Persona(\"Juan\", 25));\n        listaPersonas.add(new Persona(\"Maria\", 30));\n        listaPersonas.add(new Persona(\"Carlos\", 42));\n        //Ordenar por nombre\n        listaPersonas.sort((p1,p2)-&gt;p1.nombre.compareTo(p2.nombre));\n        //Ordenar por edad\n        listaPersonas.sort((p1,p2)-&gt;p1.edad-p2.edad);\n\n\n    }\n}\n</code></pre>"},{"location":"ud7/2lambda/#bucle-for-each-en-collections","title":"Bucle for-each en Collections","text":"<p>Podemos utilizar el m\u00e9todo <code>foreach</code> de las listas que permite pasarle una lambda que se ejecuta para cada elemento de la lista</p> <pre><code>public static void main(String[] args) {  \n\n    List&lt;String&gt; list = new ArrayList&lt;String&gt;();  \n    list.add(\"java\");\n    list.add(\"lambda\");\n    list.add(\"test\");  \n\n    list.forEach(  \n        //n es el elemento actual de la lista\n        (n)-&gt;System.out.println(n)  \n    );  \n\n    List&lt;Integer&gt; list2=new ArrayList&lt;Integer&gt;();\n    list2.add(1);\n    list2.add((2));\n    list2.add(3);    \n    list2.forEach(n-&gt;System.out.println(n%2==0?\"Es par\":\"Es impar\"));\n}\n</code></pre>"},{"location":"ud7/2lambda/#escenario-sin-expresiones-lambda","title":"Escenario sin expresiones lambda","text":"<pre><code>interface Saludo { \n    public void saludar();  \n}  \npublic class LambdaExpressionExample {  \n    public static void main(String[] args) {  \n        String nombre = \"Patri\";\n\n        //sin expresiones lambda, Saludo se implementa usando clases an\u00f3nimas\n        Saludo s = new Saludo(){  \n            public void saludar(){System.out.println(\"Hola \" + nombre);}  \n        };  \n        s.saludar();  \n    }  \n}  \n</code></pre>"},{"location":"ud7/2lambda/#escenario-con-expresiones-lambda","title":"Escenario con expresiones lambda","text":"<pre><code>@FunctionalInterface  //Esto es opcional\ninterface Saludo {  \n    public void saludar();  \n}  \n\npublic class LambdaExpressionExample2 {  \n    public static void main(String[] args) {  \n        String nombre = \"Patri\";\n\n        //con expresiones lambda\n        Saludo s2 = ()-&gt; {\n            System.out.println(\"Hola \" + nombre);  \n        };\n        s2.saludar();  \n    }  \n}  \n</code></pre>"},{"location":"ud7/2lambda/#function-crear-una-expresion-lambda-sin-interface","title":"<code>Function</code> Crear una expresi\u00f3n lambda sin interface","text":"<p>Para definir una expresi\u00f3n lambda de un m\u00e9todo que no est\u00e1 definido en ninguna interfaz funcional, tenemos que utilizar la clase <code>Function</code>. A la clase Function se le especifican dos tipos de par\u00e1metros entre <code>&lt;&gt;</code>, el primero es el par\u00e1metro de entrada de la funci\u00f3n, y el segundo es el par\u00e1metro de salida que devuelve la funci\u00f3n o m\u00e9todo.</p> <pre><code>    Function&lt;String, Integer&gt; funcionLambda = (s) -&gt; {\n            int total = 0;\n            for (int i = 0; i &lt; s.length(); i++) {\n                //suma el valor del c\u00f3digo Unicode del carcter\n                total+=s.charAt(i);\n            }\n            return total;\n        };\n</code></pre> <p>Para ejecutar el c\u00f3digo en el interior de la expresi\u00f3n lambda, utilizaremos el m\u00e9todo <code>apply</code>:</p> <pre><code>System.out.println(funcionLambda.apply(\"Programaci\u00f3n\"));\n</code></pre>"},{"location":"ud7/3predicates/","title":"Entidades de java.util.functional","text":"<p>Antes de crear una funci\u00f3n de tipo lambda, conviene conocer las entidades b\u00e1sicas que componen esta manera de programar. Las principales entidades son interfaces con un \u00fanico m\u00e9todo que debe implementar el programador y que estas implementaciones pueden hacerse llegar como argumentos de m\u00e9todos de otras muchas clases del API de Java</p> <p>Las implementaciones de estas interfaces son del tipo, consume un valor y retorna otro tipo de valor, o produce un valor sin argumentos o produce un valor dados dos argumentos. A \u00e9stas se les llama unidades funcionales porque componen una l\u00f3gica interna que a priori el consumidor de esta l\u00f3gica no conoce, pero de la que s\u00ed se conoce su interfaz y por tanto la manera de relacionarse con el resto de los objetos, o lo que es lo mismo la manera de ser invocada</p> <p>Las interfaces funcionales m\u00e1s importantes contenidas en java.util.functional son:</p> <p></p> <ul> <li>Predicate: Se utiliza en expresiones lambda para comprobar si una condici\u00f3n dada es verdadera o falsa</li> <li>Supplier: esta funci\u00f3n se debe utilizar cuando se necesiten generar objetos sin requerir argumentos. Por ejemplo para realizar una inicializaci\u00f3n perezosa.</li> <li>Consumer esta en cambio es el opuesto de Supplier ya que consume, acepta como argumento el tipo T sin devolver ning\u00fan valor de retorno.</li> <li><code>Function&lt;T,R&gt;</code> esta interfaz permite definir una funci\u00f3n que acepta un par\u00e1metro de tipo T y devuelve un resultado del tipo R pudiendo aplicarle alguna transformaci\u00f3n u operaci\u00f3n.</li> <li><code>BiFunction&lt;T,R,S&gt;</code> esta interfaz permite definir una funci\u00f3n que acepta dos par\u00e1metros de tipo T y R, devolviendo un resultado del tipo S. Normalmente ser\u00e1n operaciones de agregaci\u00f3n u operadores binarios como la suma, resta, etc..</li> </ul>"},{"location":"ud7/3predicates/#predicate","title":"Predicate","text":"<p>Predicate la interfaz predicado debe devolver forzosamente un boolean dado un objeto de tipo T, normalmente utilizado para filtrar elementos de una colecci\u00f3n.</p> <p>Predicate es una interfaz funcional que se encuentra en el paquete <code>java.util.function</code>. Mejora la capacidad de administraci\u00f3n del c\u00f3digo, ayuda a realizar pruebas unitarias por separado.</p> <p>Se utiliza en expresiones lambda para comprobar si una condici\u00f3n dada es verdadera o falsa.</p> <p>En lugar de pasar un booleano con valor true or false,  pasas una referencia de tipo Predicate para determinar de manera din\u00e1mica si una condici\u00f3n dada es verdadera, o falsa.</p> <p>Esta es la estructura de la interfaz <code>Predicate</code>:</p> <pre><code>@FunctionalInterface\npublic interface Predicate&lt;T&gt; {\n\n    boolean test(T t);\n}\n</code></pre> <p>Como vemos la interfaz <code>Predicate</code> utiliza los gen\u00e9ricos para poder decirle que tipo concreto vamos a utilizar.</p> <p>Ejemplo:</p> <pre><code>public class EjemploPredicate {\n    public static void main(String[] args) {\n        Predicate&lt;String&gt; checker = a -&gt; a.startsWith(\"M\");\n        System.out.println(checker.test(\"Miguel\"));\n    }\n}\n</code></pre> <p>Hemos creado un objeto <code>Predicate</code> de tipo <code>String</code>. Le damos cuerpo al m\u00e9todo <code>test</code> con una expresi\u00f3n lambda que se le pasa un argumento y devuelve un booleano.</p>"},{"location":"ud7/3predicates/#metodos-predicate","title":"M\u00e9todos Predicate","text":"<p>La interfaz <code>Predicate</code> contiene algunos m\u00e9todos como:</p> <ul> <li><code>isEqual(Object targetRef)</code>: Devuelve un predicado que prueba si dos argumentos son iguales.</li> <li><code>and(Predicate other)</code>: Devuelve un predicado compuesto que representa un AND l\u00f3gico de este predicado y otro.</li> <li><code>or(Predicate other)</code>: Devuelve un predicado compuesto que representa un OR l\u00f3gico de este predicado y otro.</li> <li><code>negate()</code>: Devuelve un predicado que representa la negaci\u00f3n l\u00f3gica de este predicado.</li> </ul> <p>Ejemplo:</p> <pre><code>    Predicate&lt;Integer&gt; greaterThan10 = i -&gt; i &gt; 10;\n    Predicate&lt;Integer&gt; lessThan20 = i -&gt; i &lt; 20;\n    //si es mayor de 10 y menor de 20-&gt;true\n    Predicate&lt;Integer&gt; andPredicate=greaterThan10.and(lessThan20);\n\n    System.out.println(andPredicate.test(15));//true\n    //negate, niega el resultado del predicado\n    System.out.println(andPredicate.negate().test(15));//false\n\n    //isEquals, Devuelve un predicado que prueba si dos argumentos son iguales //seg\u00fan Objects.equals(Object, Object).\n    Predicate&lt;String&gt; compara  = Predicate.isEqual(\"hola\");\n    System.out.println(compara.test(\"java\"));//false\n    System.out.println(compara.test(\"hola\"));//true\n</code></pre> <p>Nota</p> <p>Debido al uso extendido de <code>Predicate</code> se han a\u00f1adido las interfaces funcionales <code>IntPredicate</code> cuando queremos trabajar con predicados de tipo entero, <code>DoublePredicate</code> y <code>LongPredicate</code>. Tambi\u00e9n tenemos la interfaz <code>BiPredicate</code> que es un caso especial de <code>Predicate</code> y recibe dos par\u00e1metros en vez de uno.</p> <pre><code>    IntPredicate predicate = (x) -&gt; {\n        if (x == 12345) {\n            return true;\n        }\n        return false;\n    };\n\n    System.out.println(predicate.test(12345));\n    //creamos otro predicado que niega el anterior\n    IntPredicate intPredicate1 = predicate.negate();\n    System.out.println(intPredicate1.test(12345));\n\n    BiPredicate&lt;String, Integer&gt; filtroLongitud = (x, y) -&gt; {\n        return x.length() == y;\n    };\n\n    boolean result = filtroLongitud.test(\"java\", 10);\n    System.out.println(result); // false\n</code></pre>"},{"location":"ud7/3predicates/#supplier","title":"Supplier","text":"<p><code>Supplier</code> es otra interfaz funcional dentro del paquete <code>java.util.function</code> que nos provee del m\u00e9todo abstracto <code>**get**</code>, sin argumentos que devuelve un tipo de dato.</p> <pre><code>@FunctionalInterface\npublic interface Supplier&lt;T&gt; {\n\n    T get();\n}\n</code></pre> <p>Esta interfaz tambi\u00e9n se utiliza con expresiones lambda que no tienen par\u00e1metros pero devuelven un resultado:</p> <pre><code>    Random random = new Random();\n    //devuelve un n\u00famero aleatorio entre 1..6\n    Supplier&lt;Integer&gt; dados = () -&gt; random.nextInt(6)+1;\n    System.out.println(\"Jugada 1: \" +dados.get());\n    System.out.println(\"Jugada 2: \" +dados.get());\n</code></pre> <p>Al igual que ocurr\u00eda en los predicados con los <code>Supplier</code> tambi\u00e9n disponemos de las clases <code>IntSupplier</code>, <code>DoubleSupplier</code>, <code>LongSupplier</code> y <code>BooleanSupplier</code>.</p>"},{"location":"ud7/3predicates/#consumer","title":"Consumer","text":"<p><code>Consumer</code> es otra interfaz funcional dentro del paquete <code>java.util.function</code> que provee un m\u00e9todo que recibe un solo par\u00e1metro de tipo gen\u00e9rico y no devuelve nada.</p> <pre><code>public interface Consumer&lt;T&gt; {\n    void accept(T t);\n}\n</code></pre> <p>La expresi\u00f3n lambda asignada a un objeto de tipo <code>Consumer</code> se usa para definir su m\u00e9todo <code>**accept(T t)**</code> que eventualmente aplica la operaci\u00f3n dada en su argumento. Los <code>Consumer</code> son \u00fatiles cuando no necesitan devolver ning\u00fan valor, ya que se espera que operen a trav\u00e9s de efectos secundarios.</p> <p>Existen tambi\u00e9n las interfaces <code>IntConsumer</code>, <code>LongConsumer</code> y <code>DoubleConsumer</code>.</p> <p><pre><code>Consumer&lt;Integer&gt; doble = (x) -&gt; System.out.println(x*2);\ndoble.accept(5);\n</code></pre> El m\u00e9todo foreach de Collection que hemos visto anteriormente, acepta un Consumer</p> <pre><code>default void forEach(Consumer&lt;? super T&gt; action)\n</code></pre> <pre><code>public static void main(String[] args) {  \n\n    List&lt;String&gt; list = new ArrayList&lt;String&gt;();  \n    list.add(\"java\");\n    list.add(\"lambda\");\n    list.add(\"test\");  \n\n    list.forEach(  \n        //n es el elemento actual de la lista\n        (n)-&gt;System.out.println(n)  \n    );  \n\n    List&lt;Integer&gt; list2=new ArrayList&lt;Integer&gt;();\n    list2.add(1);\n    list2.add((2));\n    list2.add(3);\n\n    list2.forEach(n-&gt;System.out.println(n%2==0?\"Es par\":\"Es impar\"));\n}\n</code></pre> <p><code>BiConsumer</code> es un caso especial de las expresiones <code>Consumer</code>, son aquellas que reciben dos valores como par\u00e1metro y no devuelven resultado.</p> <pre><code>@FunctionalInterface\npublic interface BiConsumer&lt;T, U&gt; {\n    void accept(T t, U u);\n}\n</code></pre> <p>Ejemplo:</p> <pre><code>BiConsumer&lt;Integer, String&gt; biConsumer = (x, s) -&gt; System.out.println(x + s);\nbiConsumer.accept(3, \" puntos\");\n</code></pre>"},{"location":"ud7/4functions/","title":"Functions","text":"<p>En el apartado de Expresiones lambda vimos como crear expresiones lambda a partir de un m\u00e9todo definido por el programador. Esto se hac\u00eda utilizando la interfaz funcional <code>Function</code> que se encuentra del paquete <code>java.util.function</code>.</p> <pre><code>@FunctionalInterface\npublic interface Function&lt;T, R&gt; {\n    R apply(T t);\n}\n</code></pre> <p><code>Function</code> recibe dos valores de distinto tipo cuando se crea el objeto, el m\u00e9todo recibe un par\u00e1metro de entrada que coincide con el primer tipo espec\u00edfico y devuelve un valor del tipo especificado del objeto que coincide con el segundo valor.</p> <pre><code>Function&lt;Integer, String&gt; function = num -&gt; {\n    if(num % 3 == 0 &amp;&amp; num % 5 == 0){\n        return num + \" divisible entre 3 y 5\";\n    }else{\n        return num + \" no es divisible entre 3 y 5\";\n    }\n};\n\nSystem.out.println(function.apply(25));//devuelve un String\n</code></pre> <p>Si tenemos dos funciones y queremos usar el resultado de una para la siguiente funci\u00f3n podemos concatenarlas utilizando <code>andThen</code>.</p> <pre><code>Function&lt;Integer, Integer&gt; suma = x -&gt; x + 2;\nFunction&lt;Integer, Integer&gt; mul = x -&gt; x * 3;\nFunction co = suma.andThen(mul);\nSystem.out.println(co.apply(4)); //imprime 18 = (4 + 2) * 3\n</code></pre> <p>Podemos realizar las operaciones en el orden inverso mediante <code>compose</code></p> <pre><code>Function&lt;Integer, Integer&gt; suma = x -&gt; x + 2;\nFunction&lt;Integer, Integer&gt; mul = x -&gt; x * 3;\nFunction co = suma.compose(mul);\nSystem.out.println(co.apply(4)); //imprime 14 = (4 * 3) + 2\n</code></pre>"},{"location":"ud7/4functions/#unaryoperator","title":"UnaryOperator","text":"<p><code>UnaryOperator</code> es una interfaz funcional que extiende de <code>Function</code>.</p> <pre><code>@FunctionalInterface\npublic interface UnaryOperator&lt;T&gt; extends Function&lt;T, T&gt; {\n    static &lt;T&gt; UnaryOperator&lt;T&gt; identity() {\n        return t -&gt; t;\n    }\n}\n</code></pre> <p><code>UnaryOperator</code> se crea con un tipo de dato, recibe un par\u00e1metro y devuelve un resultado del mismo tipo de su argumento.</p> <pre><code>UnaryOperator&lt;Integer&gt; func2 = x -&gt; x * 2;\nint resultado = func2.apply(2);\nSystem.out.println(resultado);//imprime 4\n</code></pre> <p>Existen tambi\u00e9n las interfaces derivadas <code>IntUnaryOperator</code>, <code>DoubleUnaryOperator</code>, etc.</p>"},{"location":"ud7/4functions/#resumen-de-las-interfaces-funcionales-dentro-de-javautilfunction","title":"Resumen de las interfaces funcionales dentro de java.util.function","text":""},{"location":"ud7/5references/","title":"Referencia a m\u00e9todos en expresiones lambda y switch","text":"<p>Una referencia a m\u00e9todos o m\u00e9todos referenciados proporciona una forma de referirse a un m\u00e9todo sin ejecutarlo. Se relaciona con expresiones lambda porque tambi\u00e9n requiere un contexto de tipo de objetivo que consiste en una interfaz funcional compatible.</p> <p>En el caso de que todo lo que haga la expresi\u00f3n lambda sea llamar a otro m\u00e9todo con los par\u00e1metros pasados \u200b\u200ba la expresi\u00f3n lambda, la implementaci\u00f3n de Java lambda proporciona una forma m\u00e1s corta de expresar la llamada al m\u00e9todo, que es usando <code>::</code></p> <p>Veamos un ejemplo:</p> <pre><code>public interface Impresora{\n    void imprimir(String s);\n}\n</code></pre> <p>Si us\u00e1ramos lambda sin referencias a m\u00e9todos, lo har\u00edamos de la siguiente forma:</p> <pre><code>Impresora impresora = s -&gt; System.out.println(s);\n</code></pre> <p>Dado que todo lo que hace el cuerpo lambda es reenviar el par\u00e1metro String al m\u00e9todo <code>System.out.println()</code>, podemos reemplazar la declaraci\u00f3n lambda anterior con una referencia de m\u00e9todo utilizando</p> <p>{Clase::Metodo}</p> <p>De forma que quedar\u00eda:</p> <p><pre><code>Impresora impresora = System.out::println;\n</code></pre> Otro ejemplo mediante <code>foreach</code> para que imprima los elementos de la lista</p> <pre><code>List&lt;String&gt; names = new ArrayList();\nnames.add(\"Andrea\");\nnames.add(\"Luisa\");\nnames.add(\"Diego\");\nnames.add(\"Pa\u00fal\");\nnames.add(\"Dario\");\nnames.forEach(System.out::println);\n</code></pre> <p>Observa los dos puntos dobles <code>::</code> . Estos le indican al compilador de Java que se trata de una referencia de m\u00e9todo. El m\u00e9todo al que se hace referencia es lo que viene despu\u00e9s de los dos puntos dobles. Cualquier clase u objeto que posea el m\u00e9todo al que se hace referencia viene antes de los dos puntos dobles.</p> <p>Podemos hacer referencia a los siguientes tipos de m\u00e9todos:</p> <ul> <li>M\u00e9todo est\u00e1tico</li> <li>M\u00e9todo con par\u00e1metros de objeto</li> <li>M\u00e9todo de instancia</li> <li>Constructor</li> </ul>"},{"location":"ud7/5references/#referencias-a-metodos-estaticos","title":"Referencias a m\u00e9todos est\u00e1ticos","text":"<p>Los m\u00e9todos m\u00e1s f\u00e1ciles de referenciar son los m\u00e9todos est\u00e1ticos. Veamos un ejemplo:</p> <pre><code>public interface Finder {\n    int find(String s1, String s2);\n}\n\npublic class MyClass{\n    public static int doFind(String s1, String s2){\n        return s1.lastIndexOf(s2);\n    }\n}\n</code></pre> <p>La referencia al m\u00e9todo est\u00e1tico <code>doFind</code> se har\u00eda con:</p> <pre><code>Finder finder = MyClass::doFind;\n</code></pre> <p>Dado que los par\u00e1metros de los m\u00e9todos <code>Finder.find()</code> y <code>MyClass.doFind()</code> coinciden, es posible crear una expresi\u00f3n lambda que implemente <code>Finder.find()</code> y haga referencia al m\u00e9todo <code>MyClass.doFind()</code>.</p>"},{"location":"ud7/5references/#referencia-a-metodos-con-parametro","title":"Referencia a m\u00e9todos con par\u00e1metro","text":"<p>Tambi\u00e9n puede hacer referencia a un m\u00e9todo con par\u00e1metros de objeto de la clase al m\u00e9todo que se llama.</p> <pre><code>public interface Finder {\n    int find(MyClass mc, String s1, String s2);\n}\n\nclass MyClass {\n    public int check(String s1, String s2) {\n        return s1.indexOf(s2);\n    }\n}\n\n//dentro del main\n//Aunque es un m\u00e9todo de instancia, no est\u00e1tico\n//podemos llamarlo con la clase porque en la interfaz\n//est\u00e1 a\u00f1adido un par\u00e1metro de tipo MyClass\nFinder finder = MyClass::check;\n</code></pre> <p>Si quisi\u00e9ramos hacerlo con una expresi\u00f3n lambda sin usar referencia de m\u00e9todos que llama a String.indexOf() para buscar ser\u00eda:</p> <pre><code>Finder finder = (s1, s2) -&gt; s1.indexOf(s2);\n</code></pre> <p>Su equivalente utilizando referencia de m\u00e9todos con par\u00e1metro de objeto en la expresi\u00f3n lambda ser\u00eda:</p> <pre><code>Finder finder = String::indexOf;\nint numero = finder.find(\"Hola\", \"a\");\n</code></pre> <p>Observe c\u00f3mo la versi\u00f3n abreviada hace referencia a un solo m\u00e9todo. El compilador de Java intentar\u00e1 hacer coincidir el m\u00e9todo al que se hace referencia con el primer tipo de par\u00e1metro, utilizando el segundo tipo de par\u00e1metro como par\u00e1metro del m\u00e9todo al que se hace referencia.</p>"},{"location":"ud7/5references/#referencia-a-metodos-de-instancia","title":"Referencia a m\u00e9todos de instancia","text":"<p>En tercer lugar, tambi\u00e9n es posible hacer referencia a un m\u00e9todo de instancia desde una definici\u00f3n lambda.</p> <pre><code>public interface Deserializer {\n    int deserialize(String v1);\n}\n</code></pre> <p>Esta interfaz representa un componente que es capaz de \"deserializar\" un String en un int.</p> <pre><code>public class StringConverter {\n    public int convertToInt(String v1){\n        return Integer.valueOf(v1);\n    }\n}\n</code></pre> <p>El m\u00e9todo <code>convertToInt()</code> tiene la misma signatura que el m\u00e9todo <code>deserialize()</code> del m\u00e9todo de la interfaz <code>Deserializer</code>. Por eso, podemos crear una instancia de StringConverter y hacer referencia a su m\u00e9todo convertToInt() desde una expresi\u00f3n lambda de Java.</p> <pre><code>StringConverter stringConverter = new StringConverter();\nDeserializador des = stringConverter::convertToInt;\n</code></pre> <p>La expresi\u00f3n lambda creada por la segunda de las dos l\u00edneas hace referencia al m\u00e9todo convertToInt de la instancia de StringConverter creada en la primera l\u00ednea.</p>"},{"location":"ud7/5references/#referencias-a-constructores","title":"Referencias a constructores","text":"<p>Finalmente, es posible hacer referencia a un constructor de una clase. Para ello, se escribe el nombre de la clase seguido de ::new:</p> <pre><code>-- Nomenclatura\nMiClase::new\n</code></pre> <pre><code>Supplier&lt;Usuario&gt; usu = Usuario::new;\n//Construye un objeto de tipo usuario que es devuelto por m\u00e9todo get();\nUsuario usuario = usu.get();\n</code></pre> <p>Veamos otro ejemplo utilizando <code>BiFunction</code>:</p> <pre><code>class Pruebas {\n    public static void main(String[] args) {\n        BiFunction&lt;String, Integer, Usuario&gt; crearUsuario = Usuario::new;\n        Usuario u = crearUsuario.apply(\"Patricia\", 12);\n    }\n}\nclass Usuario {\n    private String nombre;\n    private int edad;\n\n    public Usuario(String nombre, int edad) {\n        this.nombre = nombre;\n        this.edad = edad;\n    }\n}\n</code></pre>"},{"location":"ud7/5references/#expresiones-switch-y-lambdas","title":"Expresiones switch y lambdas","text":"<p>Desde Java 12, se ha incluido las expresiones switch que junto las lambdas, nos permite crear c\u00f3digo m\u00e1s compacto. En estos momentos <code>switch</code>, nos permite devolver un valor y asignarlo. Para ello, por cada <code>case</code> va seguido de una expresi\u00f3n lambda que devuelve un valor. Por otro lado, es  obligada la sentencia <code>default</code></p> <p><pre><code>enum Mes {\n    ENERO, FEBRERO,  MARZO, ABRIL, MAYO, JUNIO, JULIO, AGOSTO, SEPTIEMBRE,OCTUBRE, NOVIEMBRE,DICIEMBRE;\n    }\npublic static String estacion(Mes mes){\n    String result=switch (mes){\n        case DICIEMBRE,ENERO, FEBRERO -&gt; \"Invierno\";\n        case MARZO, ABRIL, MAYO -&gt; \"Primavera\";\n        case JUNIO, JULIO, AGOSTO -&gt; \"Verano\";\n        default -&gt; \"Oto\u00f1o\";\n    };\n    return result;\n}\n</code></pre> Otro ejemplo en el que nos protegemos de valores no v\u00e1lidos</p> <pre><code> int day = 3;\n String dayName = switch (day) {\n    case 1 -&gt; \"Lunes\";\n    case 2 -&gt; \"Martes\";\n    case 3 -&gt; \"Mi\u00e9rcoles\";\n    case 4 -&gt; \"Jueves\";\n    case 5 -&gt; \"Viernes\";\n    case 6 -&gt; \"S\u00e1bado\";\n    case 7 -&gt; \"Domingo\";\n    //lanzamos excepci\u00f3n si no es v\u00e1lido el valor\n    default -&gt; throw new IllegalArgumentException(\"D\u00eda no v\u00e1lido\");\n        };\n</code></pre>"},{"location":"ud7/5references/#yield","title":"yield","text":"<p>Si la sentencia lambda tiene varias l\u00edneas, tenemos que usar <code>yield</code> para devolver el valor</p> <pre><code>int nota=5;\nBoolean esAprobado=switch (nota){\n    case 0,1,2,3,4-&gt;{\n        System.out.println(\"Suspenso\");\n        //devuelve false\n        yield false;\n    }\n    case 5,6,7,8,9,10 -&gt; {\n        System.out.println(\"Aprobado\");\n        //devuelve true\n        yield true;\n    }\n    default -&gt; throw new IllegalArgumentException(\"Nota no v\u00e1lido\");\n\n};\n</code></pre>"},{"location":"ud7/5references/#instanceof-vs-switch","title":"instanceof vs switch","text":"<p>Por otro lado, ahora, podemos prescindir de <code>instanceof</code> para determinar el tipo de un objeto. Mediante <code>instanceof</code> tendr\u00edamos <pre><code>static String formatter(Object o) {\n    String formatted = \"unknown\";\n    if (o instanceof Integer i) {\n        formatted = String.format(\"int %d\", i);\n    } else if (o instanceof Long l) {\n        formatted = String.format(\"long %d\", l);\n    } else if (o instanceof Double d) {\n        formatted = String.format(\"double %f\", d);\n    } else if (o instanceof String s) {\n        formatted = String.format(\"String %s\", s);\n    }\n    return formatted;\n}\n</code></pre> Ahora podemos tener c\u00f3digo m\u00e1s simple y claro <pre><code> static String formatterPatternSwitch(Object o) {\n    return switch (o) {\n        case null     -&gt; System.out.println(\"null!\");\n        case Integer i -&gt; String.format(\"int %d\", i);\n        case Long l    -&gt; String.format(\"long %d\", l);\n        case Double d  -&gt; String.format(\"double %f\", d);\n        case String s  -&gt; String.format(\"String %s\", s);\n        default        -&gt; o.toString();\n    };\n}\n</code></pre></p>"},{"location":"ud7/6streams/","title":"Streams","text":"<p>Los Streams fueron introducidos en Java 8 para abrir la puerta a la programaci\u00f3n funcional al igual que con las expresiones lambda.</p> <p>La API <code>Stream</code> permite manipular las colecciones como nunca antes. Nos permite realizar operaciones sobre la colecci\u00f3n, como por ejemplo, buscar, filtrar, reordenar, etc.</p> <p>Con Streams podemos utilizar cualquier clase que implemente la interfaz <code>Collection</code> como si fuese un <code>Stream</code> con la ventaja que nos ofrecen las expresiones lambda.</p> <p>Con streams hay que tener el cuenta que la fuente o colecci\u00f3n que utilicemos no se puede modificar y no debe afectar al estado de la misma. Cada operaci\u00f3n dentro del stream debe verse como una operaci\u00f3n independiente que opera sobre el argumento (colecci\u00f3n).</p> <p>A trav\u00e9s del API Stream podemos trabajar sobre colecciones como si estuvi\u00e9ramos realizando sentencias SQL pero de una manera limpia y clara, evitando bucles y algoritmos que ralentizan los programas e incluso hacen que el c\u00f3digo se torne inmanejable.</p> <p>Cada operaci\u00f3n del stream debe verse como un paso independiente, es decir, no se puede usar variables intermedias.</p>"},{"location":"ud7/6streams/#partes-de-un-stream","title":"Partes de un Stream","text":"<p>De forma gen\u00e9rica existen 3 partes que componen un Stream:</p> <ol> <li>Un Stream funciona a partir de una lista o colecci\u00f3n, que tambi\u00e9n se la conoce como la fuente de donde obtienen informaci\u00f3n.</li> <li>Operaciones intermedias como por ejemplo el m\u00e9todo filter, que permite hacer una selecci\u00f3n a partir de un predicado.</li> <li>Operaciones terminales, como por ejemplo los m\u00e9todos max, min, forEach, findFirst etc.</li> </ol> <p></p> <p>La fuente proporciona los elementos a la tuber\u00eda.</p>"},{"location":"ud7/6streams/#funciones-de-stream","title":"Funciones de Stream","text":"<p>Como ejemplo, vamos a trabajar sobre una lista de objetos de tipo Persona</p> <pre><code>public class Persona {\n\n    String nombre;\n    String apellido;\n    String pais;\n    String genero;\n    Integer edad;\n\n    public Persona(String nombre, String apellido, String pais, String genero, Integer edad) {\n        this.nombre = nombre;\n        this.apellido = apellido;\n        this.pais = pais;\n        this.genero = genero;\n        this.edad = edad;\n    }\n    //getter y setter\n    @Override\n    public String toString() {\n        return  nombre + \" \"+ apellido ;\n    }\n}\n</code></pre> <p>creamos una lista</p> <pre><code> public static void main(String[] args) {\n        // Crear un ArrayList para almacenar objetos Persona\n        List&lt;Persona&gt; personas = new ArrayList&lt;&gt;();\n\n        // Agregar 5 personas al ArrayList\n        personas.add(new Persona(\"Juan\", \"Perez\", \"Espa\u00f1a\", \"Masculino\", 30));\n        personas.add(new Persona(\"Mar\u00eda\", \"Gonz\u00e1lez\", \"M\u00e9xico\", \"Femenino\", 25));\n        personas.add(new Persona(\"Carlos\", \"L\u00f3pez\", \"Argentina\", \"Masculino\", 40));\n        personas.add(new Persona(\"Laura\", \"Mart\u00ednez\", \"Espa\u00f1a\", \"Femenino\", 35));\n        personas.add(new Persona(\"Pedro\", \"S\u00e1nchez\", \"Chile\", \"Masculino\", 28));\n\n    }\n</code></pre>"},{"location":"ud7/6streams/#operaciones-intermedias","title":"Operaciones intermedias","text":"<p>Las operaciones intermedias obtienen elementos uno por uno y los procesan. Todas las operaciones intermedias son perezosas (lazy) y, como resultado, ninguna operaci\u00f3n tendr\u00e1 ning\u00fan efecto hasta que la tuber\u00eda comience a funcionar.</p>"},{"location":"ud7/6streams/#filter","title":"<code>Filter()</code>","text":"<p>Como su nombre indica lo que hacemos es filtrar de todos los elementos del stream solo aquellos que cumplan una determinada condici\u00f3n. Recibe como par\u00e1metro una expresi\u00f3n lambda <code>Predicate</code> la cual debe devolver <code>true</code> solo en aquellos elementos que se quedar\u00e1n en el stream y <code>false</code> para aquellos elementos que se deben eliminar.</p> <p>Obtener las personas de Espa\u00f1a e imprimir el nombre por pantalla</p> <pre><code>personas.stream()\n          .filter(persona-&gt;persona.pais.equals(\"Espa\u00f1a\"))\n          //operaci\u00f3n terminal\n          .forEach(persona -&gt; System.out.println(persona.nombre));\n</code></pre> <p>Obtener las personas menores de 30 a\u00f1os y guardarlas en una lista</p> <pre><code>List&lt;Persona&gt; menores30=personas.stream()\n                                  .filter(persona -&gt; persona.edad&lt;30)\n                                  //operaci\u00f3n terminar que convierte los elemento en una lista\n                                  .collect(Collectors.toList());\nSystem.out.println(menores30);\n</code></pre>"},{"location":"ud7/6streams/#sorted","title":"<code>Sorted()</code>","text":"<p>Se utiliza para ordenar los elementos del stream. Recibe como par\u00e1metro una expresi\u00f3n lambda de tipo <code>Comparator</code> para que podamos indicar la l\u00f3gica de la ordenaci\u00f3n.</p> <p>Ordenar por apellido y mostrar por pantalla</p> <pre><code> personas.stream()\n            .sorted((p1,p2)-&gt;p1.apellido.compareTo(p2.apellido))\n            .forEach(System.out::println);\n            //tambi\u00e9n : forEach(p-&gt;System.out.println(p))\n</code></pre> <p>Comparator.comparing()</p> <p>Podemos utilizar <code>Comparator.comparing()</code> que  es un m\u00e9todo est\u00e1tico de la interfaz <code>Comparator</code> en Java que permite crear un comparador basado en una funci\u00f3n de extracci\u00f3n de claves. Esta funci\u00f3n extrae una clave de los elementos que se van a comparar, y el comparador se construye utilizando estas claves para determinar el orden.</p> <p>Para nuestro ejemplo</p> <p><pre><code>personas.stream()\n  .sorted(Comparator.comparing(Persona::getApellido))\n  .forEach(System.out::println);\n</code></pre> <code>Comparator.comparing()</code> espera una funci\u00f3n de referencia (o m\u00e9todo de referencia) que devuelve la clave que se utilizar\u00e1 para comparar los elementos. En este caso, <code>Persona::getApellido</code> es una referencia al m\u00e9todo <code>getApellido</code> de la clase <code>Persona</code>, que devuelve el apellido de una persona.</p> <p><code>Comparator.comparing(Persona::getApellido)</code> crea un comparador que compara objetos Persona bas\u00e1ndose en sus apellidos.</p> <p>Si necesitas ordenar en orden descendente, puedes usar Comparator.comparing() junto con el m\u00e9todo reversed()</p> <p><pre><code>.sorted(Comparator.comparing(Persona::getApellido).reversed())\n</code></pre> Por otro lado, nos permite anidar condiciones de orden. Si queremos ordenar primero por pais y despu\u00e9s por apellido</p> <pre><code>personas.stream()\n            .sorted(Comparator.comparing(Persona::getPais)\n                    .thenComparing(Persona::getApellido))\n            .forEach(persona-&gt;System.out.println(persona.getPais()+\" \"+persona));\n</code></pre>"},{"location":"ud7/6streams/#peek","title":"<code>Peek()</code>","text":"<p>El m\u00e9todo <code>peek</code> recibe como par\u00e1metro una expresi\u00f3n lambda de tipo <code>Consumer</code> para poder utilizar cada elemento del stream. Normalmente se utilizar para mostrar por consola el contenido del stream.</p> <p>Este m\u00e9todo existe principalmente para la depuraci\u00f3n del programa, donde se desea ver los elementos a medida que pasan por un punto determinado en el pipeline.</p> <p><code>peek()</code> tambi\u00e9n se utiliza cuando queremos alterar el estado interno de un elemento (aunque esto no es muy com\u00fan).</p> <p>Obtener una lista con las personas menores de 40 ordenados por Pais <pre><code>List&lt;Persona&gt; menores40=personas.stream()\n          //antes de filtrar\n          .peek(persona-&gt;System.out.println(\"Sin filtro: \"+persona))\n          .filter(persona -&gt; persona.edad&lt;40)\n          .peek(persona-&gt;System.out.println(\"Despues de filtro: \"+persona))\n          .sorted(Comparator.comparing(Persona::getPais))\n          .peek(persona-&gt;System.out.println(\"Ordenado: \"+persona))\n          //operaci\u00f3n terminar que convierte los elemento en una lista\n          .collect(Collectors.toList());\nSystem.out.println(menores40);\n</code></pre></p>"},{"location":"ud7/6streams/#distinct","title":"<code>Distinct()</code>","text":"<p>Con <code>distinct</code> se seleccionan los elementos distintos dentro del stream eliminando los duplicados. Los elementos se comparan utilizando el m\u00e9todo <code>equals()</code>.</p>"},{"location":"ud7/6streams/#map","title":"<code>Map()</code>","text":"<p>El m\u00e9todo <code>map</code> recibe como par\u00e1metro una expresi\u00f3n lambda de tipo <code>Function</code>, por lo que debemos especificar una funci\u00f3n que recibe como par\u00e1metro de entrada cada elemento del stream, y devuelve un objeto que puede ser un tipo de dato distinto o el mismo.</p> <p>La funci\u00f3n se aplica a cada uno de los elementos del stream para realizar alguna transformaci\u00f3n sobre cada elemento y devuelve otro Stream sobre el cual puedes seguir trabajando. Se utiliza para modificar el contenido del stream. <code>map()</code> devuelve un stream nuevo que consta de los resultados de aplicar la funci\u00f3n dada a los elementos del stream.</p> <p>Obtener una lista de los paises ordenados </p> <p><pre><code>List &lt;String&gt; paises=personas.stream()\n                //obtenemos los paises\n                .map(persona-&gt; persona.getPais())\n                //tambien .map(Persona::getPais)\n                //quitamos repeticiones\n                .distinct()\n                //ordenamos\n                .sorted()\n                //creamos la lista\n                .collect(Collectors.toList());\nSystem.out.println(paises);\n</code></pre> Tenemos la siguiente clase</p> <pre><code>public class Person {\n    String name;\n    String country;\n\n    public Person(String name, String country) {\n        this.name = name;\n        this.country = country;\n    }\n}\n</code></pre> <p>Crear una lista de <code>Person</code> a partir de la de <code>Personas</code></p> <pre><code> List&lt;Person&gt; people=personas.stream()\n                .map(persona -&gt; new Person(persona.getNombre()+\" \"+persona.getApellido(),persona.getPais()))\n                .collect(Collectors.toList());\n</code></pre>"},{"location":"ud7/6streams/#flatmap","title":"<code>FlatMap</code>","text":"<p>Cuando nos encontramos con estructuras m\u00e1s complejas, como por ejemplo una lista con otra lista, trabajar con <code>map()</code> no es suficiente, por ello, utilizamos <code>flatMap()</code> que lo que hace es \"aplanar\" listas anidadas y quedarnos con un stream plano.</p> <p>Es una funci\u00f3n que recibe una entrada y devuelve varias salidas para esa entrada. Esa es la diferencia con respecto a <code>map()</code> que recibe solo un par\u00e1metro de entrada y devuelve una salida.</p> <p><code>flatMap()</code> es una operaci\u00f3n intermedia y devuelve un nuevo Stream. Devuelve un Stream que consiste en los resultados de reemplazar cada elemento del stream dado con el contenido de un stream mapeado producido al aplicar la funci\u00f3n de mapeo provista a cada elemento. La funci\u00f3n de mapeo utilizada para la transformaci\u00f3n en <code>flatMap()</code> es una funci\u00f3n sin estado y solo devuelve una secuencia de nuevos valores.</p> <p>En el siguiente ejemplo el programa usa la operaci\u00f3n <code>flatMap()</code> para convertir una lista de una lista <code>List&lt;List&lt;Integer&gt;&gt;</code> a una lista <code>List&lt;Integer&gt;</code>.</p> <p><pre><code>List&lt;Integer&gt; list1 = Arrays.asList(1,2,3);\nList&lt;Integer&gt; list2 = Arrays.asList(4,5,6);\nList&lt;Integer&gt; list3 = Arrays.asList(7,8,9);\n\nList&lt;List&lt;Integer&gt;&gt; listOfLists = Arrays.asList(list1, list2, list3);\n\nList&lt;Integer&gt; listOfAllIntegers = listOfLists.stream()\n          .flatMap(x -&gt; x.stream())\n          .collect(Collectors.toList());\n\nSystem.out.println(listOfAllIntegers);\n//[1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre> Obtener una lista con los caracteres que aparecen en los nombres sin repeticiones</p> <pre><code>List&lt;Character&gt; listaCaracteres=personas.stream()\n        //obtenemos un stream con los nombres\n        .map(Persona::getNombre)\n        //convierte cada string en un IntStream de int y los conviente en char\n        .flatMap(nombre-&gt;nombre.chars()\n                //operaci\u00f3n de stream que permite cambiar el tipo\n                                .mapToObj(c -&gt; (char) c))\n        //obtenemos todos los caracteres sin repetici\u00f3n\n        .distinct()\n        .collect(Collectors.toList());\nSystem.out.println(listaCaracteres);\n//[J, u, a, n, M, r, \u00ed, C, l, o, s, L, P, e, d]\n</code></pre>"},{"location":"ud7/6streams/#operaciones-terminales","title":"Operaciones terminales","text":"<p>Las operaciones terminales significan el final del ciclo de vida del steam. Lo m\u00e1s importante para nuestro escenario es que inician el trabajo en la tuber\u00eda.</p>"},{"location":"ud7/6streams/#foreach","title":"<code>ForEach()</code>","text":"<p>Recorremos cada elemento del stream para realizar alguna acci\u00f3n con \u00e9l. Como bien sabemos recibe como par\u00e1metro una expresi\u00f3n lambda de tipo <code>Consumer</code>.</p>"},{"location":"ud7/6streams/#collect","title":"<code>Collect()</code>","text":"<p>Es una operaci\u00f3n terminal, se utiliza para indicar el tipo de colecci\u00f3n en la que se devolver\u00e1 el resultado final de todas las operaciones realizadas en el stream.</p> <pre><code>List&lt;String&gt; lista = Arrays.asList(\"Texto1\", \"Texto2\");\nSet&lt;String&gt; set = lista.stream().collect(Collectors.toSet());\n</code></pre>"},{"location":"ud7/6streams/#findfirst","title":"<code>FindFirst()</code>","text":"<p>Se utiliza para devolver el primer elemento encontrado del stream. Se suele utilizar en combinaci\u00f3n con otras funciones cuando hay que seleccionar un \u00fanico valor del stream que cumpla determinadas condiciones.</p> <p><code>findFirst</code> devuelve un objeto de tipo <code>Optional</code> para poder indicar un valor por defecto en caso de que no se pueda devovler ning\u00fan elemento del stream.</p>"},{"location":"ud7/6streams/#toarray","title":"<code>ToArray()</code>","text":"<p>Con este m\u00e9todo se puede convertir cualquier tipo de <code>Collection</code> en un array de forma sencilla.</p>"},{"location":"ud7/6streams/#min","title":"<code>Min()</code>","text":"<p>Con <code>min</code> se obtiene el elemento del stream con el valor m\u00ednimo calculado a partir de una expresi\u00f3n lambda de tipo <code>Comparator</code> que indicamos como par\u00e1metro.</p> <p><code>min</code> devuelve un objeto de tipo <code>Optional</code> para poder indicar un valor por defecto en caso de que no se pueda devolver ning\u00fan elemento del stream.</p>"},{"location":"ud7/6streams/#max","title":"<code>Max()</code>","text":"<p>Con <code>max</code> se obtiene el elemento del stream con el valor m\u00e1ximo calculado a partir de una expresi\u00f3n lambda de tipo <code>Comparator</code> que indicamos como par\u00e1metro de la expresi\u00f3n.</p> <p><code>max</code> devuelve un objeto de tipo <code>Optional</code> para poder indicar un valor por defecto en caso de que no se pueda devolver ning\u00fan elemento del stream.</p> <pre><code>// Encontrar la persona de mayor edad utilizando max()\nOptional&lt;Persona&gt; personaMayorEdad = personas.stream()\n        .max(Comparator.comparing(Persona::getEdad));\n// Verificar si se encontr\u00f3 alguna persona y mostrar su informaci\u00f3\npersonaMayorEdad.ifPresent(System.out::println);\n//Carlos L\u00f3pez\n</code></pre>"},{"location":"ud7/6streams/#count","title":"<code>count()</code>","text":"<p>Permite obtener el total de elementos</p> <p>Obtener el total de personas en \"Espa\u00f1a\"</p> <pre><code>// Contar el total de personas de Espa\u00f1a\n  long totalPersonasEspa\u00f1a = personas.stream()\n          .filter(persona -&gt; \"Espa\u00f1a\".equals(persona.getPais()))\n          .count();\n\n  System.out.println(\"Total de personas de Espa\u00f1a: \" + totalPersonasEspa\u00f1a);\n  //Total de personas de Espa\u00f1a: 2\n</code></pre>"},{"location":"ud7/6streams/#otras-funciones","title":"Otras funciones","text":"<p>Podemos consultar otras funciones de la clase Stream en la Api de Java</p> <p>https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html</p>"},{"location":"ud7/6streams/#stream-vs-sql","title":"Stream vs SQL","text":"<p>La mayor similitud o manera de imaginarse los streams con otro t\u00e9rmino de la inform\u00e1tica es con el lenguaje estructurado m\u00e1s utilizado en base de datos relacionales, el Structured Query Language (SQL)</p> <p>Suponiendo una tabla de Personas</p> <p>\"Obtener los nombres de Personas con edad menor de 32 y que sean de Espa\u00f1a ordenado por nombre\"</p> <p>En SQL</p> <pre><code>SELECT nombre FROM Personas WHERE (edad&lt;32) AND (pais=\"Espa\u00f1a\") ORDER BY nombre\n</code></pre> <p>mediante Stream <pre><code> personas.stream()\n                .filter(persona -&gt; persona.getEdad()&lt;32 &amp;&amp; persona.getPais().equals(\"Espa\u00f1a\"))\n                .map(Persona::getNombre)\n                .sorted()\n                .forEach(System.out::println);\n//Juan\n</code></pre></p>"},{"location":"ud7/6streams/#ventajas-de-streams","title":"Ventajas de Streams","text":"<ul> <li>C\u00f3digo conciso y m\u00e1s limpio.</li> <li>Programaci\u00f3n funcional: se programa escribiendo el \"qu\u00e9\" en lugar del \"c\u00f3mo\" para que sea comprensible de un vistazo.</li> <li>Puede leer y comprender f\u00e1cilmente el c\u00f3digo que tiene una serie de operaciones complejas.</li> <li>Ejecutar tan r\u00e1pido como bucles for (o m\u00e1s r\u00e1pido con operaciones paralelas)</li> <li>Ideal para listas grandes.</li> </ul>"},{"location":"ud7/6streams/#desventajas","title":"Desventajas","text":"<ul> <li>Excesivo para peque\u00f1as colecciones.</li> <li>Dif\u00edcil de aprender si est\u00e1 acostumbrado a la codificaci\u00f3n de estilo imperativo tradicional</li> </ul>"},{"location":"ud7/7regularexpressions/","title":"Expresiones Regulares","text":"<p>Una expresi\u00f3n regular (regex) define un patr\u00f3n de b\u00fasqueda para cadenas. El patr\u00f3n de b\u00fasqueda puede ser cualquier cosa, desde un car\u00e1cter simple, una cadena fija o una expresi\u00f3n compleja que contenga caracteres especiales que describan el patr\u00f3n.</p> <p>Se puede usar una expresi\u00f3n regular para buscar, editar y manipular texto.</p> <p>La expresi\u00f3n regular se aplica en el texto de izquierda a derecha.</p> <p>Se usa ampliamente para definir la restricci\u00f3n en cadenas como contrase\u00f1a y validaci\u00f3n de correo electr\u00f3nico.</p> <p>Java Regex API proporciona 1 interfaz y 3 clases en el paquete  <code>java.util.regex</code>:</p> <ul> <li>MatchResult interface</li> <li>Matcher class</li> <li>Pattern class</li> <li>PatternSyntaxException class</li> </ul>"},{"location":"ud7/7regularexpressions/#clases-de-caracteres-y-limites-de-coincidencia","title":"Clases de caracteres y l\u00edmites de coincidencia","text":"<p>La forma m\u00e1s simple de una expresi\u00f3n regular (regex) es una cadena, un literal, un String. Por ejemplo, \"Hola\" es una regex que coincide (matches) con la palabra \"Hola\".</p> <p>Si solo us\u00e1ramos literales como patr\u00f3n para buscar en un String, las regex no ser\u00edan muy interesantes. Por eso, se crearon las Character classes &amp; boundary matches.</p> <p>Los boundary matches o l\u00edmites de coincidencia son: <code>^</code> (al principio del String), <code>$</code> (final del String), <code>\\b</code> (principio y final palabra).</p> <p>Una clase caracter es como un comod\u00edn y representa un conjunto o clase de caracteres.</p> Regex Descripci\u00f3n . Coincide con cualquier car\u00e1cter. ^pattern El s\u00edmbolo ^ indica al inicio del String. Encuentra la regex que coincide con el patr\u00f3n dado al comienzo del String.  Por ejemplo, /^start/ coincidir\u00e1 con \"start\" solo si est\u00e1 al principio de una l\u00ednea. pattern$ El s\u00edmbolo $ indica el final del String. Encuentra la regex que coincide con el patr\u00f3n dado al final del String.  Por ejemplo, /end$/ coincidir\u00e1 con \"end\" solo si est\u00e1 al final de una l\u00ednea [abc] Los corchetes representan un conjunto. El String debe coincidir con la/s letra/s dentro del corchete.   Por ejemplo, <code>gr[ae]y</code> coincidir\u00e1 con \"gray\" y \"grey\" pero no con \"groy\". [abc][12] El String debe coincidir con las letras a, b \u00f3 c, seguidas de 1 \u00f3 2.  Por ejemplo, \"a1\", \"b2\" [^abc] El s\u00edmbolo ^ dentro de los corchetes indica negaci\u00f3n. El String debe coincidir con cualquier car\u00e1cter excepto \"a\" \u00f3 \"b\" \u00f3 \"c\". Ejemplo <code>cod[^abc]</code> \"cod3\" y \"codv\" pero no \"coda\" o \"codb\" [a-z1-9] Rango. Busca coincidir las letras min\u00fasculas de la a a la z (ambas incluidas) y los d\u00edgitos del 1 al 9 (ambos incluidos). Por ejemplo,<code>cod[a-z1-9]</code> \"cod3\", \"code\" pero no \"codE\" ni cod$ ni \"coda2\" a|o Encuentra en el String las ocurrencias de \"a\" \u00f3 \"o\".  Por ejemplo, <code>perro|gato</code>  \"perro\" y \"gato\" pero no \"pez\" ab Encuentra en el String todas las ocurrencias de 'a' seguido de una 'b'. Por ejemplo, \"abuelo\","},{"location":"ud7/7regularexpressions/#meta-caracteres","title":"Meta caracteres","text":"<p>Los siguientes metacaracteres tienen un significado predefinido y hacen que ciertos patrones comunes sean m\u00e1s f\u00e1ciles de usar. Por ejemplo, puede usar \\d como definici\u00f3n simplificada para [0..9].</p> Regex Descripci\u00f3n \\d Cualquier d\u00edgito. Equivale a [0-9]. \\D No d\u00edgito. Equivale a [^0-9]. \\s Espacio en blanco. Equivale a [ \\t\\n\\x0b\\r\\f] \\S No espacio en blanco. Equivale a [^\\s] \\w Una letra may\u00fascula o min\u00fascula, un d\u00edgito o el car\u00e1cter '_'. Equivale a  [a-zA-Z0-9_] \\W Equivale a [^\\w] \\S+ Varios caracteres que no son espacios en blanco \\b L\u00edmite de una palabra. Por ejemplo <code>\\b\\d[a-z]\\b</code>. Coincide con \"2a\", \"4c\" pero no con \"2c3\" \""},{"location":"ud7/7regularexpressions/#especificacion-de-modos-dentro-de-la-expresion-regular","title":"Especificaci\u00f3n de modos dentro de la expresi\u00f3n regular","text":"<p>Puede agregar los siguientes modificadores de modo al comienzo de la expresi\u00f3n regular. Para especificar m\u00faltiples modos, simplemente se juntan: <code>(?ismx)</code>.</p> <ul> <li><code>(?i)</code>  hace que la expresi\u00f3n regular sea insensible a may\u00fasculas y min\u00fasculas. Ejemplo <code>(?i)hola</code>, coincide con \"HoLa\",\"hoLA\", \"HOLa\"....</li> <li><code>(?s)</code>  para \"modo de una sola l\u00ednea\" hace que el punto coincida con todos los caracteres, incluidos los saltos de l\u00ednea. Por ejemplo, si deseas realizar una b\u00fasqueda en un texto que incluya m\u00faltiples l\u00edneas y deseas que el punto . coincida con cualquier car\u00e1cter</li> <li><code>(?m)</code>  para \"modo multil\u00ednea\" hace que el s\u00edmbolo de intercalaci\u00f3n y el d\u00f3lar coincidan al principio y al final de cada l\u00ednea en la cadena de asunto.</li> </ul>"},{"location":"ud7/7regularexpressions/#cuantificadores-regex","title":"Cuantificadores Regex","text":"<p>Los cuantificadores especifican el n\u00famero de ocurrencias de un car\u00e1cter.</p> <p>Un cuantificador define con qu\u00e9 frecuencia puede ocurrir un elemento. Los s\u00edmbolos ?, *, + y {} son calificadores.</p> Regex Descripci\u00f3n * Indica que ocurre 0 \u00f3 m\u00e1s veces. Equivale a {0,}. Por ejemplo, <code>go*d</code>  coincidir\u00e1 con \"gd\", \"god\", \"good\", \"gooood\", etc + Indica que ocurre 1 \u00f3 m\u00e1s veces. Equivale a {1,}.  Por ejemplo, <code>go+d</code> coincidir\u00e1 con \"god\", \"good\", \"gooood\", pero no con \"gd\" ? Indica que ocurre 0 \u00f3 1 veces. Equivale a {0,1}.  Por ejemplo, <code>go?d</code> coincidir\u00e1 con \"gd\", \"god\" . Pero no con \"good\" {X} Indica que lo que va justo antes de las llaves {} se repite X n\u00famero de veces. Por ejemplo <code>A\\d{3}B</code>, \"A231B\", \"A365B\". Pero no coincide con \"As23B\" \u00f3 \"A1234B\" {X, Y} Indica que lo que va justo antes de las llaves {} se repite m\u00ednimo X n\u00famero de veces y m\u00e1ximo Y. Por ejemplo <code>\\b\\w{4,6}\\b</code> coincide \"apple\", \"123456\" pero no \"abc\", \"1234567\", \"biblioteca\" *? ? despu\u00e9s de un cuantificador lo convierte en un cuantificador perezoso (lazy). Intenta encontrar la coincidencia m\u00e1s peque\u00f1a. Esto hace que la expresi\u00f3n regular se detenga en la primera coincidencia. <p>En la documentaci\u00f3n de Oracle podemos ver todas las clases de caracteres que hay para construir una expresi\u00f3n regular.</p> <p>https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html</p>"},{"location":"ud7/7regularexpressions/#entrena-tus-regex","title":"Entrena tus Regex","text":"<p>https://regexcrossword.com/</p> <p>https://www.freeformatter.com/java-regex-tester.html</p>"},{"location":"ud7/7regularexpressions/#java-regex-core-classes","title":"Java Regex Core Classes","text":"<p>La API de expresiones regulares de Java consta de dos clases principales. Estos son:</p> <p><code>Pattern</code> (java.util.regex.Pattern) <code>Matcher</code> (java.util.regex.Matcher)</p>"},{"location":"ud7/7regularexpressions/#clase-pattern","title":"Clase <code>Pattern</code>","text":"<p>La clase <code>Pattern</code> se utiliza para crear patrones (expresiones regulares). Un patr\u00f3n es una expresi\u00f3n regular precompilada en forma de objeto (como una instancia de patr\u00f3n), capaz de compararse con un texto.</p> <pre><code>String regex = \".*http://.*\";\n\nPattern pattern = Pattern.compile(regex);\n</code></pre>"},{"location":"ud7/7regularexpressions/#clase-matcher","title":"Clase <code>Matcher</code>","text":"<p>La clase <code>Matcher</code> se usa para hacer coincidir una expresi\u00f3n regular determinada (\u00f9na instancia de <code>Pattern</code>) con un texto varias veces. En otras palabras, buscar m\u00faltiples ocurrencias de la expresi\u00f3n regular en el texto. <code>Matcher</code> nos dir\u00e1 en qu\u00e9 parte del texto (\u00edndice de caracteres) encontr\u00f3 las ocurrencias. Puede obtener una instancia de Matcher a partir de una instancia de Pattern.</p> <p>Implementa la interfaz <code>MatchResult</code>.</p> <p>Algunos de los m\u00e9todos de la clase Matcher son:</p> <ul> <li>boolean matches(): prueba si la expresi\u00f3n regular coincide con el patr\u00f3n.</li> <li>booleano find(): encuentra la siguiente expresi\u00f3n que coincide con el patr\u00f3n.</li> <li>boolean find(int start): encuentra la siguiente expresi\u00f3n que coincide con el patr\u00f3n del n\u00famero de inicio dado.</li> <li>String group(): devuelve la subsecuencia coincidente.</li> <li>int start(): devuelve el \u00edndice inicial de la subsecuencia coincidente.</li> <li>int end(): devuelve el \u00edndice final de la subsecuencia coincidente.</li> <li>int groupCount(): devuelve el n\u00famero total de la subsecuencia coincidente.</li> </ul> <p>Ejemplo:</p> <p>Coincidencia de una cadena con la expresi\u00f3n regular</p> <p><pre><code>String regex = \"ab+c\";//'palabras que empicen por 'a' siga 1 o m\u00e1s 'b' y terminen por 'c'\nString input = \"abbc\";\nPattern pattern = Pattern.compile(regex);\nMatcher matcher = pattern.matcher(input);\nboolean matches = matcher.matches(); // Devuelve true si toda la cadena coincide con la expresi\u00f3n regular\nSystem.out.println(matches); // Imprime: true\n</code></pre> B\u00fasqueda de ocurrencias de una expresi\u00f3n regular en una cadena:</p> <p><pre><code>String regex = \"ab\\\\w*o\";// palabras que empiecen por 'ab' y terminen e 'o'\nString input = \" hola que tal abuelo, donde vamos\";\nPattern pattern = Pattern.compile(regex);\nMatcher matcher = pattern.matcher(input);\n// Devuelve true si encuentra al menos una ocurrencia de la expresi\u00f3n regular\nboolean find = matcher.find(); \nSystem.out.println(find); // Imprime: true\n\nString input2 = \" hola que tal abuela, donde vamos\";\nMatcher matcher2 = pattern.matcher(input2);\nfind = matcher.find(); \nSystem.out.println(find); // Imprime: false\n</code></pre> Obtener todas las coincidencias de una expresi\u00f3n regular en una cadena <pre><code>//palabras entre 4 y 6 letras. Fijate en \\b que indica inicio y fin\nString regex = \"\\\\b\\\\w{4,6}\\\\b\";\nString input = \"ver banana casa 1234567\";\nPattern pattern = Pattern.compile(regex);\nMatcher matcher = pattern.matcher(input);\nwhile (matcher.find()) {\n  //extrae el elemento que coincide con el patr\u00f3n\n    System.out.println(matcher.group()); \n    // Imprime: banana casa\n}\n</code></pre></p> <p>Encontrar las posiciones de la coincidencia <pre><code>StringBuilder html = new StringBuilder(\"&lt;h1&gt;Head&lt;/h1&gt;\");\nhtml.append(\"&lt;h2&gt;Etiqueta h2 de encabezado&lt;/h2&gt;\");\nhtml.append(\"&lt;p&gt;Esto es un p\u00e1rrafo en html&lt;/p&gt;\");\nhtml.append(\"&lt;h2&gt;Resumen&lt;/h2&gt;\");\nhtml.append(\"&lt;p&gt;Fin del html&lt;/p&gt;\");\n\nPattern p = Pattern.compile(\"&lt;h2&gt;\");\nMatcher m = p.matcher(html);\n//buscamos la posici\u00f3n de las coincidencias\nwhile (m.find()) {\n    System.out.println(\"Coincidencia encontrada en la posici\u00f3n \" + m.start());\n}\n/*Coincidencia encontrada en la posici\u00f3n 13\nCoincidencia encontrada en la posici\u00f3n 80*/\n</code></pre> Reemplazar todas las ocurrencias de una expresi\u00f3n regular en una cadena</p> <pre><code>String regex = \"\\\\d\";//n\u00fameros\nString input = \"abc123xyz\";\nPattern pattern = Pattern.compile(regex);\nMatcher matcher = pattern.matcher(input);\nString replaced = matcher.replaceAll(\"*\");\nSystem.out.println(replaced); // Imprime: abc***xyz\n</code></pre>"},{"location":"ud7/7regularexpressions/#reset","title":"reset()","text":"<p>El m\u00e9todo de la clase Matcher <code>reset()</code> restablece el estado de coincidencia internamente en el Matcher. En caso de que haya comenzado a hacer coincidir las ocurrencias en una cadena a trav\u00e9s del m\u00e9todo <code>find()</code>, el Matcher mantendr\u00e1 internamente un estado sobre qu\u00e9 tan lejos ha buscado a trav\u00e9s del texto de entrada. Al llamar a <code>reset()</code>, la coincidencia comenzar\u00e1 nuevamente desde el principio del texto.</p> <pre><code>String text = \"La casa est\u00e1 en el lago y el gato est\u00e1 en la casa.\";\n\n// Patr\u00f3n para encontrar palabras que contienen la letra 'a'\nPattern pattern = Pattern.compile(\"\\\\b\\\\w*a\\\\w*\\\\b\");\nMatcher matcher = pattern.matcher(text);\n\n// Encontrar y reemplazar las letras 'a' con 'X'\nint replacementCount = 0;\nwhile (matcher.find()) {\n    String replacement = matcher.group().replace('a', 'X');\n    text = text.substring(0, matcher.start()) + replacement + text.substring(matcher.end());\n    replacementCount++;\n}\nSystem.out.println(\"Texto con 'a' reemplazado por 'X':\");\nSystem.out.println(text);\n //LX cXsX est\u00e1 en el lXgo y el gXto est\u00e1 en lX cXsX.\n\n// Reiniciar el objeto Matcher para usarlo nuevamente\nmatcher.reset();\n\n// Encontrar la cantidad total de palabras que contienen 'a'\nint count = 0;\nwhile (matcher.find()) {\n    count++;\n}\nSystem.out.println(\"Total de palabras que contienen 'a': \" + count);\n//Total de palabras que contienen 'a': 6\n</code></pre>"},{"location":"ud7/7regularexpressions/#group","title":"group()","text":"<p>Los grupos est\u00e1n marcados con par\u00e9ntesis en la expresi\u00f3n regular. Por ejemplo:</p> <p>(Hola)</p> <p>Esta expresi\u00f3n regular coincide con el texto Hola. Los par\u00e9ntesis no son parte del texto que se compara. Los par\u00e9ntesis marcan un grupo. Cuando se encuentra una coincidencia en un texto, puede obtener acceso a la parte de la expresi\u00f3n regular dentro del grupo.</p> <p>Para acceder a un grupo se utiliza el m\u00e9todo <code>group(int groupNo)</code>. Una expresi\u00f3n regular puede tener m\u00e1s de un grupo. Por lo tanto, cada grupo est\u00e1 marcado con un conjunto separado de par\u00e9ntesis. Para obtener acceso al texto que coincidi\u00f3 con la subparte de la expresi\u00f3n en un grupo espec\u00edfico, se pasa el n\u00famero del grupo al m\u00e9todo <code>group(int groupNo)</code>.</p> <p>El grupo con el n\u00famero 0 es siempre la expresi\u00f3n regular completa. Para obtener acceso a un grupo marcado entre par\u00e9ntesis, debe comenzar con los n\u00fameros de grupo 1.</p> <p>Ejemplo:</p> <pre><code>String text = \"\"\"\nName: Juan, Phone: 123456789\nName: Pepe, Phone: 345678989\n\"\"\";\n// Patr\u00f3n para extraer el nombre y el tel\u00e9fono\nPattern pattern = Pattern.compile(\"Name: (.*), Phone: (\\\\d+)\");\nMatcher matcher = pattern.matcher(text);\n\nwhile (matcher.find()) {\n    String nombre = matcher.group(1); // Obtiene el grupo de captura 1 (el nombre)\n    String telefono = matcher.group(2); // Obtiene el grupo de captura 2 (el tel\u00e9fono)\n\n    System.out.println(\"Nombre: \" + nombre);\n    System.out.println(\"Tel\u00e9fono: \" + telefono);\n/*\nNombre: Juan\nTel\u00e9fono: 123456789\nNombre: Pepe\nTel\u00e9fono: 345678989\n         */\n    }\n</code></pre>"},{"location":"ud7/7regularexpressions/#stringmatches","title":"String.matches","text":"<p>El m\u00e9todo matches() de String se utiliza para determinar si una cadena coincide con una expresi\u00f3n regular completa. Devuelve true si la cadena coincide completamente con la expresi\u00f3n regular y false en caso contrario</p> <pre><code>String texto = \"Hola Mundo\";\nif (texto.matches(\"Hola.*\")) {\n    System.out.println(\"La cadena comienza con 'Hola'\");\n} else {\n    System.out.println(\"La cadena no comienza con 'Hola'\");\n}\n</code></pre>"},{"location":"ud7/7regularexpressions/#stringreplaceall","title":"String.replaceAll","text":"<p>Permite sustituir en un String las coincidencias de una expresi\u00f3n regular</p> <p>Sustituir el Dni por asteriscos</p> <pre><code>String emails = \"Pepe con DNI 12345678F y Mar\u00eda con DNI 87654321G\";\n\n// Expresi\u00f3n regular para coincidir con el DNI\nString regex = \"\\\\b\\\\d{8}[A-HJ-NP-TV-Z]\\\\b\";\nString reemplazo = \"*********\";\n\n// Reemplazar los DNI\nString dniOcultos = emails.replaceAll(regex, reemplazo);\n\nSystem.out.println(\"Resultado:\");\nSystem.out.println(dniOcultos);\n//Pepe con DNI ********* y Mar\u00eda con DNI *********\n</code></pre>"},{"location":"ud7/7regularexpressions/#operadores-logicos","title":"Operadores l\u00f3gicos","text":"<p>La API de Java Regex admite un conjunto de operadores l\u00f3gicos que se pueden usar para combinar m\u00faltiples subpatrones dentro de una sola expresi\u00f3n regular.</p> <p>Los operadores l\u00f3gicos son: el operador and, el operador or y el operador not.</p> <p>El operador and es impl\u00edcito. Si dos caracteres (u otros subpatrones) se suceden en una expresi\u00f3n regular, eso significa que tanto el primer como el segundo subpatr\u00f3n coinciden en gran medida con la cadena de destino.</p> <p>El operador or es expl\u00edcito y est\u00e1 representado por el car\u00e1cter vertical <code>|</code>.</p> <p>El operador not es expl\u00edcito, est\u00e1 representado por el s\u00edmbolo <code>!</code>, brinda la posibilidad de excluir un patr\u00f3n. Con esto se puede decir que una cadena no debe ir seguida de otra cadena.</p> <p>En expresi\u00f3n regular, hay anticipaci\u00f3n positiva <code>(? =)</code> y anticipaci\u00f3n negativa <code>(?!)</code>:</p> <ul> <li><code>(?=)</code> garantiza que algo siga a algo m\u00e1s.<code>b(?=c)</code> coincide con una b seguida de una c</li> </ul> <p>Por ejemplo, si queremos encontrar palabras que contengan \"apple\" seguidas de \"pie\"  </p> <p><pre><code>String text = \"apple juice, apple pie, apple juice, apple cake, apple pie\";\nPattern pattern = Pattern.compile(\"\\\\bapple(?=\\\\spie)\\\\b\");\nMatcher matcher = pattern.matcher(text);\n\nwhile (matcher.find()) {\n    System.out.println(matcher.start());\n}\n\n\n//13 49\n</code></pre> + <code>(?!)</code> garantiza que algo NO sea seguido por otra cosa. <code>b(?!c)</code> coincide con una b que NO va seguida de una c</p> <p>Por ejemplo, si queremos encontrar palabras que contengan \"apple\" no seguidas de \"pie\"  </p> <pre><code>String text = \"apple juice, apple pie, apple juice, apple cake, apple pie\";\nPattern pattern = Pattern.compile(\"\\\\bapple(?=\\\\spie)\\\\b\");\nMatcher matcher = pattern.matcher(text);\n\nwhile (matcher.find()) {\n    System.out.println(matcher.start());\n}\n\n//0 24 37\n</code></pre>"},{"location":"ud7/7regularexpressions/#ejemplos-expresion-regular","title":"Ejemplos expresi\u00f3n regular","text":"<p>tel\u00e9fono m\u00f3vil de Espa\u00f1a</p> <pre><code>//(+34) 655-555-555\nString regexTelefono = \"^([\\\\(]{1}[\\\\+]{1}34[\\\\)]{1}[ ]{1}[0-9]{3}[\\\\-]{1}[0-9]{3}[\\\\-]{1}[0-9]{3})$\";\n\nString t1 = \"123456789\";//no\nString t2 = \"(+35) 123456-789\";//no\nString t3 = \"(+34) 123-456-789\";//si\nString t4 = \"(+34)123-456-78\";//no\n\nSystem.out.println(t1.matches(regexTelefono));//false\nSystem.out.println(t2.matches(regexTelefono));//false\nSystem.out.println(t3.matches(regexTelefono));//true\nSystem.out.println(t4.matches(regexTelefono));//false\n</code></pre> <p>Buscar un patr\u00f3n num\u00e9rico en una cadena <pre><code>String texto = \"El precio es $50.00\";\nPattern pattern = Pattern.compile(\"\\\\$\\\\d+\\\\.\\\\d{2}\");\nMatcher matcher = pattern.matcher(texto);\nif (matcher.find()) {\n    System.out.println(\"Precio encontrado: \" + matcher.group());\n}\n</code></pre> Validar una direcci\u00f3n de correo electr\u00f3nico</p> <p><pre><code>String email = \"usuario@example.com\";\nPattern pattern = Pattern.compile(\"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}\");\nMatcher matcher = pattern.matcher(email);\nif (matcher.matches()) {\n    System.out.println(\"La direcci\u00f3n de correo electr\u00f3nico es v\u00e1lida.\");\n}\n</code></pre> Buscar todas las apariciones de una palabra espec\u00edfica en una cadena</p> <p><pre><code>String texto = \"La lluvia en Sevilla es una maravilla. Sevilla tiene un color especial.\";\nPattern pattern = Pattern.compile(\"\\\\bSevilla\\\\b\");\nMatcher matcher = pattern.matcher(texto);\nint contador = 0;\nwhile (matcher.find()) {\n    contador++;\n}\nSystem.out.println(\"La palabra 'Sevilla' aparece \" + contador + \" veces.\");\n</code></pre> Extraer el contenido entre par\u00e9ntesis:</p> <p><pre><code>String texto = \"La temperatura es (25\u00b0C) y la humedad es (50%)\";\nPattern pattern = Pattern.compile(\"\\\\((.*?)\\\\)\");\nMatcher matcher = pattern.matcher(texto);\nwhile (matcher.find()) {\n    System.out.println(\"Contenido entre par\u00e9ntesis: \" + matcher.group(1));\n}\n/*\nContenido entre par\u00e9ntesis: 25\u00b0C\nContenido entre par\u00e9ntesis: 50%\n*/\n</code></pre> Buscar y reemplazar todas las ocurrencias de una palabra en una cadena:</p> <p><pre><code>String texto = \"La casa es peque\u00f1a, pero la casa es acogedora.\";\nPattern pattern = Pattern.compile(\"\\\\bcasa\\\\b\");\nMatcher matcher = pattern.matcher(texto);\nString resultado = matcher.replaceAll(\"vivienda\");\nSystem.out.println(resultado);\n//La vivienda es peque\u00f1a, pero la vivienda es acogedora.\n</code></pre> Validar una fecha en formato MM/DD/AAAA</p> <p><pre><code>String fecha = \"12/31/2023\";\nPattern pattern = Pattern.compile(\"(0[1-9]|1[0-2])/([0-2][0-9]|3[0-1])/\\\\d{4}\");\nMatcher matcher = pattern.matcher(fecha);\nif (matcher.matches()) {\n    System.out.println(\"La fecha es v\u00e1lida.\");\n}\n</code></pre> Extraer los nombres de usuario de direcciones de correo electr\u00f3nico: <pre><code>String emails = \"usuario1@example.com, usuario2@example.com, usuario3@example.com\";\nPattern pattern = Pattern.compile(\"\\\\b([a-zA-Z0-9._%+-]+)@\");\nMatcher matcher = pattern.matcher(emails);\nwhile (matcher.find()) {\n    System.out.println(\"Nombre de usuario: \" + matcher.group(1));\n}\n/*\nNombre de usuario: usuario1\nNombre de usuario: usuario2\nNombre de usuario: usuario3\n*/\n</code></pre></p>"},{"location":"ud7/8fechas/","title":"Fechas en Java 8+","text":"<p>Actualmente en el Jdk de Java hay dos Apis para la gesti\u00f3n de calendarios, fechas y horas que puede usar el programador. El primero de ellos es un api obsoleto que ser\u00e1 eliminado en un futuro de Java, y corresponde con el uso de <code>java.util.Date</code>, <code>java.util.Calendar</code> y relacionados. Estos objetos est\u00e1n pr\u00e1cticamente desde el inicio de Java y a trav\u00e9s de la evoluci\u00f3n del lenguaje y su uso en entornos cada vez m\u00e1s diversos se han quedado desfasados.</p> <p>Para remediar los puntos negativos, en la versi\u00f3n de Jdk 8 y posteriores, el lenguaje incorpora un nuevo api para la gesti\u00f3n de tiempo, denominado de forma com\u00fan por <code>java.time</code> por el paquete en el que est\u00e1n ubicadas las clases que lo conforman</p>"},{"location":"ud7/8fechas/#javatime","title":"java.time","text":"<p>En marzo de 2014 apareci\u00f3 la versi\u00f3n est\u00e1ndar de Java 8 y con ella estas nuevas clases especializadas que solucionan la mayor parte de los problemas de las clases tradicionales, e incluyen soporte autom\u00e1tico para cosas como a\u00f1os bisiestos, zonas horarias y cambio autom\u00e1tico de zona horaria</p> <p>Las principales clases son</p> clase descripci\u00f3n LocalDate representa a fechas sin la hora y nos facilita su manejo para declararlas, sumar y restar fechas y compararlas. LocalTime es id\u00e9ntica a la anterior pero para el manejo de horas, sin ninguna fecha asociada, pudiendo as\u00ed compararlas, sumar o restar tiempo a las mismas LocalDateTime como puedes suponer, es una combinaci\u00f3n de las dos anteriores, que permite hacer lo mismo con fechas y horas simult\u00e1neamente. Instant es muy parecida a la anterior pero a la vez muy diferente. Se usa para almacenar un punto determinado en el tiempo, o sea con fecha y hora, pero guarda su valor como un timestamp de UNIX, es decir, en nanosegundos desde el epoch de UNIX (1/1/1970 a las 00:00) y usando la zona horaria UTC. Es muy \u00fatil para manejar momentos en el tiempo de manera neutra e intercambiarlo entre aplicaciones y sistemas, por lo que lo ver\u00e1s utilizado muy a menudo. ZonedDateTime esta clase es como la LocalDateTime pero teniendo en cuenta una zona horaria concreta, ya que las anteriores no la tienen en cuenta. Period esta clase auxiliar nos ayuda a obtener diferencias entre fechas en distintos periodos (segundos, minutos, d\u00edas...) y tambi\u00e9n a a\u00f1adir esas diferencias a las fechas. Duration esta es muy parecida a la anterior pero para manejo de horas exclusivamente Clock Un reloj que proporciona acceso al instante actual, fecha y hora utilizando una zona horaria MonthDay Un mes al d\u00eda en el sistema de calendario ISO-8601, como \u201312-03. OffsetDateTime Una fecha y hora con una compensaci\u00f3n de UTC / Greenwich en el sistema de calendario ISO-8601, como 2007-12-03T10: 15: 30 + 01: 00. Year Un a\u00f1o en el sistema de calendario ISO-8601, como 2007 YearMonth Un a\u00f1o-mes en el sistema de calendario ISO-8601, como 2007-12. ZoneId Una identificaci\u00f3n de zona horaria, como Europa / Par\u00eds ZoneOffset Un desplazamiento de zona horaria de Greenwich / UTC, como +02: 00."},{"location":"ud7/8fechas/#creacion-de-fechas","title":"Creaci\u00f3n de fechas","text":"<p>Para la creaci\u00f3n de fechas tenemos que saber si necesitamos:</p> <ul> <li>la fecha</li> <li>la hora</li> <li>la fecha y la hora</li> </ul> <p>Para el manejo de fechas tenemos principalmente de 3 m\u00e9todos:</p> <ul> <li><code>now()</code>: crean instancias nuevas a partir de la fecha y hora actual.</li> <li><code>of()</code>: construyen fechas y horas a partir de sus partes</li> <li><code>with()</code>: modifican la fecha u hora actual en funci\u00f3n del par\u00e1metro que se le pase</li> </ul> <pre><code>//creaci\u00f3n de fechas\nLocalDate localDate1 = LocalDate.now();\nLocalDate localDate2 = LocalDate.of(2024, 02, 20);\nLocalDate localDate4 = LocalDate.of(2024, Month.FEBRUARY, 20);\nLocalDate localDate3 = LocalDate.parse(\"2024-02-20\");\n\n//Creaci\u00f3n de horas\nLocalTime horaActual = LocalTime.now();\nLocalTime horaEspecifica = LocalTime.of(15, 30, 0);\nLocalTime horaParseada = LocalTime.parse(\"13:45:30\");\n\n//fecha/hora\nLocalDateTime fechaHoraActual = LocalDateTime.now();\nLocalDateTime fechaHoraEspecifica = LocalDateTime.of(2024, 4, 11, 15, 30, 0);\nLocalDateTime fechaHoraParseada = LocalDateTime.parse(\"2024-04-11T13:45:30\");\n</code></pre> <p>El m\u00e9todo <code>now()</code> est\u00e1 disponible en varias clases, y su resultado es diferente</p> <p><pre><code>System.out.println(\"La fecha actual es: \" + LocalDate.now());\nSystem.out.println( \"La hora actual es: \" + LocalTime.now() );\nSystem.out.println( \"La fecha y hora actuales son: \" + LocalDateTime.now() );\nSystem.out.println( \"El instante actual es: \" + Instant.now() );\nSystem.out.println( \"La fecha y hora actuales con zona horaria son: \" + ZonedDateTime.now() );\n/*\nLa fecha actual es: 2024-04-11\nLa hora actual es: 13:04:16.928467900\nLa fecha y hora actuales son: 2024-04-11T13:04:16.928467900\nEl instante actual es: 2024-04-11T11:04:16.928467900Z\nLa fecha y hora actuales con zona horaria son: 2024-04-11T13:04:16.928467900+02:00[Europe/Madrid]\n\n*/\n</code></pre> Al convertirlas a cadena para mostrarlas se generan en el formato ISO 8601, que es un est\u00e1ndar ampliamente aceptado</p>"},{"location":"ud7/8fechas/#partes-de-fechahora","title":"Partes de Fecha/hora","text":"<p>Tenemos variedad de m\u00e9todo que permiten acceder a las partes de una fecha/hora</p> <p></p> <pre><code>LocalDateTime fechaHoraActual = LocalDateTime.now();\n\nint year=fechaHoraActual.getYear();\nint mes=fechaHoraActual.getMonthValue();\n</code></pre>"},{"location":"ud7/8fechas/#modificar-fechashoras","title":"Modificar fechas/horas","text":"<p>Seg\u00fan la clase que manejemos tendremos una serie de m\u00e9todos para a\u00f1adir o quitar intervalos al dato</p> M\u00e9todo Descripci\u00f3n plusDays() / minusDays() para sumar o restar d\u00edas a la fecha plusWeeks() / minusWeeks() para sumar o restar semanas plusMonths() / minusMonths() para sumar o restar meses plusYears() / minusYears() para sumar o restar a\u00f1os <pre><code>System.out.println(\"La fecha dentro de 10 d\u00edas: \" + LocalDate.now().plusDays(10) );\nSystem.out.println(\"La fecha dentro de 2 semanas: \" + LocalDate.now().plusWeeks(2) );\nSystem.out.println(\"La fecha y hora de hace 32 horas: \" + LocalDateTime.now().minusHours(32) );\n</code></pre>"},{"location":"ud7/8fechas/#ajustadores-temporales","title":"Ajustadores temporales","text":"<p>Tenemos una clase muy \u00fatil <code>TemporalAdjusters</code> que permite obtener nuevas fechas con ajustes muy utilizados</p> <pre><code>LocalDate fechaActual = LocalDate.now();\nLocalDate ultimoDiaMesActual = fechaActual.with(TemporalAdjusters.lastDayOfMonth());\nSystem.out.println(\"\u00daltimo d\u00eda del mes actual: \" + ultimoDiaMesActual);\n\nLocalDate primerDiaAnioSiguiente = fechaActual.with(TemporalAdjusters.firstDayOfNextYear());\nSystem.out.println(\"Primer d\u00eda del a\u00f1o siguiente: \" + primerDiaAnioSiguiente);\n</code></pre>"},{"location":"ud7/8fechas/#tiempo-transcurrido-entre-fechas-y-horas","title":"Tiempo transcurrido entre fechas y horas","text":"<p>Otra tarea habitual que necesitaremos hacer es obtener la diferencia entre dos fechas u horas, o sea, el tiempo transcurrido entre dos instantes de tiempo.</p> <p>Por ejemplo, imaginemos que queremos saber cu\u00e1nto tiempo ha transcurrido entre la fecha de tu nacimiento y el d\u00eda de hoy. Para averiguarlo s\u00f3lo hay que hacer algo como esto:</p> <pre><code>LocalDate fNacimiento = LocalDate.of(1982, Month.MAY, 23);\nSystem.out.println(\"Tu edad es de \" +\n  ChronoUnit.YEARS.between(fNacimiento, LocalDate.now())\n  + \" a\u00f1os.\"\n);\n</code></pre> <p>Otros ejemplos</p> <p><pre><code>LocalDateTime fechaInicio = LocalDateTime.of(2024, 4, 1, 8, 0); // 1 de abril de 2024, 08:00\nLocalDateTime fechaFin = LocalDateTime.of(2024, 4, 10, 16, 30); // 10 de abril de 2024, 16:30\n\nlong diasEntre = ChronoUnit.DAYS.between(fechaInicio, fechaFin);\nlong horasEntre = ChronoUnit.HOURS.between(fechaInicio, fechaFin);\n\nSystem.out.println(\"D\u00edas entre las fechas: \" + diasEntre);\nSystem.out.println(\"Horas entre las fechas: \" + horasEntre);\n</code></pre> Por otro lado, tenemos la clase <code>Period</code> para medir per\u00edodos de tiempo entre fechas</p> <pre><code>LocalDate fechaInicio = LocalDate.of(2023, 12, 25); // 25 de diciembre de 2023\nLocalDate fechaFin = LocalDate.of(2024, 1, 7); // 7 de enero de 2024\n\nPeriod periodo = Period.between(fechaInicio, fechaFin);\n\nint anios = periodo.getYears();\nint meses = periodo.getMonths();\nint dias = periodo.getDays();\n\nSystem.out.println(\"A\u00f1os: \" + anios + \", Meses: \" + meses + \", D\u00edas: \" + dias);\n</code></pre>"},{"location":"ud7/8fechas/#parseo-de-fechas","title":"Parseo de fechas","text":"<p>Para interpretar una fecha desde una cadena tenemos el m\u00e9todo <code>parse()</code> que si el formato cumple la ISO 8601 no hay que indicarle nada, en otro caso hay que utilizar la clase <code>DateTimeFormatter</code></p> <pre><code>LocalDate fecha1 = LocalDate.parse(\"2020-07-06\");\nLocalDate fecha2 = LocalDate.parse(\"6/11/2020\", DateTimeFormatter.ofPattern(\"d/M/yyyy\") );\n</code></pre>"},{"location":"ud7/8fechas/#formato-personalizado-de-fechas","title":"Formato personalizado de fechas","text":"<p>Al igual que podemos leer una fecha en el formato que necesitemos, podemos mostrar la fecha en el formato que queramos</p> <p>Por defecto se muestra con el formato ISO 8601, podemos cambiar este formato como sigue</p> <p><pre><code>LocalDateTime fechaConHora = LocalDateTime.now();\nDateTimeFormatter esDateFormat = DateTimeFormatter.ofPattern(\"dd/MM/yyyy hh:mm:ss\");\nSystem.out.println(\"Formato espa\u00f1ol (manual): \" + fechaConHora.format(esDateFormat));\n</code></pre> Existen diversos formateadores ya predefinidos en forma de constantes de <code>DateTimeFormatter</code></p> <p></p> <p>Podemos definir un formato espec\u00edfico para un idioma concreto mediate <code>Locale</code></p> <p>Teniendo en cuenta que por ejemplo, supongamos que queremos que el mes se muestre con su nombre completo y no con un n\u00famero; para ello usar\u00edamos el formato \"MMMM\" (las 4 M representan el nombre del mes). Por defecto ese nombre se mostrar\u00eda en ingl\u00e9s, por lo que ver\u00edamos por pantalla, por ejemplo \"July\" y no \"Julio\", en espa\u00f1ol</p> <pre><code>DateTimeFormatter esDateFormatLargo =\nDateTimeFormatter\n  .ofPattern(\"EEEE, dd 'de' MMMM 'de' yyyy 'a las' hh:mm:ss\")\n  .withLocale(new Locale(\"es\", \"ES\"));\nSystem.out.println(\"Formato espa\u00f1ol (largo, localizado): \" + fechaConHora.format(esDateFormatLargo));\n//Formato espa\u00f1ol (largo, localizado): jueves, 11 de abril de 2024 a las 01:52:55\n</code></pre> <p>Pero puede ser necesario que la aplicaci\u00f3n sea global y queramos que se muestre en el formato configurado en el sistema operativo donde se ejecuta</p> <pre><code>LocalDateTime fechaHoraActual = LocalDateTime.now();\n\n// Obtener el formato del sistema operativo actual\nDateTimeFormatter formatter = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM);\n\n// Formatear la fecha y hora actual seg\u00fan el formato del sistema operativo\nString fechaFormateada = fechaHoraActual.format(formatter);\n\n// Mostrar la fecha y hora formateada\nSystem.out.println(\"Fecha y hora formateadas seg\u00fan el formato del sistema operativo actual: \"\n                   + fechaFormateada);\n\n//Fecha y hora formateadas seg\u00fan el formato del sistema operativo actual: 11 abr 2024 13:52:55\n</code></pre>"},{"location":"ud8/1javafx/","title":"JavaFX","text":"<p>JavaFX es una plataforma de aplicaciones de cliente de pr\u00f3xima generaci\u00f3n de c\u00f3digo abierto para sistemas integrados, m\u00f3viles y de escritorio construidos en Java. Es un esfuerzo de colaboraci\u00f3n de muchas personas y empresas con el objetivo de producir un conjunto de herramientas moderno, eficiente y con todas las funciones para desarrollar aplicaciones de clientes enriquecidos.</p> <p>En este tema nos centraremos en las aplicaciones de escritorio. JavaFX est\u00e1 disponible en Windows, Mac OS X y Linux.</p> <p>Dado que la biblioteca JavaFX est\u00e1 escrita como una API de Java, el c\u00f3digo de la aplicaci\u00f3n JavaFX puede hacer referencia a las API de cualquier biblioteca de Java. Por ejemplo, las aplicaciones JavaFX pueden usar bibliotecas API de Java para acceder a las capacidades del sistema nativo y conectarse a aplicaciones de middleware basadas en servidor.</p> <p>Es en esencia un conjunto de paquetes en Java y el sucesor de swing.</p> <p>Documentaci\u00f3n oficial para JavaFX JDK11</p> <p>API documentation</p>"},{"location":"ud8/1javafx/#crear-un-nuevo-proyecto-javafx","title":"Crear un nuevo proyecto JavaFX","text":"<p>En IntelliJ, seleccionamos File -&gt; New Project</p> <p></p> <p>Seleccionamos JavaFX, lo llamamos HolaMundo y le damos a crear. Para ejecutarlo nos ponemos en la clase principal y hacemos click en Run.</p> <p></p>"},{"location":"ud8/1javafx/#workflow-de-una-aplicacion-javafx","title":"Workflow de una aplicaci\u00f3n JavaFX","text":"<ol> <li> <p><code>Application</code> La clase de <code>Application</code> del paquete javafx.application es el punto de entrada de la aplicaci\u00f3n en JavaFX. Para crear una aplicaci\u00f3n JavaFX, se debe heredar esta clase e implementar su m\u00e9todo abstracto <code>start()</code>. La clase principal tiene el nombre del proyecto seguido de Application y extiende de la clase <code>Application</code>, que es la que gestiona el ciclo de vida de una aplicaci\u00f3n JavaFX.</p> </li> <li> <p><code>main</code> method Cuando ejecutamos la aplicaci\u00f3n JavaFX por primera vez, se lanza el m\u00e9todo <code>main</code> que contiene el m\u00e9todo <code>launch</code> que lanza la aplicaci\u00f3n JavaFX y no vuelve hasta que se cierra la aplicaci\u00f3n.</p> </li> <li> <p><code>init</code> method Cuando un aplicaci\u00f3n JavaFX es lanzada, el m\u00e9todo <code>init</code> se ejecuta primero. Este m\u00e9todo se encuentra en la clase <code>Application</code> y est\u00e1 vac\u00edo, por lo que podremos sobreescribirlo si queremos hacer algo con \u00e9l.</p> </li> <li> <p><code>start</code> method El m\u00e9todo <code>start</code> se ejecuta justo despu\u00e9s del m\u00e9todo <code>init</code>. <code>start</code> es un m\u00e9todo abstracto que heredamos de la clase <code>Application</code> por lo que siempre hay que sobreescribirlo y darle cuerpo.</p> </li> <li> <p><code>stop</code> method Cuando la aplicaci\u00f3n acaba porque los usuario cierran la ventana de la aplicaci\u00f3n se ejecuta el m\u00e9todo <code>stop</code>. Igual que pasa con el m\u00e9todo <code>init</code>, este m\u00e9todo se encuentra en la clase <code>Application</code> y est\u00e1 vac\u00edo tambi\u00e9n. Si no lo sobreescribimos no se har\u00e1 nada con \u00e9l.</p> </li> </ol>"},{"location":"ud8/1javafx/#estructura-de-una-aplicacion-javafx","title":"Estructura de una aplicaci\u00f3n JavaFX","text":"<p>En general, una aplicaci\u00f3n JavaFX tendr\u00e1 tres componentes principales, Stage, Scene y Node como se muestra en la siguiente figura:</p> <p></p>"},{"location":"ud8/2stage/","title":"JavaFX Stage","text":"<p>Uno de los s\u00edmiles que m\u00e1s se aproxima para entender estos conceptos es ver el stage como un escenario, teatro o cine, en el cual, se desarrollan escenas. Dicho de otro modo, stage es un espacio y una escena define que sucede en ese espacio. Visto as\u00ed, tenemos que un stage es el contenedor de nivel superior, que como m\u00ednimo consta de una escena, que a su vez es contenedora de otros elementos.</p> <p>Si nuestra programa es una aplicaci\u00f3n de escritorio, el stage ser\u00e1 la ventana, con su barra de t\u00edtulo, y botones de maximizar, minimizar o cerrar, en el caso que que se ejecutase en un navegador web como Chrome, nuestro stage esta embebido dentro del navegador.</p> <p>Un <code>Stage</code> JavaFX, javafx.stage.Stage, es un contenedor de nivel superior y extiende de la clase <code>Window</code>. Representa una ventana en una aplicaci\u00f3n de escritorio JavaFX. Dentro de un stage JavaFX, se puede insertar un <code>Scene</code> JavaFX que representar\u00e1 el contenido que se muestra dentro de una ventana, dentro de un <code>Stage</code>.</p> <p>Cuando se inicia una aplicaci\u00f3n JavaFX, se crea un objeto <code>Stage</code> ra\u00edz que se pasa al m\u00e9todo <code>start(Stage primaryStage)</code> de la clase ra\u00edz de la aplicaci\u00f3n JavaFX. Este objeto Stage representa la ventana principal de la aplicaci\u00f3n. Se pueden crear m\u00e1s objetos nuevos <code>Stage</code> m\u00e1s adelante si la aplicaci\u00f3n necesita abrir m\u00e1s ventanas.</p> <p>Normalmente las aplicaciones tienen una ventana o stage de nivel superior, ya que muchas ventanas pueden conducir a una mala experiencia por parte del usuario.</p> <p></p>"},{"location":"ud8/2stage/#crear-un-stage","title":"Crear un <code>Stage</code>","text":"<pre><code>Stage stage = new Stage();\n</code></pre>"},{"location":"ud8/2stage/#mostrar-un-stage","title":"Mostrar un <code>Stage</code>","text":"<p>Solo con crear un objeto Stage no basta para que se muestre en la aplicaci\u00f3n. Para que el Stage sea visible, se debe llamar a su m\u00e9todo <code>show()</code> o <code>showAndWait()</code>.</p> <pre><code>stage.show();\n</code></pre> <p>La diferencia entre los m\u00e9todos <code>show()</code> y <code>showAndWait()</code>, es que show() hace visible el <code>Stage</code> y sale del m\u00e9todo inmediatamente, mientras que showAndWait() muestra el objeto <code>Stage</code> y luego lo bloquea (permanece dentro del m\u00e9todo showAndWait()) hasta que se cierre el <code>stage</code>.</p>"},{"location":"ud8/2stage/#establecer-un-scene-a-un-stage","title":"Establecer un <code>Scene</code> a un <code>Stage</code>","text":"<p>Para mostrar algo dentro de un <code>Stage</code>, se debe establecer un objeto <code>Scene</code> en el Stage. El contenido de <code>Scene</code> se mostrar\u00e1 dentro del Stage cuando se muestre el Stage.</p> <pre><code>VBox vBox = new VBox(new Label(\"A JavaFX Label\"));\nScene scene = new Scene(vBox);\n\nStage stage = new Stage();\nstage.setScene(scene);\nstage.show();\n</code></pre>"},{"location":"ud8/2stage/#ponerle-titulo-a-un-stage","title":"Ponerle t\u00edtulo a un <code>Stage</code>","text":"<p>El t\u00edtulo del <code>Stage</code> se muestra en la barra de t\u00edtulo de la ventana.</p> <pre><code>stage.setTitle(\"Aplicaci\u00f3n JavaFX\");\n</code></pre>"},{"location":"ud8/2stage/#posicionar-un-stage","title":"Posicionar un <code>Stage</code>","text":"<p>Se puede establecer la posici\u00f3n (X,Y) de un <code>Stage</code> a trav\u00e9s de sus m\u00e9todos setX() y setY(). Los m\u00e9todos setX() y setY() establecen la posici\u00f3n de la esquina superior izquierda de la ventana.</p> <pre><code>Stage stage = new Stage();\n\nstage.setX(50);\nstage.setY(50);\n</code></pre>"},{"location":"ud8/2stage/#dimensionar-un-stage","title":"Dimensionar un <code>Stage</code>","text":"<p>Para establecer el ancho y el alto de un <code>Stage</code> utilizaremos los m\u00e9todos <code>setWidth()</code> y <code>setHeight()</code>.</p> <pre><code>Stage stage = new Stage();\n\nstage.setWidth(600);\nstage.setHeight(300);\n</code></pre>"},{"location":"ud8/2stage/#establecer-una-ventana-modal","title":"Establecer una ventana modal","text":"<p>Si queremos establecer la ventana como modal en un <code>Stage</code> usamos el m\u00e9todo <code>initModality()</code>. La modalidad determina si la ventana que representa el Stage bloquear\u00e1 otras ventanas abiertas por la misma aplicaci\u00f3n.</p> <pre><code>@Override\npublic void start(Stage primaryStage) {\n    primaryStage.setTitle(\"JavaFX App\");\n\n    Stage stage = new Stage();\n    stage.initModality(Modality.APPLICATION_MODAL);\n    //stage.initModality(Modality.WINDOW_MODAL);\n    //stage.initModality(Modality.NONE);\n\n    primaryStage.show();\n\n    stage.showAndWait();\n\n}\n</code></pre> <ul> <li>Modalidad.APPLICATION_MODAL, bloquear\u00e1 todas las dem\u00e1s ventanas abiertas por esta aplicaci\u00f3n. No puede acceder a ninguna otra ventana hasta que se haya cerrado esta ventana.</li> <li>Modality.WINDOW_MODAL el <code>Stage</code> creado bloquear\u00e1 la ventana del <code>Stage</code> que \"posee\" (propietario) el <code>Stage</code> creado, pero solo eso. No todas las ventanas de la aplicaci\u00f3n.</li> <li>Modalidad.NONE el <code>Stage</code> no bloquear\u00e1 ninguna otra ventana abierta en esta aplicaci\u00f3n.</li> </ul>"},{"location":"ud8/2stage/#establecer-propietario-de-un-stage","title":"Establecer propietario de un <code>Stage</code>","text":"<p>Un <code>Stage</code> puede ser propiedad de otro <code>Stage</code>. El propietario de un stage se establece a trav\u00e9s de su m\u00e9todo <code>initOwner()</code>.</p> <pre><code>@Override\npublic void start(Stage primaryStage) {\n    primaryStage.setTitle(\"JavaFX App\");\n\n    Stage stage = new Stage();\n    stage.initModality(Modality.WINDOW_MODAL);\n\n    stage.initOwner(primaryStage);\n\n    primaryStage.show();\n\n    stage.showAndWait();\n}\n</code></pre>"},{"location":"ud8/2stage/#dar-estilo-a-un-stage","title":"Dar estilo a un <code>Stage</code>","text":"<p>Se puede dar estilo a un stage utilizando el m\u00e9todo <code>initStyle()</code>. Hay un conjunto de estilos diferentes:</p> <ul> <li>DECORATED: es una ventana est\u00e1ndar con decoraciones del sistema operativo (barra de t\u00edtulo y botones para minimizar/maximizar/cerrar) y un fondo blanco.</li> <li>UNDECORATED: es una ventana est\u00e1ndar sin decoraciones del sistema operativo, pero a\u00fan con un fondo blanco.</li> <li>TRANSPARENT: es una ventana sin decorar con un fondo transparente.</li> <li>UNIFIED: es como un escenario decorado, excepto que no tiene borde entre el \u00e1rea de decoraci\u00f3n y el \u00e1rea de contenido principal.</li> <li>UTILITY: es una ventana decorada, pero con decoraciones m\u00ednimas.</li> </ul> <pre><code>stage.initStyle(StageStyle.DECORATED);\n</code></pre>"},{"location":"ud8/2stage/#stage-a-pantalla-completa","title":"<code>Stage</code> a pantalla completa","text":"<p>Se puede establecer el stage a modo de pantalla completa a trav\u00e9s del m\u00e9todo <code>setFullScreen()</code>. Nota: puede que no obtengamos el resultado esperado sino a\u00f1adimos un <code>Scene</code> en el stage.</p> <pre><code>VBox vbox = new VBox();\nScene scene = new Scene(vbox);\n\nprimaryStage.setScene(scene);\nprimaryStage.setFullScreen(true);\n\nprimaryStage.show();\n</code></pre>"},{"location":"ud8/2stage/#eventos-del-ciclo-de-vida-de-un-stage","title":"Eventos del ciclo de vida de un <code>Stage</code>","text":"<p><code>Stage</code> emite algunos eventos que se pueden escuchar.</p> <ul> <li>Close Request: se recibe una notificaci\u00f3n cuando el usuario hace click en el bot\u00f3n con la X en la esquina superior derecha de la ventana del escenario. Escuchar el evento de cierre del escenario puede ser \u00fatil si se necesita limpiar algunos recursos despu\u00e9s de cerrar la ventana principal del escenario, o p. necesita detener algunos hilos, etc.</li> </ul> <pre><code>primaryStage.setOnCloseRequest((event) -&gt; {\n    System.out.println(\"Closing Stage\");\n});\n</code></pre> <ul> <li>Hiding: se llama antes de que se oculte el stage, pero despu\u00e9s de que se haya solicitado ocultarlo.</li> </ul> <pre><code>primaryStage.setOnHiding((event) -&gt; {\n    System.out.println(\"Hiding Stage\");\n});\n</code></pre> <ul> <li>Hidden: se llama despu\u00e9s de que se oculta el Stage.</li> </ul> <pre><code>primaryStage.setOnHidden((event) -&gt; {\n    System.out.println(\"Stage hidden\");\n});\n</code></pre> <ul> <li>Showing: se llama despu\u00e9s de que se solicite que se muestre el stage, pero antes de que se muestre.</li> </ul> <pre><code>primaryStage.setOnShowing((event) -&gt; {\n    System.out.println(\"Showing Stage\");\n});\n</code></pre> <ul> <li>Shown: se llama despu\u00e9s de que se muestre el stage.</li> </ul> <pre><code>primaryStage.setOnShown((event) -&gt; {\n    System.out.println(\"Stage Shown\");\n});\n</code></pre>"},{"location":"ud8/2stage/#eventos-de-teclado-del-stage","title":"Eventos de teclado del <code>Stage</code>","text":"<p>Podemos escuchar eventos de teclado en un stage. De esta forma, se puede capturar todos los eventos del teclado que ocurren mientras el stage tiene el foco. Ejemplo que escucha las teclas ESC y Retorno en el teclado cuando un Stage tiene foco:</p> <pre><code>primaryStage.addEventHandler(KeyEvent.KEY_PRESSED,  (event) -&gt; {\n    System.out.println(\"Key pressed: \" + event.toString());\n\n    switch(event.getCode().getCode()) {\n        case 27 : { // 27 = ESC key\n            primaryStage.close();\n            break;\n        }\n        case 10 : { // 10 = Return\n            primaryStage.setWidth( primaryStage.getWidth() * 2);\n        }\n        default:  {\n            System.out.println(\"Unrecognized key\");\n        }\n    }\n});\n</code></pre>"},{"location":"ud8/3scene/","title":"JavaFX Scene","text":"<p>Para mostrar cualquier cosa en un escenario <code>Stage</code> se necesita una escena <code>Scene</code>. Un <code>Stage</code> solo puede mostrar una escena a la vez, pero es posible intercambiar la escena en tiempo de ejecuci\u00f3n. Al igual que un escenario en un teatro se puede reorganizar para mostrar varias escenas durante una obra, un objeto de escenario (stage) en JavaFX puede mostrar varias escenas (una a la vez) durante la vida \u00fatil de una aplicaci\u00f3n JavaFX.</p> <p>Quiz\u00e1s se pregunte por qu\u00e9 una aplicaci\u00f3n JavaFX tendr\u00eda m\u00e1s de una escena por etapa. Imagina un juego de computadora. Un juego puede tener m\u00faltiples \"pantallas\" para mostrar al usuario. Por ejemplo, una pantalla de men\u00fa inicial, la pantalla principal del juego (donde se juega el juego), una pantalla de finalizaci\u00f3n del juego y una pantalla de puntuaci\u00f3n m\u00e1s alta. Cada una de estas pantallas puede ser representada por una escena diferente. Cuando el juego necesita cambiar de una pantalla a la siguiente, simplemente adjunta la escena correspondiente al objeto Stage de la aplicaci\u00f3n JavaFX.</p> <p>Una escena est\u00e1 representada por un objeto <code>Scene</code> dentro de una aplicaci\u00f3n JavaFX.</p> <p>Note</p> <p>Para que un objeto <code>Scene</code> sea visible debe configurarse en un <code>Stage</code>.</p>"},{"location":"ud8/3scene/#scene-graph","title":"Scene Graph","text":"<p>Todos los componentes visuales (controls, layouts, etc.) deben adjuntarse a un <code>Scene</code> para ser mostrados, y ese <code>Scene</code> debe adjuntarse a un <code>Stage</code> para que la escena completa sea visible. El objeto gr\u00e1fico total final de todos los controles, layouts, etc. adjuntos a un <code>Scene</code> se denomina gr\u00e1fico de escena (Scene Graph).</p> <p>Consta de todos los nodos que se adjuntan a un objeto de Scene determinado. Cada objeto Scene tiene su propio gr\u00e1fico de escena.</p> <p>El Scene Graph tiene un \u00fanico nodo ra\u00edz. Se pueden adjuntar otros nodos al nodo ra\u00edz en una estructura de datos similar a un \u00e1rbol (un \u00e1rbol es una especie de gr\u00e1fico).</p>"},{"location":"ud8/3scene/#crear-un-scene","title":"Crear un Scene","text":"<p>Para crear un objeto <code>Scene</code> lo haremos a trav\u00e9s de su constructor. Como par\u00e1metro, se debe pasar el componente ra\u00edz de la GUI de JavaFX que actuar\u00e1 como la vista ra\u00edz que se mostrar\u00e1 dentro de la escena.</p> <pre><code>VBox  vBox  = new VBox();\nScene scene = new Scene(vBox);\n</code></pre>"},{"location":"ud8/3scene/#establecer-un-scene-en-un-stage","title":"Establecer un Scene en un Stage","text":"<p>Para hacer visible un <code>Scene</code> debe asignarse a un <code>Stage</code>.</p> <pre><code>VBox vBox = new VBox(new Label(\"A JavaFX Label\"));\nScene scene = new Scene(vBox);\n\nStage stage = new Stage();\nstage.setScene(scene);\n</code></pre> <p>Un Scene se puede adjuntar a un solo Stage a la vez, y el Stage tambi\u00e9n puede mostrar solo un Scene a la vez.</p>"},{"location":"ud8/3scene/#scene-mouse-cursor","title":"Scene Mouse Cursor","text":"<p>Es posible configurar el cursor del mouse de un <code>Scene</code>. Se establece el cursor del mouse de una escena a trav\u00e9s del m\u00e9todo <code>setCursor()</code>.</p> <pre><code>scene.setCursor(Cursor.OPEN_HAND);\n</code></pre> <p>La clase <code>javafx.scene.Cursor</code> contiene muchas constantes que puede usar para especificar qu\u00e9 cursor del mouse desea mostrar. Algunas de estas constantes son:</p> <ul> <li>Cursor.OPEN_HAND</li> <li>Cursor.CLOSED_HAND</li> <li>Cursor.CROSSHAIR</li> <li>Cursor.DEFAULT</li> <li>Cursor.HAND</li> <li>Cursor.WAIT</li> <li>Cursor.MOVE</li> </ul> <p>Puede consultar el resto en la documentaci\u00f3n oficial de JavaFX.</p>"},{"location":"ud8/4node/","title":"JavaFX Node","text":"<p>La clase <code>Node</code>, javafx.scene.Node, es la clase base (superclase) para todos los componentes agregados a JavaFX Scene Graph. La clase <code>Node</code> es abstracta, por lo que solo agregar\u00e1 subclases de la clase Node al Scene Graph. Todas las instancias de <code>Node</code> en el escenario gr\u00e1fico comparten un conjunto de propiedades comunes que est\u00e1n definidas por la clase JavaFX <code>Node</code> y que veremos a continuaci\u00f3n.</p>"},{"location":"ud8/4node/#conceptos-basicos-de-node","title":"Conceptos b\u00e1sicos de <code>Node</code>","text":"<p>Cada instancia de <code>Node</code> (subclase) solo se puede agregar al Scene Graph una vez. En otras palabras, cada instancia de Node solo puede aparecer en un lugar en el escenario gr\u00e1fico. Si intenta agregar la misma instancia de Node, o instancia de subclase de Node, al gr\u00e1fico de escena m\u00e1s de una vez, se generar\u00e1 una excepci\u00f3n.</p> <p>Un nodo JavaFX a veces puede tener subelementos, que tambi\u00e9n se denominan elementos secundarios.</p> <p>Una vez que se adjunta una instancia de node al gr\u00e1fico de escena, solo el hilo de la aplicaci\u00f3n JavaFX puede modificar la instancia de node.</p>"},{"location":"ud8/4node/#propiedades-de-javafx-node","title":"Propiedades de JavaFX <code>Node</code>","text":"<p>La clase <code>Node</code> y, por lo tanto, todas las subclases de Node, tienen las siguientes propiedades comunes:</p>"},{"location":"ud8/4node/#1-sistema-de-coordenadas-coordinate-system","title":"1. Sistema de coordenadas (Coordinate System)","text":"<p>Cada nodo JavaFX tiene su propio sistema de coordenadas cartesianas. La \u00fanica diferencia con un sistema de coordenadas cartesianas regular es que el eje Y est\u00e1 invertido. Eso significa que el origen del sistema de coordenadas est\u00e1 en la esquina superior izquierda del sistema de coordenadas. A medida que aumentan los valores de Y, el punto se mueve hacia abajo desde la parte superior del sistema de coordenadas. Esta inversi\u00f3n del eje Y es normal en los sistemas de coordenadas de gr\u00e1ficos 2D.</p> <p></p> <p>Es posible que un nodo JavaFX tenga coordenadas X e Y negativas.</p> <p>Cada nodo tiene su propio sistema de coordenadas. Este sistema de coordenadas se utiliza para colocar instancias de nodos secundarios dentro del nodo principal o al dibujar en un lienzo JavaFX. Eso significa que un nodo que es hijo de otro nodo tiene su propio sistema de coordenadas y una ubicaci\u00f3n (X,Y) dentro del sistema de coordenadas de su nodo principal.</p> <p>A continuaci\u00f3n se muestra un ejemplo de un sistema de coordenadas de nodo principal en el que un nodo secundario est\u00e1 ubicado en (25,25) en el sistema de coordenadas del nodo principal. El nodo secundario tambi\u00e9n tiene su propio sistema de coordenadas que tiene su (0,0) donde el nodo secundario se encuentra en el sistema de coordenadas principal, es decir, en (25,25) en el sistema de coordenadas del nodo principal.</p> <p></p>"},{"location":"ud8/4node/#2-cuadro-delimitador-bounding-box","title":"2. Cuadro delimitador (Bounding Box)","text":"<p>Un nodo JavaFX tiene un cuadro delimitador. El cuadro delimitador es un cuadro l\u00f3gico alrededor de la forma del nodo. El nodo completo se encuentra dentro del cuadro delimitador, es decir, gr\u00e1ficamente. En otras palabras, todas las esquinas y bordes del Nodo est\u00e1n contenidos dentro del cuadro delimitador, y no hay espacio adicional alrededor del Nodo, a menos que se agregue a trav\u00e9s de un efecto, relleno u otra cosa aplicada al Nodo.</p> <p></p> <p>En realidad, un nodo tiene 3 cuadros delimitadores:</p> <ul> <li>layoutBounds Los l\u00edmites del nodo en su propio espacio de coordenadas, sin aplicar ning\u00fan efecto, recorte o transformaci\u00f3n.</li> <li>boundsInLocal Los l\u00edmites del nodo en su propio espacio de coordenadas, con efectos y clip aplicados, pero sin transformaciones.</li> <li>boundsInParent Los l\u00edmites del nodo en su espacio de coordenadas principal, con efectos, recorte y transformaciones aplicadas.</li> </ul> <p></p> <p>Cada una de estas dimensiones del cuadro delimitador se puede leer desde sus propiedades correspondientes con el mismo nombre, es decir, propiedades denominadas layoutBounds,boundsInLocal yboundsInParent.</p> <p>El cuadro boundsInParent es utilizado por el nodo padre (padre) para dise\u00f1ar sus hijos. El nodo principal necesita conocer el espacio total, incluidos todos los efectos, clips y transformaciones de un nodo para poder asignarle espacio.</p>"},{"location":"ud8/4node/#3-layoutx-y-layouty","title":"3. layoutX y layoutY","text":"<p>Las propiedades layoutX y layoutY de un objeto de nodo contienen la X y la Y del nodo dentro de su padre.</p>"},{"location":"ud8/4node/#4-preferred-height-and-width","title":"4. Preferred height and width","text":"<p>Las propiedades de ancho y alto preferidas de un objeto de nodo especifican el ancho y alto preferidos del objeto de nodo dado (normalmente subclase de nodo). No todas las clases de nodos principales respetar\u00e1n el ancho preferido y la altura preferida de un nodo secundario. Depende de la implementaci\u00f3n concreta del nodo padre.</p>"},{"location":"ud8/4node/#5-minimum-height-and-minimum-width","title":"5. Minimum height and Minimum width","text":"<p>Las propiedades m\u00ednimas de ancho y alto de un objeto de nodo JavaFX especifican el ancho y el alto m\u00ednimos que un nodo quiere (o necesita) para mostrarse. No todas las clases de nodos principales pueden respetar estas propiedades. Depende de la implementaci\u00f3n concreta del nodo padre.</p>"},{"location":"ud8/4node/#6-maximum-height-and-maximum-width","title":"6. Maximum height and Maximum width","text":"<p>Las propiedades m\u00e1ximas de ancho y alto de un objeto de nodo especifican el ancho y alto m\u00e1ximo que un nodo quiere (o necesita) para mostrarse. No todas las clases de nodos principales pueden respetar estas propiedades. Depende de la implementaci\u00f3n concreta del nodo padre.</p>"},{"location":"ud8/4node/#7-user-data","title":"7. User data","text":"<p>Puede establecer datos de usuario en un nodo utilizando el m\u00e9todo <code>setUserData()</code>. Este m\u00e9todo toma cualquier objeto Java de su elecci\u00f3n. De esta manera puede adjuntar, por ejemplo objetos de instancias de nodo.</p>"},{"location":"ud8/4node/#8-items-child-nodes","title":"8. Items (Child nodes)","text":"<p>Muchas subclases de nodos pueden contener elementos o nodos secundarios. La forma exacta en que agrega y accede a estos nodos secundarios depende de la subclase de nodo concreta. Algunas clases tienen un m\u00e9todo <code>getItems()</code> que devuelve una lista de elementos. Otras clases tienen un m\u00e9todo <code>getChildren()</code> que hace lo mismo. Se tendr\u00e1 que comprobar la subclase de Nodo concreta para averiguar si puede tener elementos o nodos secundarios, y c\u00f3mo los agrega y accede a ellos.</p>"},{"location":"ud8/5uicontrols/","title":"UI Controls (User Interface Controls)","text":"<p>Los controles de la interfaz de usuario de JavaFX disponibles a trav\u00e9s de la API de JavaFX se crean mediante el uso de nodos en el gr\u00e1fico de escena. Pueden aprovechar al m\u00e1ximo las funciones visualmente ricas de la plataforma JavaFX y son port\u00e1tiles entre diferentes plataformas. JavaFX CSS permite la creaci\u00f3n de temas y estilos a los diferentes ontroles de la interfaz de usuario.</p> <p></p> <p>Las clases para construir controles de interfaz de usuario residen en el paquete <code>javafx.scene.control</code> de la API de JavaFX.</p> <p>La lista de controles de IU incluye componentes de IU t\u00edpicos que puede reconocer de su desarrollo anterior de aplicaciones cliente en Java. Sin embargo, el SDK de JavaFX presenta nuevos controles de interfaz de usuario de Java, como <code>TitledPane</code>, <code>ColorPicker</code> y <code>Pagination</code> entre otros.</p> <p>Podemos obtener informaci\u00f3n detallada sobre todos los controles de interfaz de usuario de JavaFX disponibles en Documentaci\u00f3n JavaFX UI y en la documentaci\u00f3n de la API para el paquete javafx.scene.control.</p>"},{"location":"ud8/5uicontrols/#funciones-y-efectos","title":"Funciones y efectos","text":"<p>Dado que los controles de la interfaz de usuario del paquete javafx.scene.control son extensiones de la clase Node, se pueden integrar con la representaci\u00f3n, la animaci\u00f3n, las transformaciones y las transiciones animadas del gr\u00e1fico de escena.</p> <p>Considere la tarea de crear un bot\u00f3n, aplicarle un reflejo y animar el bot\u00f3n alterando su opacidad de su valor m\u00e1ximo a su valor m\u00ednimo.</p> <p>La siguiente figura muestra tres estados del bot\u00f3n a trav\u00e9s de la l\u00ednea de tiempo de la animaci\u00f3n. La imagen de la izquierda muestra el bot\u00f3n cuando su opacidad se establece en 1,0, la imagen central muestra la opacidad establecida en 0,8 y la imagen de la derecha muestra la opacidad establecida en 0,5.</p> <p></p> <p>El siguiente ejemplo crea e inicia una l\u00ednea de tiempo indefinida, donde dentro de un cuadro de 600 milisegundos, la opacidad del bot\u00f3n cambia de su valor predeterminado (1,0) a 0,0.</p> <pre><code>Button button = new Button();\n    button.setText(\"OK\");\n    button.setFont(new Font(\"Tahoma\", 24));\n    button.setEffect(new Reflection());\n\nfinal Timeline timeline = new Timeline();\ntimeline.setCycleCount(Timeline.INDEFINITE);\ntimeline.setAutoReverse(true);\nfinal KeyValue kv = new KeyValue(button.opacityProperty(), 0);\nfinal KeyFrame kf = new KeyFrame(Duration.millis(600), kv);\ntimeline.getKeyFrames().add(kf);\ntimeline.play();\n</code></pre> <p>Podemos aplicar otros efectos visuales disponibles en el paquete <code>javafx.scene.effect</code>, como sombra, iluminaci\u00f3n o desenfoque de movimiento.</p>"},{"location":"ud8/5uicontrols/#aplicar-estilo-a-los-controles-de-la-interfaz-de-usuario-con-css","title":"Aplicar estilo a los controles de la interfaz de usuario con CSS","text":"<p>Podemos personalizar el aspecto de los controles de la interfaz de usuario definiendo sus propias hojas de estilo en cascada (CSS). Usar CSS en aplicaciones JavaFX es muy similar a usar CSS en HTML, porque cada caso se basa en la misma especificaci\u00f3n de CSS. El estado visual de un control se define mediante el archivo .css, como se muestra en el ejemplo.</p> <pre><code>/*controlStyle.css */\n\n.scene{\n    -fx-font: 14pt \"Cambria Bold\";\n    -fx-color: #e79423;\n    -fx-background: #67644e;\n}\n\n.button{\n    -fx-text-fill: #006464;\n    -fx-background-color: #e79423;\n    -fx-border-radius: 20;\n    -fx-background-radius: 20;\n    -fx-padding: 5;\n}\n</code></pre> <pre><code>Scene scene = new Scene();\nscene.getStylesheets().add(\"uicontrolssample/controlStyle.css\");\n</code></pre> <p>Adem\u00e1s, tambi\u00e9n podemos definir el estilo de un control directamente en el c\u00f3digo de la aplicaci\u00f3n utilizando el m\u00e9todo <code>setStyle()</code>.</p>"},{"location":"ud8/5uicontrols/#graficos-charts","title":"Gr\u00e1ficos (Charts)","text":"<p>Adem\u00e1s de los elementos t\u00edpicos de una interfaz de usuario, JavaFX proporciona gr\u00e1ficos predefinidos en el paquete <code>javafx.scene.chart</code>. Actualmente se admiten los siguientes tipos de gr\u00e1ficos: gr\u00e1fico de \u00e1reas, gr\u00e1fico de barras, gr\u00e1fico de burbujas, gr\u00e1fico de l\u00edneas, gr\u00e1fico circular y gr\u00e1fico de dispersi\u00f3n. Un gr\u00e1fico puede contener varias series de datos.</p>"},{"location":"ud8/5uicontrols/#preferred-size-tamano-preferido","title":"Preferred Size (tama\u00f1o preferido)","text":"<p>Cada control calcula su preferred size en funci\u00f3n de su contenido, es decir, el alto y el ancho del control cuando se muestra.</p> <p>Por ejemplo, en el caso de un button se redimensionar\u00e1 a si mismo de forma que haya espacio suficiente para mostrar su contenido, en su caso el texto.</p>"},{"location":"ud8/6layouts/","title":"Layout","text":"<p>Los contenedores o paneles de dise\u00f1o (layout) nos permiten a\u00f1adir controles de la interfaz de usuario dentro de un gr\u00e1fico de escena de una aplicaci\u00f3n JavaFX sin tener que escribir el c\u00f3digo necesario para gestionar el posicionamiento o el cambio de tama\u00f1o de esos controles. El Layout gestionar\u00e1 todo eso por nosotros. La API de layout de JavaFX incluye 8 layouts:</p> <p></p> <ol> <li><code>BorderPane</code>: presenta sus nodos de contenido en la regi\u00f3n superior, inferior, derecha, izquierda o central. </li> <li><code>HBox</code> organiza sus nodos de contenido horizontalmente en una sola fila y los dimensiona con sus tama\u00f1os preferidos. Normalmente usamos un HBox para dise\u00f1ar un conjunto de botones en un di\u00e1logo.</li> <li><code>VBox</code> organiza sus nodos de contenido verticalmente en una sola columna.</li> <li><code>StackPane</code> coloca sus nodos de contenido en una sola pila de atr\u00e1s hacia adelante.</li> <li><code>GridPane</code> permite al desarrollador crear una cuadr\u00edcula flexible de filas y columnas en la que dise\u00f1ar los nodos de contenido. Cada posici\u00f3n de la cuadr\u00edcula se llama celda. Un fila ser\u00e1 tan alta como el control m\u00e1s alto y una columna ser\u00e1 tan ancha como el control m\u00e1s ancho que contiene.</li> <li><code>FlowPane</code> organiza sus nodos de contenido en un \"flujo\" horizontal o vertical, envolvi\u00e9ndose en los l\u00edmites especificados de ancho (para horizontal) o alto (para vertical).</li> <li><code>TilePane</code> coloca sus nodos de contenido en mosaicos o celdas de dise\u00f1o de tama\u00f1o uniforme y los envuelve como hace <code>FlowPane</code>.</li> <li><code>AnchorPane</code> permite a los desarrolladores crear nodos de anclaje en la parte superior, inferior, izquierda o central del dise\u00f1o.</li> </ol> <p>Para lograr una estructura de dise\u00f1o deseada, se pueden anidar diferentes layouts dentro de una aplicaci\u00f3n JavaFX.</p> <p>En <code>HBox</code> y <code>VBox</code> si al reducir la ventana los hijos que contienen esos paneles no caben, entonces se cortan. En cambio, con <code>FlowPane</code>, pasan a la siguiente fila en el caso de que la orientaci\u00f3n sea horizontal y si es vertical pasar\u00edan a la siguiente columna.</p>"},{"location":"ud8/7events/","title":"Eventos","text":"<p>Cada vez que un usuario interact\u00faa con la aplicaci\u00f3n (nodos), se dice que ha ocurrido un evento. Existe un <code>UIThread</code> que est\u00e1 escuchando cuando lanzamos la aplicaci\u00f3n. Cuando el usuario hace algo el UIThread que est\u00e1 escuchando, mira a ver si se lanza un evento, y si es as\u00ed, env\u00eda el evento al controlador de eventos (event handler). El Event Handler se ejecuta en el subproceso del hilo UIThread. Mientras se ejecuta un evento del UIThread el usuario no puede interactuar con la aplicaci\u00f3n.</p> <p>Por ejemplo, hacer clic en un bot\u00f3n, mover el mouse, ingresar un car\u00e1cter a trav\u00e9s del teclado, seleccionar un elemento de la lista, desplazarse por la p\u00e1gina, etc. son ejemplos de actividades que provocan que suceda un evento.</p> <p>Un evento notifica que ha ocurrido algo importante. Los eventos suelen ser la parte \"primitiva\" de un sistema de eventos (tambi\u00e9n conocido como bus de eventos). Generalmente, un sistema de eventos tiene las siguientes 3 responsabilidades:</p> <ol> <li>Trigger an event (disparar un evento),</li> <li>Notify listeners (notificar a los oyentes partes interesadas) sobre el evento y</li> <li>Handle the event (manejar o procesar el evento).</li> </ol> <p>El mecanismo de notificaci\u00f3n de eventos lo realiza la plataforma JavaFX autom\u00e1ticamente. Por lo tanto, solo consideraremos c\u00f3mo disparar eventos, escuchar eventos y c\u00f3mo manejarlos.</p>"},{"location":"ud8/7events/#tipos-de-eventos","title":"Tipos de eventos","text":"<ul> <li>Eventos en primer plano (foreground events): requieren la interacci\u00f3n directa de un usuario. Se generan como consecuencia de la interacci\u00f3n de una persona con los componentes gr\u00e1ficos en una interfaz gr\u00e1fica de usuario. Por ejemplo, hacer clic en un bot\u00f3n, mover el mouse, ingresar un car\u00e1cter a trav\u00e9s del teclado, seleccionar un elemento de la lista, desplazarse por la p\u00e1gina, etc.</li> <li>Eventos de fondo (background events): no requieren la interacci\u00f3n del usuario final. Las interrupciones del sistema operativo, fallas de hardware o software, vencimiento del temporizador, finalizaci\u00f3n de la operaci\u00f3n son ejemplos de eventos en segundo plano.</li> </ul>"},{"location":"ud8/7events/#eventos-en-javafx","title":"Eventos en JavaFX","text":"<p>La clase denominada <code>Event</code> del paquete <code>javafx.event</code> es la clase base para un evento. Una instancia de cualquiera de sus subclases es un evento. JavaFX proporciona una amplia variedad de eventos. Algunos de ellos se enumeran a continuaci\u00f3n.</p> <ul> <li> <p>Mouse event: evento de entrada que ocurre cuando se hace clic en el mouse. Est\u00e1 representado por la clase denominada <code>MouseEvent</code>. Incluye acciones como hacer clic con el mouse, presionar el mouse, soltar el mouse, mover el mouse, objetivo ingresado con el mouse, objetivo salido del mouse, etc.</p> </li> <li> <p>Key event: evento de entrada que indica que se produjo una pulsaci\u00f3n de tecla en un nodo. Est\u00e1 representado por la clase denominada <code>KeyEvent</code>. Este evento incluye acciones como pulsaci\u00f3n de tecla, liberaci\u00f3n de tecla y escritura de tecla.</p> </li> <li> <p>Drag event: evento de entrada que ocurre cuando se arrastra el mouse. Est\u00e1 representado por la clase llamada <code>DragEvent</code>. Incluye acciones como arrastrar para insertar, arrastrar para soltar, etc.</p> </li> <li> <p>Window event: evento relacionado con las acciones de mostrar/ocultar ventanas. Est\u00e1 representado por la clase llamada <code>WindowEvent</code>.</p> </li> </ul>"},{"location":"ud8/7events/#manejo-de-eventos-event-handling","title":"Manejo de eventos (Event Handling)","text":"<p>Es el mecanismo que controla el evento y decide qu\u00e9 debe suceder, si ocurre un evento. Tiene el c\u00f3digo que se conoce como event handler que se ejecuta cuando ocurre un evento.</p> <p>En JavaFX cada evento tiene:</p> <ol> <li> <p>Target: el nodo en el que se produjo un evento. Un objetivo puede ser una ventana, una escena y un nodo.</p> </li> <li> <p>Source: la fuente a partir de la cual se genera el evento. Por ejemplo, el mouse es la fuente del evento.</p> </li> <li> <p>Type: tipo del evento ocurrido; en el caso de un evento del mouse, el tipo de evento es presionar el mouse y soltar el mouse.</p> </li> </ol> <p>Supongamos que tenemos una aplicaci\u00f3n que tiene botones. Si hace clic en un bot\u00f3n, la source ser\u00e1 el mouse, el target ser\u00e1 el nodo del bot\u00f3n presionado y el tipo de evento generado ser\u00e1 el clic del mouse.</p>"},{"location":"ud8/7events/#fases-del-manejo-de-eventos","title":"Fases del manejo de eventos","text":"<p>Cada vez que se genera un evento, JavaFX pasa por las siguientes fases.</p>"},{"location":"ud8/7events/#route-construction-construccion-de-rutas","title":"Route construction (Construcci\u00f3n de rutas)","text":"<p>Cada vez que se genera un evento, la ruta predeterminada/inicial del evento est\u00e1 determinada por la construcci\u00f3n de una cadena de env\u00edo de eventos. Es el camino desde el escenario hasta el Nodo fuente.</p> <p>A continuaci\u00f3n se muestra la cadena de env\u00edo de eventos para el evento generado, cuando hacemos clic en el bot\u00f3n en el escenario anterior: Stage -&gt; Scene -&gt; Button</p>"},{"location":"ud8/7events/#event-capturing-phase-fase-de-captura-de-eventos","title":"Event capturing phase (Fase de captura de eventos)","text":"<p>Despu\u00e9s de la fase anterior se dispara el evento. Este evento viaja a todos los nodos de la cadena de despacho anterior (de arriba a abajo). Si alguno de estos nodos tiene registrado un filtro (filter) para el evento generado, se ejecutar\u00e1. Si ninguno de los nodos en la cadena de despacho tiene un filtro para el evento generado, entonces se pasa al nodo de destino y finalmente el nodo de destino procesa el evento.</p>"},{"location":"ud8/7events/#event-bubbling-phase-fase-de-propagacion-de-eventos","title":"Event bubbling phase (Fase de propagaci\u00f3n de eventos)","text":"<p>Aqu\u00ed el evento viaja desde el nodo de destino hasta el nodo de Stage (de abajo hacia arriba). Si alguno de los nodos de la cadena de env\u00edo de eventos tiene un controlador (handler) registrado para el evento generado, se ejecutar\u00e1. Si ninguno de estos nodos tiene controladores para manejar el evento, entonces el evento llega al nodo ra\u00edz y finalmente se completar\u00e1 el proceso.</p>"},{"location":"ud8/7events/#event-handlers-and-filters","title":"Event handlers and filters","text":"<p>Los filter y handlers de eventos son aquellos que contienen la l\u00f3gica de la aplicaci\u00f3n para procesar un evento. Un nodo puede registrarse en m\u00e1s de un controlador/filtro (handler/filter).</p> <p>Como se mencion\u00f3 anteriormente, durante el evento, el procesamiento es un filtro que se ejecuta y durante la fase de propagaci\u00f3n del evento, se ejecuta un controlador. Todos los controladores y filtros implementan la interfaz EventHandler del paquete javafx.event.</p>"},{"location":"ud8/7events/#anadir-y-eliminar-un-event-filter","title":"A\u00f1adir y eliminar un event filter","text":"<p>Para agregar un filtro de eventos a un nodo, debe registrar este filtro utilizando el m\u00e9todo <code>addEventFilter()</code> de la clase Node.</p> <pre><code>//Creating the mouse event handler \nEventHandler&lt;MouseEvent&gt; eventHandler = new EventHandler&lt;MouseEvent&gt;() { \n   @Override \n   public void handle(MouseEvent e) { \n      System.out.println(\"Hello World\"); \n      boton.setFill(Color.DARKSLATEBLUE);  \n   } \n};   \n//Adding event Filter \nboton.addEventFilter(MouseEvent.MOUSE_CLICKED, eventHandler);\n</code></pre> <p>Para eliminar un filter hacemos:</p> <pre><code>boton.removeEventFilter(MouseEvent.MOUSE_CLICKED, eventHandler);\n</code></pre>"},{"location":"ud8/7events/#anadir-y-eliminar-event-handler","title":"A\u00f1adir y eliminar event handler","text":"<p>Para agregar un controlador de eventos a un nodo, debe registrar este controlador mediante el m\u00e9todo <code>addEventHandler()</code> de la clase Node, como se muestra a continuaci\u00f3n.</p> <pre><code>//Creating the mouse event handler \nEventHandler&lt;MouseEvent&gt; eventHandler = \n   new EventHandler&lt;MouseEvent&gt;() { \n\n   @Override \n   public void handle(MouseEvent e) { \n      System.out.println(\"Hello World\"); \n      boton.setFill(Color.DARKSLATEBLUE);             \n   } \n};    \n//Adding the event handler \nboton.addEventHandler(MouseEvent.MOUSE_CLICKED, eventHandler);\n</code></pre> <p>Para eliminar:</p> <pre><code>boton.removeEventHandler(MouseEvent.MOUSE_CLICKED, eventHandler);\n</code></pre> <p>Controllers JavaFX</p>"},{"location":"ud9/12binaryfiles/","title":"Ficheros binarios","text":""},{"location":"ud9/12binaryfiles/#excepciones-comprobadas","title":"Excepciones comprobadas","text":"<p>Recuerda que tenemos <code>Checked exceptions</code> que se pueden producir y es obligatorio manejarlas</p> <p>Excepciones</p> <p>Las clase de I/O te obligan a trabajar con try/catch</p>"},{"location":"ud9/12binaryfiles/#escribir-datos-en-un-fichero-binario","title":"Escribir datos en un fichero binario","text":"<p>La escritura en ficheros binarios representa el flujo de salida de bytes, es decir, necesitamos utilizar las clases que derivan de <code>OutputStream</code>. Se puede escribir datos en un fichero binario de muchas formas. Veamos un ejemplo utilizando la clase <code>FileOutputStream</code>.</p> <pre><code> public static void main(String[] args) {\n        DataOutputStream fos=null;\n        try {\n            fos= new DataOutputStream(new FileOutputStream(\"datos.dat\"));\n            fos.writeInt(0);\n            fos.writeInt(-34);\n            //todas pueden derivar de IOException\n        } catch (FileNotFoundException e) {\n            System.out.println(e.getMessage());\n        } catch (IOException e) {\n            System.out.println(e.getMessage());\n        }finally{//siempre se ejecuta y permite cerrar\n            if(fos!=null) {\n                try {\n                    fos.close();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n    }\n</code></pre> <p>En el ejemplo, el constructor <code>FileOutputStream</code> abre el fichero <code>datos.dat</code> para escritura. Se crea un nuevo fichero; si un fichero antiguo tiene el mismo nombre, se eliminar\u00e1. Luego, un <code>DataOutputStream</code> se conecta al <code>FileOutputStream</code>.</p> <p><code>DataOutputStream</code> tiene m\u00e9todos para escribir datos primitivos en un flujo de salida. El m\u00e9todo writeInt() escribe los cuatro bytes de un tipo de datos int en la secuencia.</p> <p>El programa escribe cuatro enteros en el flujo de salida y luego cierra el flujo.</p> <p>Warning</p> <p>Siempre hay que cerrar el flujo para asegurarse de liberar todos los recursos asociados a \u00e9l y que el sistema operativo no consuma recursos.</p> <p>La excepci\u00f3n <code>IOException</code> se lanza si el stream se ha cerrado y el flujo de salida contenido no admite la escritura despu\u00e9s del cierre, o se produce otro error de I/O.</p>"},{"location":"ud9/12binaryfiles/#try-with-resources","title":"try-with-resources","text":"<p>La declaraci\u00f3n <code>try-with-resource</code> es una caracter\u00edstica introducida en Java 7 que facilita la gesti\u00f3n de recursos que deben cerrarse expl\u00edcitamente, como flujos de archivos o conexiones a bases de datos. Permite que los recursos sean autom\u00e1ticamente cerrados una vez que el bloque try termina, incluso si ocurre una excepci\u00f3n. Esto simplifica el c\u00f3digo y reduce la posibilidad de fugas de recursos.</p> <p><pre><code>public static void main(String[] args) {\n    try(DataOutputStream fos = new DataOutputStream(new FileOutputStream(\"datos.dat\"))) {\n\n        fos.writeInt(0);\n        fos.writeInt(-34);\n\n    } catch (FileNotFoundException e) { //todas pueden derivar de IOException\n        System.out.println(e.getMessage());\n    } catch (IOException e) {\n        System.out.println(e.getMessage());\n    }\n}\n</code></pre> Pero podemos seguir usando la versi\u00f3n con <code>finally</code> </p>"},{"location":"ud9/12binaryfiles/#escritura-en-un-fichero-binario-usando-el-bufer","title":"Escritura en un fichero binario usando el b\u00fafer","text":"<p>Ahora vamos a escribir m\u00e1s enteros en el fichero. Para ello utilizamos <code>BufferedOutputStream</code>. Este b\u00fafer almacena los bytes antes de que se escriban en el disco. Recuerda que un b\u00fafer es un bloque de memoria que se usa para ensamblar datos antes de que se escriban todos a la vez.</p> <p></p> <p>Cuando se cierra el stream <code>close()</code>, es como si pinch\u00e1ramos en guardar de forma gr\u00e1fica, es decir, que si no cerramos el stream es como si el fichero estuviera vac\u00edo.</p> <p>El almacenamiento en b\u00fafer hace que las operaciones de E/S sean m\u00e1s eficientes. Para un programa que realiza E/S masivas, el almacenamiento en b\u00fafer es esencial. La E/S es muy lenta en comparaci\u00f3n con las operaciones con almacenamiento principal. Sin almacenamiento en b\u00fafer, la E/S ser\u00eda muy, muy lenta.</p> <pre><code> public static void writeBuffer() {\n    DataOutputStream out =null;\n    try {\n        out = new DataOutputStream(\n                new BufferedOutputStream(\n                        new FileOutputStream(\"datosBufer.dat\")));\n        for (int i = 0; i &lt; 1000; i++) {\n            out.writeInt(i);\n        }\n\n    } catch (FileNotFoundException e) {\n        throw new RuntimeException(e);\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }finally{//siempre se ejecuta y permite cerrar\n       if(fos!=null) {\n                try {\n                    fos.close();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n    }\n}\n</code></pre>"},{"location":"ud9/12binaryfiles/#lectura-de-datos-en-un-fichero-binario","title":"Lectura de datos en un fichero binario","text":"<p>Para leer un fichero, primero hemos de preguntarnos un poco sobre \u00e9l, es decir, si fue escrito por un programa Java, entonces necesitaremos saber qu\u00e9 tipos de datos se usaron, y as\u00ed poder usar una subclase de <code>InputStream</code> para leer bytes para ese tipo de datos.</p> <p><code>InputStream</code>, como hemos visto en los diagramas, es una clase abstracta para objetos que leen flujos de bytes. Aunque, no todas las clases que derivan de ella est\u00e1n relacionadas con la entrada de ficheros de disco. Por ejemplo, <code>PipedInputStream</code> representa datos provenientes de otro programa en ejecuci\u00f3n.</p> <pre><code>public static void main(String[] args) {\n    try( DataInputStream dis = new DataInputStream(new FileInputStream(\"datos.dat\"));) {\n\n        //leer todos los enteros de un fichero\n        while (dis.available() &gt; 0) {//me va diciendo cu\u00e1ntos bytes disponibles hay en el input stream\n            //mientras hayan bytes que leer\n            System.out.println(dis.readInt());\n        }\n\n    } catch (FileNotFoundException e) { //todas pueden derivar de IOException\n        System.out.println(e.getMessage());\n    } catch (IOException e) {\n        System.out.println(e.getMessage());\n\n    }\n}\n</code></pre> <p>Al igual que en la escritura para la lectura tambi\u00e9n disponemos de la clase <code>BufferedInputStream</code>.</p>"},{"location":"ud9/12binaryfiles/#lectura-y-escritura-de-objetos-en-ficheros","title":"Lectura y escritura de Objetos en ficheros","text":"<p>Para poder guardar objetos de una Clase en un fichero es necesario que la clase implemente la interface <code>Serializable</code> que no es obligatorio implementar ning\u00fan m\u00e9todo. Vamos a ver un ejemplo donde guardamos una ArrayList y luego lo recuperamos</p> <p><pre><code>public class Socio implements Serializable {\n    //nombre del fichero\n    public static final String SOCIOS_DAT = \"socios.dat\";\n    // private static final long serialVersionUID = 1L;\n    private String dni;\n    private String nombre;\n\n    public Socio(String dni, String nombre) {\n        this.dni = dni;\n        this.nombre = nombre;\n    }\n    @Override\n    public String toString() {\n        return \"Socio{\" +\n                \"dni='\" + dni + '\\'' +\n                \", nombre='\" + nombre + '\\'' +\n                '}';\n    }\n}\n</code></pre> Para la escritura del ArrayList de Socios en el fichero podemos llamar al siguiente m\u00e9todo <pre><code>// M\u00e9todo para guardar en un archivo binario\n    public static void guardarEnArchivo(ArrayList&lt;Socio&gt; socios, String nombreArchivo) {\n        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(nombreArchivo))) {\n            oos.writeObject(socios);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n</code></pre> Para la lectura <pre><code>public static ArrayList&lt;Socio&gt; leerDesdeArchivo(String nombreArchivo) {\n        ArrayList&lt;Socio&gt; socios = null;\n        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(nombreArchivo))) {\n            Object obj = ois.readObject();\n            if (obj instanceof ArrayList) {\n                socios = (ArrayList&lt;Socio&gt;) obj;\n            }\n        } catch (IOException | ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n        return socios;\n    }\n</code></pre> Un ejemplo de guardado y recuperaci\u00f3n <pre><code> public static void main(String[] args) {\n        // Crear algunos socios y guardarlos en un ArrayList\n        ArrayList&lt;Socio&gt; socios = new ArrayList&lt;&gt;();\n        socios.add(new Socio(\"12345678A\", \"Juan Perez\"));\n        socios.add(new Socio(\"87654321B\", \"Mar\u00eda Lopez\"));\n        socios.add(new Socio(\"98765432C\", \"Pedro Gomez\"));\n\n        // Guardar los socios en un archivo binario\n        guardarEnArchivo(socios, SOCIOS_DAT);\n\n        // Leer los socios desde el archivo binario\n        ArrayList&lt;Socio&gt; sociosLeidos = leerDesdeArchivo(SOCIOS_DAT);\n\n        // Imprimir los socios le\u00eddos\n        System.out.println(\"Socios le\u00eddos:\");\n        if(sociosLeidos!=null)\n            sociosLeidos.forEach(System.out::println);\n}\n</code></pre></p>"},{"location":"ud9/13characterfiles/","title":"Ficheros de caracteres","text":"<p>Las  clases Java <code>FileWriter</code> y <code>FileReader</code> se utilizan para escribir y leer datos de archivos de texto (son clases de flujo de caracteres, character stream). Se recomienda no utilizar las clases <code>FileInputStream</code> y <code>FileOutputStream</code> si vamos a leer o escribir informaci\u00f3n de texto.</p> <p></p>"},{"location":"ud9/13characterfiles/#escritura-de-caracteres","title":"Escritura de caracteres","text":"<p>La clase Java <code>FileWriter</code> del paquete java.io se utiliza para escribir datos en forma de caracteres en un archivo.</p> <ul> <li>Esta clase hereda de la clase <code>OutputStream</code>.</li> <li>Los constructores de esta clase asumen que la codificaci\u00f3n de caracteres predeterminada y el tama\u00f1o de b\u00fafer de bytes predeterminado son aceptables.</li> <li><code>FileWriter</code> est\u00e1 dise\u00f1ado para escribir secuencias de caracteres. Si queremos escribir flujos de bytes sin procesar, tendr\u00edamos que usar la clase <code>FileOutputStream</code>.</li> </ul> <p>Los m\u00e9todos principales</p> M\u00e9todo Descripci\u00f3n void write(int caracter) escribe un car\u00e1cter en el archivo void write(String cadena) escribe una cadena en el archivo void newline() escribe un salto de l\u00ednea en el fichero. Se debe evitar el uso expl\u00edcito del car\u00e1cter <code>\\n</code> para insertar saltos de l\u00ednea, ya que su codificaci\u00f3n es distinta seg\u00fan la plataforma utilizada. void flush() vac\u00eda el buffer de salida, escribiendo en el fichero los caracteres pendientes. void close() cierra el flujo de salida, vaciando el buffer y liberando el recurso correspondiente. <pre><code>public static void main(String[] args)  {      \n        BufferedWriter fw=null;\n        try {\n            fw =new BufferedWriter(new FileWriter(\"output.txt\"));\n            fw.write(\"Esto es un ejemplo\"); \n            //nueva linea\n            fw.newLine();\n            fw.write(\"Segunda linea\"); \n        } catch(IOException e) {\n            System.out.println(\"Error E/S: \" + e);\n        }finally{\n            if (fw != null) {\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    System.out.println(e.getMessage());\n                }\n            }\n        }\n}\n</code></pre> <p>Cuando se cierra el stream <code>close()</code> se escribe en el fichero. Si quisi\u00e9ramos grabar en el fichero en alg\u00fan momento antes de cerrar, podemos usar el m\u00e9todo <code>flush()</code>.</p>"},{"location":"ud9/13characterfiles/#escritura-de-string-como-systemout","title":"Escritura de String como System.out","text":"<p>Podemos utilizar la clase <code>PrintWriter</code> para la escritura de String en el archivo. Proporciona m\u00e9todos parececidos a <code>System.out</code></p> <pre><code> public static void main(String[] args) {\n    try( FileWriter fileWriter = new FileWriter(\"output.txt\");\n        PrintWriter printWriter = new PrintWriter(fileWriter);\n    ) {\n        // Datos a escribir\n        String nombre = \"Juan\";\n        int edad = 30;\n        double altura = 1.75;\n\n        // Escribir los datos en el archivo con formato\n        printWriter.println(\"Nombre: \"+nombre);\n        printWriter.println(\"Edad: \"+edad);\n        //con formato\n        printWriter.printf(\"Altura: %.2f\\n\", altura);\n\n        System.out.println(\"Se ha escrito en el archivo exitosamente.\");\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n\n}\n</code></pre>"},{"location":"ud9/13characterfiles/#lectura-de-datos","title":"Lectura de datos","text":"<p><code>FileReader</code> es una clase en el paquete java.io que se usa para leer una secuencia de caracteres de los ficheros. Esta clase se hereda de la clase <code>InputStreamReader</code>.</p> <ul> <li><code>FileReader</code> est\u00e1 dise\u00f1ada para leer flujos de caracteres. Para leer flujos de bytes sin procesar, usaremos <code>FileInputStream</code>.</li> </ul> <p>Los m\u00e9todos principales</p> M\u00e9todo Descripci\u00f3n readLine() para leer l\u00edneas de texto del fichero (String). Este m\u00e9todo devuelve null cuando no hay m\u00e1s l\u00edneas para leer read() para leer car\u00e1cter a car\u00e1cter. Devuelve un entero que representa el c\u00f3digo Unicode del car\u00e1cter le\u00eddo. Devuelve -1 si no hay m\u00e1s caracteres. <pre><code>   public static void main(String[] args) {\n        int ch;\n        try(FileReader fr = new FileReader(\"output.txt\");) {            \n            ch = fr.read();\n            while (ch != -1) { //fin de fichero\n                System.out.print((char) ch);\n                ch = fr.read();\n            }\n\n        } catch (IOException fe) {\n            System.out.println(\"Error de E/S\");\n        }\n    }\n</code></pre> <p>Otro ejemplo en el que se leen l\u00edneas completas. En este caso utilizamos <code>BufferedReader</code></p> <pre><code>public static void main(String[] args) {\n        try (var in = new BufferedReader(new FileReader(\"datos.txt\"))) {\n            String cadena = in.readLine();\n            while (cadena != null) {\n                System.out.println(cadena);\n                cadena = in.readLine();\n            }\n        } catch (FileNotFoundException e) {\n            System.out.println(\"ERROR. Archivo no encontrado\");\n        } catch (IOException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}\n</code></pre>"},{"location":"ud9/13characterfiles/#lectura-de-ficheros-de-texto-con-scanner","title":"Lectura de ficheros de texto con Scanner","text":"<p>A partir de Java 5 se puede leer un fichero de texto utilizando la clase Scanner igual que si ley\u00e9ramos por teclado. Para ello se le pasa al constructor de Scanner el objeto FileReader asociado al fichero. Esta operaci\u00f3n lanza una excepci\u00f3n <code>FileNotFoundException</code>.</p> <p>Lectura de un fichero de texto con una serie de enteros separados por secuencias de espacios y tabuladores, incluso en l\u00edneas distintas</p> <p>12 34 56 32 43</p> <pre><code>public static void main(String[] args) {\n\n /*\n Creamos el flujo de texto a partir del nombre del archivo. Como\n Dentro del bloque try solo se va a abrir el archivo y no se va a leer\n de \u00e9l, basta con la excepci\u00f3n FileNotFoundException\n */\n    try(FileInputStream flujo = new FileInputStream(\"datos.txt\");\n         var sc = new Scanner(flujo);) {\n\n        while (sc.hasNext()) { // en principio, no sabemos cu\u00e1ntos n\u00fameros hay\n            int n = sc.nextInt();\n            System.out.print(n + \" \"); // vamos mostrando los n\u00fameros le\u00eddos\n\n        }        \n\n    } catch (FileNotFoundException e) {\n        System.out.println(\"ERROR. Archivo no encontrado\");\n    } catch (IOException e) {\n            System.out.println(\"ERROR de E/S\");\n        }\n}\n</code></pre>"},{"location":"ud9/14fileclass/","title":"File vs Path","text":"<p>En Java, <code>Path</code> y <code>File</code> son clases responsables de las operaciones de E/S de ficheros. Realizan las mismas funciones pero pertenecen a diferentes paquetes.</p>"},{"location":"ud9/14fileclass/#clase-file","title":"Clase <code>File</code>","text":"<p>Las primeras versiones de Java incluyen el paquete <code>java.io</code>, que contiene casi todas las clases que podr\u00edamos necesitar para realizar operaciones de entrada y salida. La clase <code>File</code> es una representaci\u00f3n abstracta de nombres de rutas de ficheros, directorios y m\u00e9todos para manipularlos.</p> <p>Un objeto <code>File</code> NO es el fichero real. No contiene los datos que contiene el fichero. Es un objeto que contiene m\u00e9todos que afectan a un archivo o directorio en particular y las funciones para la manipulaci\u00f3n real del archivo.</p> <p>Ejemplo en Windows:</p> <pre><code>File f = new File(\"C:\\\\Users\\\\temp\\\\data.txt\");\n</code></pre> <p>En Linux el car\u00e1cter separador es <code>/</code>.</p>"},{"location":"ud9/14fileclass/#constructor-de-file","title":"Constructor de <code>File</code>","text":"<pre><code>File(String pathName) //Constructor\n</code></pre> <p><code>pathName</code> es una secuencia de nombres de directorio seguidos de un nombre de archivo. Los nombres de los directorios est\u00e1n separados por un car\u00e1cter especial. La sintaxis de los nombres de directorio, separadores y nombres de archivo depende del sistema operativo.</p> <p>Warning</p> <p>Construir un objeto de la clase File NO CREA UN FICHERO</p> <pre><code>public static void main(String[] args) {\n    File file = new File(\"archivo.txt\");\n    if (file.exists()) {\n        System.out.println(\"Nombre del archivo: \" + file.getName());\n        System.out.println(\"Ruta absoluta: \" + file.getAbsolutePath());\n        System.out.println(\"Tama\u00f1o del archivo: \" + file.length() + \" bytes\");\n    } else {\n        System.out.println(\"El archivo no existe.\");\n    }\n}\n</code></pre>"},{"location":"ud9/14fileclass/#desventajas-de-la-clase-file","title":"Desventajas de la clase <code>File</code>","text":"<ul> <li> <p>Manejo de errores El problema m\u00e1s com\u00fan es el manejo deficiente de errores. Muchos m\u00e9todos no nos dicen ning\u00fan detalle sobre el problema encontrado o incluso lanzan excepciones.</p> </li> <li> <p>Compatibilidad con metadatos Los metadatos pueden incluir permisos, propietario del fichero y atributos de seguridad. Debido a esto, la clase <code>File</code> no admite enlaces simb\u00f3licos en absoluto, y el m\u00e9todo rename() no funciona de manera consistente en diferentes plataformas.</p> </li> <li> <p>Escalabilidad y rendimiento de m\u00e9todos Tambi\u00e9n hay un problema de rendimiento porque los m\u00e9todos de la clase File no escalan. Conduce a problemas con algunos directorios con una gran cantidad de archivos. Enumerar el contenido de un directorio podr\u00eda provocar un bloqueo, lo que provocar\u00eda problemas de recursos de memoria. Debido a algunos de estos inconvenientes, Oracle desarroll\u00f3 la API NIO2 mejorada.</p> </li> </ul>"},{"location":"ud9/14fileclass/#clase-path","title":"Clase Path","text":"<p>La clase <code>Path</code> nos permite manipular las rutas de archivos y directorios.</p> <p>Ejemplos</p> <p>Crear un objeto Path a partir de una ruta</p> <p><pre><code>public static void main(String[] args) {\n    Path path = Paths.get(\"ruta/del/archivo.txt\");\n    System.out.println(\"Ruta: \" + path.toString());\n}\n</code></pre> Obtener la ruta absoluta de un archivo</p> <p><pre><code> public static void main(String[] args) {\n        Path path = Paths.get(\"ruta/del/archivo.txt\");\n        Path absolutePath = path.toAbsolutePath();\n        System.out.println(\"Ruta absoluta: \" + absolutePath.toString());\n    }\n</code></pre> Obtener el nombre del archivo</p> <p><pre><code>public static void main(String[] args) {\n    Path path = Paths.get(\"ruta/del/archivo.txt\");\n    System.out.println(\"Nombre del archivo: \" + path.getFileName());\n}\n</code></pre> Obtener la subruta de una ruta</p> <p><pre><code>public static void main(String[] args) {\n    Path path = Paths.get(\"ruta/del/archivo.txt\");\n    Path subPath = path.subpath(0, 2); // Empieza en 0, termina en 2 (exclusivo)\n    System.out.println(\"Subruta: \" + subPath.toString());\n}\n</code></pre> Verificar si una ruta es absoluta</p> <pre><code>public static void main(String[] args) {\n    Path path = Paths.get(\"ruta/del/archivo.txt\");\n    boolean isAbsolute = path.isAbsolute();\n    System.out.println(\"\u00bfEs absoluta? \" + isAbsolute);\n}\n</code></pre>"},{"location":"ud9/14fileclass/#path-vs-file","title":"Path vs File","text":"<p>Cuando construimos un objeto <code>File</code> lo hacemos a trav\u00e9s del constructor, mientras que en la clase <code>Path</code> se usa un m\u00e9todo est\u00e1tico.</p> <pre><code>File file = new File(\"ada.txt\");\nPath path = Paths.get(\"ada.txt\");\n</code></pre>"},{"location":"ud9/15javanio/","title":"java.nio","text":"<ul> <li><code>java.nio.file.Path</code>: Es una interfaz que localiza un fichero o directorio mediante una ruta dependiente del sistema.</li> <li><code>java.nio.file.Files</code>: En combinaci\u00f3n con <code>Path</code>, realiza operaciones en ficheros o directorios.</li> <li><code>java.nio.file.FileSystem</code>: Proporciona una interfaz para el sistema de ficheros y una f\u00e1brica para crear <code>Path</code> y otros objetos que acceden al sistema de ficheros.</li> <li>Todos los m\u00e9todos que acceden  al sistema de ficheros lanzan una excepci\u00f3n de tipo <code>IOException</code>.</li> </ul>"},{"location":"ud9/15javanio/#path","title":"<code>Path</code>","text":"<p>Ofrece una API completamente nueva para trabajar con E/S. Adem\u00e1s, al igual que la clase <code>File</code>, <code>Path</code> tambi\u00e9n crea un objeto que se puede usar para ubicar un archivo en un sistema de archivos.</p> <p><code>Path</code> puede realizar todas las operaciones que se pueden realizar con la clase <code>File</code>.</p> <p>Muchos ficheros utilizan la notaci\u00f3n \".\" para denotar el directorio actual y \"..\" para denotar el directorio del padre.</p>"},{"location":"ud9/15javanio/#filesystems-cargar-un-fichero-con-filesystems","title":"<code>FileSystems</code>. Cargar un fichero con FileSystems","text":"<pre><code>Path path = FileSystems.getDefault().getPath(\"fichero.txt\");\n</code></pre>"},{"location":"ud9/15javanio/#escritura-en-un-fichero","title":"Escritura en un fichero","text":"<pre><code>Path p = FileSystems.getDefault().getPath(\"ficPrueba.txt\");\ntry(BufferedWriter bw = Files.newBufferedWriter(p)) {\n    for (int i = 0; i &lt; 10; i++) {\n        bw.write(String.valueOf(i));\n    }\n} catch (IOException e) {\n    throw new RuntimeException(e);\n}\n</code></pre>"},{"location":"ud9/15javanio/#lectura-de-un-fichero","title":"Lectura de un fichero","text":"<p>Con buffer:</p> <pre><code>Path p = FileSystems.getDefault().getPath(\"ficPrueba.txt\");\ntry (BufferedReader br = Files.newBufferedReader(p)) {\n    String input;\n    while ((input = br.readLine()) != null) {\n        System.out.println(input);\n    }\n} catch (IOException e) {\n    throw new RuntimeException(e);\n}\n\nPath p = FileSystems.getDefault().getPath(\"ficPrueba.txt\");\ntry {\n    List&lt;String&gt; lines = Files.readAllLines(p);\n    for (String line: lines) {\n        System.out.println(line);\n    }\n} catch (IOException e) {\n    throw new RuntimeException(e);\n}\n</code></pre>"},{"location":"ud9/15javanio/#listar-todos-los-directorios-con-fileswalk","title":"Listar todos los directorios con Files.walk","text":"<p>Es importante utilizar el try with resources para cerrar el stream. Viene especificado en la documentaci\u00f3n oficial</p> <p>Note</p> <p>This method must be used within a try-with-resources statement or similar control structure to ensure that the stream's open directories are closed promptly after the stream's operations have completed.</p> <pre><code>List&lt;Path&gt; result;\ntry (Stream&lt;Path&gt; walk = Files.walk(path)) {\n    result = walk.filter(Files::isDirectory)\n            .collect(Collectors.toList());\n}\n</code></pre>"},{"location":"ud9/16randomaccessfile/","title":"Acceso aleatorio a ficheros","text":"<p>Todos los flujos de E/S que hemos usado hasta ahora se conocen como flujos de solo lectura o solo escritura. Estos flujos se denominan flujos secuenciales en Java.</p> <p>Un fichero que se lee o escribe mediante un flujo secuencial se denomina fichero de acceso secuencial. Los datos de un fichero de acceso secuencial NO se pueden actualizar.</p> <p>Por lo tanto, para leer y escribir datos simult\u00e1neamente, Java proporciona la clase <code>RandomAccessFile</code>. Con esta clase, podemos leer y escribir datos en cualquier ubicaci\u00f3n del fichero. Los archivos de acceso aleatorio son \u00fatiles para muchas aplicaciones diferentes.</p>"},{"location":"ud9/16randomaccessfile/#puntero-de-la-clase-randomaccessfile","title":"Puntero de la clase <code>RandomAccessFile</code>","text":"<p>Un fichero de acceso aleatorio consta de una secuencia de bytes. \u00c9stos, admiten un puntero especial conocido como puntero de fichero (file pointer). El puntero indica la posici\u00f3n actual (ubicaci\u00f3n) en el fichero.</p> <p>Se coloca en uno de estos bytes en el fichero y se puede mover a cualquier posici\u00f3n arbitraria antes de leer o escribir.</p> <p>En otras palabras, se lleva a cabo una operaci\u00f3n de lectura o escritura en la ubicaci\u00f3n del puntero.</p> <p>El puntero se puede mover utilizando el m\u00e9todo <code>seek()</code>.</p> <p>Cuando se crea un fichero por primera vez, el puntero se establece en 0, lo que indica el comienzo del archivo. Cuando leemos o escribimos datos en el archivo usando m\u00e9todos de lectura o escritura, el puntero del archivo avanza al siguiente elemento de datos (es decir, el siguiente byte).</p> <p>Por ejemplo, si leemos un valor int usando el m\u00e9todo readInt() del archivo, JVM lee 4 bytes usando el puntero, y ahora el puntero del archivo est\u00e1 4 bytes por delante de la posici\u00f3n anterior, como se muestra en la figura a continuaci\u00f3n.</p> <p></p> <pre><code>RandomAccessFile raf = ....\n\nraf.seek(position); //mueve el puntero a una posici\u00f3n\nraf.seek(0); //mueve el puntero al inicio del fichero\nraf.seek(raf.length()); //mueve el puntero al final del fichero\n</code></pre>"},{"location":"ud9/16randomaccessfile/#constructor-de-la-clase-randomaccessfile","title":"Constructor de la clase RandomAccessFile","text":"<p>Para construir un objeto de la clase tenemos que especificar el modo (mode) que determina qu\u00e9 tipo de acceso a ficheros est\u00e1 permitido.</p> <ul> <li>r: el fichero es de solo lectura.</li> <li>rw: se abre en modo lectura-escritura.</li> <li>rws: se abre para lectura y escritura y cada cambio en los datos del fichero se escribir\u00e1 inmediatamente en el dispositivo f\u00edsico.</li> </ul> <pre><code>&gt; RandomAccessFile raf = new RandomAccessFile(\"myfile.dat\", \"rw\");\n</code></pre>"},{"location":"ud9/16randomaccessfile/#ejemplo-de-un-programa-que-anade-texto-al-final-de-un-fichero","title":"Ejemplo de un programa que a\u00f1ade texto al final de un fichero","text":"<p><pre><code>public static void main(String[] args) {\n    RandomAccessFile file = null;\n    try {\n        file = new RandomAccessFile(\"file.txt\", \"rw\");\n        file.seek(file.length()); // Moving file pointer to the end.\n        file.writeBytes(\"\\nJava\"); // Append text.\n        file.close();\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}\n</code></pre> Si el programa requiere  trabajar con objetos, todos los objetos tienen que ser del mismo tama\u00f1o. Vamos a ver un ejemplo en el que fijamos el tama\u00f1o de los string en el que recortamos el los campos o rellenamos con espacios si no tiene la longitud definida y calculamos el tama\u00f1o que tiene un objeto de tipo Contacto</p> <pre><code>class Contacto {\n    //tama\u00f1o fijo de los campos\n    final static int LONGITUD_NOMBRE = 20;\n    final static int LONGITUD_DIRECCION = 30;\n    final static int LONGITUD_TELEFONO = 10;\n    //tama\u00f1o de registro. Es necesario conocer el tama\u00f1o para mover el cursor del fichero correctamente\n    final static int SIZE_REGISTRO =4+//tama\u00f1o int\n                                //tama\u00f1o de los string\n                                    (LONGITUD_NOMBRE + LONGITUD_DIRECCION + LONGITUD_TELEFONO)\n                                    +6;//2 bytes por cada string que guarda el tama\u00f1o del string en el fichero\n\n    private int id;\n    private String nombre;\n    private String direccion;\n    private String telefono;\n\n    public Contacto(int id, String nombre, String direccion, String telefono) {\n        this.id = id;\n        setNombre(nombre);\n        setDireccion(direccion);\n        setTelefono(telefono);\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public String getNombre() {\n        return nombre;\n    }\n\n    public String getDireccion() {\n        return direccion;\n    }\n\n    public String getTelefono() {\n        return telefono;\n    }\n //Los setter se encargan de ajusta los string al tama\u00f1o exacto\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public void setNombre(String nombre) {\n        this.nombre = ajustarLongitud(nombre, LONGITUD_NOMBRE);\n    }\n\n    public void setDireccion(String direccion) {\n        this.direccion = ajustarLongitud(direccion, LONGITUD_DIRECCION);\n    }\n\n    public void setTelefono(String telefono) {\n        this.telefono = ajustarLongitud(telefono, LONGITUD_TELEFONO);\n    }\n    //ajusta la longitud de la cadena a la longitud deseada\n    public static String ajustarLongitud(String cadena, int longitud) {\n        if (cadena.length() &gt;= longitud) {\n            // Si la longitud de la cadena es mayor o igual a la longitud deseada, se recorta\n            return cadena.substring(0, longitud);\n        } else {\n            // Si la longitud de la cadena es menor que la longitud deseada, se rellena con espacios\n            StringBuilder sb = new StringBuilder(cadena);\n            while (sb.length() &lt; longitud) {\n                sb.append(' ');\n            }\n            return sb.toString();\n        }\n    }\n    @Override\n    public String toString() {\n        return id + \" \" + nombre + \" \" + direccion + \" \" + telefono;\n    }\n    // M\u00e9todo para escribir el objeto Contacto en un RandomAccessFile en la posici\u00f3n actual\n    public static void escribirContacto(RandomAccessFile raf,Contacto contacto) throws IOException {\n        raf.writeInt(contacto.getId());\n        //writeUTF escribe en el fichero el tama\u00f1o del string al inicio del string \n        raf.writeUTF(contacto.getNombre());\n        raf.writeUTF(contacto.getDireccion());\n        raf.writeUTF(contacto.getTelefono());\n\n    }\n    //Escribe un contacto en la posisi\u00f3n indicada\n    public static void escribirContacto(RandomAccessFile raf,Contacto contacto,int posicion) throws IOException {\n        //Posicionamos el cursor en la posicion indicada              \n        if(raf.length() &gt; (posicion*SIZE_REGISTRO)){\n            raf.seek(posicion*SIZE_REGISTRO);\n           escribirContacto(raf,contacto);\n        }else throw new IOException(\"Posicion fuera de rango\");\n    }\n\n    // M\u00e9todo para leer el objeto Contacto desde un RandomAccessFile en la posici\u00f3n actual\n    public  static Contacto leerContacto(RandomAccessFile raf) throws IOException {\n        int id = raf.readInt();\n        //el metodo readUTF lee el string de tama\u00f1o indicado al inicio\n        String nombre = raf.readUTF();\n        String direccion = raf.readUTF();\n        String telefono = raf.readUTF();\n\n        return new Contacto(id, nombre, direccion, telefono);\n    }\n    //Leer un contacto posicionando el cursor en la posicion indicada\n    public static Contacto leerContacto(RandomAccessFile raf, int posicion) throws IOException {\n        //Posicionamos el cursor en la posici\u00f3n indicada\n        if(raf.length() &gt; (posicion*SIZE_REGISTRO)){\n            raf.seek(posicion*SIZE_REGISTRO);\n            return leerContacto(raf);\n        }else throw new IOException(\"Posicion fuera de rango\");\n\n    }  \n}\n</code></pre> <p>Un ejemplo de uso de la clase anterior</p> <pre><code>public static void main(String[] args) {\n    Contacto[] contactos = {\n            new Contacto(1, \"Juan\", \"Calle 123, Alicante\", \"123456789\"),\n            new Contacto(2, \"Maria\", \"Carrera 456\", \"987654321\"),\n            new Contacto(3, \"Pedro\", \"Avenida XYZ\", \"456123789\")\n    };\n\n    try(RandomAccessFile raf = new RandomAccessFile(\"agenda.dat\", \"rw\");) {\n\n        //escritura secuencial\n        for (Contacto contacto : contactos) {\n            Contacto.escribirContacto(raf,contacto);\n        }\n\n        System.out.println(\"Contactos guardados en agenda.dat\");\n        //lectura secuencial del fichero\n        raf.seek(0);\n        while (raf.getFilePointer() &lt; raf.length()) {\n            Contacto contacto = Contacto.leerContacto(raf);\n            System.out.println(contacto);\n            System.out.println(raf.getFilePointer());\n        }\n\n        //lectura aleatoria del fichero\n        Contacto contacto = Contacto.leerContacto(raf, 1);\n        System.out.println(\"Contacto aleatorio: \" + contacto);\n\n        //escritura aleatoria del fichero\n        contacto.setNombre(\"Maria Jose\");\n        contacto.setTelefono(\"555676766\");\n        Contacto.escribirContacto(raf, contacto, 1);\n\n        //leer el anterior\n        contacto = Contacto.leerContacto(raf, 1);\n        System.out.println(\"Contacto aleatorio: \" + contacto);\n\n\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n</code></pre>"},{"location":"ud9/17configfiles/","title":"Ficheros de configuraci\u00f3n","text":"<p>En Java es habitual guardar algunos par\u00e1metros de configuraci\u00f3n de nuestro programa en un fichero de propiedades. Un fichero de propiedades no es m\u00e1s que un fichero de texto, habitualmente con la extensi\u00f3n \u201c.properties\u201d, en donde cada l\u00ednea tiene una pareja clave=valor.</p> <p>En la API de Java se incluyen librer\u00edas para trabajar con los ficheros de configuraci\u00f3n. Puesto que todos siguen un mismo patr\u00f3n, es la librer\u00eda la que se encarga de acceder al fichero a bajo nivel y el programador s\u00f3lo tiene que indicar a que propiedad quiere acceder o que propiedad quiere modificar, sin tener que a\u00f1adir nada de c\u00f3digo para leer o escribir el fichero tal.</p> <p>Aqu\u00ed se muestra un ejemplo de fichero de configuraci\u00f3n, llamado <code>datasource.properties</code>, que almacena informaci\u00f3n sobre la base de datos:</p> <p></p> <p>La primera l\u00ednea del ejemplo es un comentario, que se indica con #, y las posteriores cada clave, parte izquierda del =, ser\u00e1 un par\u00e1metro de nuestra configuraci\u00f3n separado por un igual donde est\u00e1 su valor correspondiente, parte derecha del =.</p> <p>Java nos proporciona la clase <code>Properties</code>, para leer de forma sencilla los ficheros de configuraci\u00f3n.</p>"},{"location":"ud9/17configfiles/#cargar-el-fichero-de-configuracion","title":"Cargar el fichero de configuraci\u00f3n","text":"<p>Lo primero que haremos ser\u00e1 inicializar nuestro objeto Properties.</p> <pre><code>Properties properties = new Properties();\n</code></pre> <p>Esta clase tiene un m\u00e9todo <code>load()</code> que permite cargar el fichero. No tenemos m\u00e1s que pasarle un <code>InputStream</code> o un <code>Reader</code> de java.</p> <pre><code>properties.load(new FileReader(\"datasource.properties\"));\n</code></pre>"},{"location":"ud9/17configfiles/#leer-una-propiedad","title":"Leer una propiedad","text":"<p>El m\u00e9todo <code>properties.getProperty(String)</code> nos permite, pas\u00e1ndole una clave, obtener el valor asociado a ella. En nuestro ejemplo, pasando como clave \"db.username\", obtendr\u00edamos el valor asociado a ella \"admin\" (siempre como String, aunque sea un n\u00famero).</p> <p>Si la clave no existe, obtendremos <code>null</code> como resultado. Sin embargo, tenemos una variante de <code>getProperty()</code> que permite obtener un valor por defecto en caso de que no exista la clave, como en el siguiente c\u00f3digo:</p> <pre><code>properties.getProperty(\"db.username\", \"default value\"));\n</code></pre> <p>Al m\u00e9todo <code>getProperty()</code> le pasamos como primer par\u00e1metro la clave cuyo valor queremos obtener, y como segundo par\u00e1metro el valor que queremos por defecto, en caso de que la clave no tenga valor asociado.</p>"},{"location":"ud9/17configfiles/#leer-todas-las-propiedades","title":"Leer todas las propiedades","text":"<p>La clase <code>Properties</code> tiene varios m\u00e9todos que nos permiten obtener todas las claves que hay en el fichero. Para ello recurriremos a un objeto <code>Enumeration</code> que nos permitir\u00e1 iterar sobre ellas. En este objeto almacenamos todas las claves de nuestro properties. Recorriendo estas claves, podemos obtener todos los valores. El siguiente c\u00f3digo consulta todas las claves con el m\u00e9todo <code>keys()</code> y luego realiza un bucle para ir sacando por pantalla todos los valores.</p> <pre><code>Enumeration&lt;Object&gt; keys = properties.keys(); \nwhile (keys.hasMoreElements()) {\n    Object key = keys.nextElement(); \n    System.out.println(key + \" = \"+ properties.get(key));\n}\n</code></pre>"},{"location":"ud9/17configfiles/#anadir-o-modificar-una-propiedad","title":"A\u00f1adir o modificar una propiedad","text":"<p>Para a\u00f1adir/modificar el valor de una propiedad, la clase <code>Properties</code> tiene un m\u00e9todo llamado <code>setProperty(String key, String value)</code> que te permite a\u00f1adir una pareja clave/valor nuevas o modificar una ya existente.</p> <pre><code>properties.setProperty(\"db.port\", \"4020\");\n</code></pre> <p>Una vez que hemos modificado/a\u00f1adido valores, tendremos que guardar el fichero. Para ello la clase <code>Properties</code> tiene dos m\u00e9todos: <code>save()</code> y <code>store()</code>. El m\u00e9todo <code>save()</code> est\u00e1 obsoleto, por lo que no se aconseja su uso. Para guardar los cambios, debemos llamar a <code>store()</code> pas\u00e1ndole un <code>OutputStream</code> o un <code>Writer</code> de java.</p> <pre><code>properties.store(new FileWriter(\"datasource.properties\"),\"Added database port\");\n</code></pre> <p>El m\u00e9todo <code>store()</code> admite un segundo par\u00e1metro que es un comentario que se a\u00f1adir\u00e1 como una l\u00ednea de cabecera en el fichero. El resultado de esta llamada es un fichero con un contenido como el siguiente:</p> <p></p> <p>Contiene el comentario que pusimos en la llamada a <code>store()</code> y la fecha.</p>"},{"location":"ud9/17configfiles/#ejemplo-completo","title":"Ejemplo completo","text":"<pre><code> public static void main(String[] args) {\n    final String filePath = \"config.properties\";\n\n    // Escribir datos en el archivo de propiedades\n    try (FileOutputStream fileOut = new FileOutputStream(filePath)) {\n        Properties properties = new Properties();\n        properties.setProperty(\"database.url\", \"jdbc:mysql://localhost:3306/mydatabase\");\n        properties.setProperty(\"database.user\", \"admin\");\n        properties.setProperty(\"database.password\", \"123456\");\n        //informaci\u00f3n sobre el fichero\n        properties.store(fileOut, \"Configuraci\u00f3n de la base de datos\");\n        System.out.println(\"Datos escritos correctamente en el archivo de propiedades.\");\n    } catch (IOException e) {\n        System.out.println(\"Error al escribir en el archivo de propiedades.\");\n        e.printStackTrace();\n    }\n\n    // Leer datos del archivo de propiedades\n    try (FileInputStream fileIn = new FileInputStream(filePath)) {\n        Properties properties = new Properties();\n        properties.load(fileIn);\n\n        String url = properties.getProperty(\"database.url\");\n        String user = properties.getProperty(\"database.user\");\n        String password = properties.getProperty(\"database.password\");\n\n        System.out.println(\"URL de la base de datos: \" + url);\n        System.out.println(\"Usuario de la base de datos: \" + user);\n        System.out.println(\"Contrase\u00f1a de la base de datos: \" + password);\n    } catch (IOException e) {\n        System.out.println(\"Error al leer el archivo de propiedades.\");\n        e.printStackTrace();\n    }\n}\n</code></pre>"},{"location":"ud9/18xmlfiles/","title":"Ficheros XML","text":"<p>XML es la abreviatura de Extensible Markup Language y es un formato de intercambio de datos establecido. XML fue definido en 1998 por el World Wide Web Consortium (W3C). A diferencia de otros lenguajes, XML da soporte a bases de datos, siendo \u00fatil cuando varias aplicaciones deben comunicarse entre s\u00ed o integrar informaci\u00f3n.</p>"},{"location":"ud9/18xmlfiles/#estructura-de-un-documento-xml","title":"Estructura de un documento XML","text":"<p>Un documento XML consta de elementos, cada elemento tiene una etiqueta de inicio, contenido y una etiqueta de finalizaci\u00f3n. Una etiqueta consiste en una marca hecha en el documento, que se\u00f1ala una porci\u00f3n de este como un elemento. Un pedazo de informaci\u00f3n con un sentido claro y definido. Las etiquetas tienen la forma <code>&lt;nombre&gt;</code>, donde nombre es el nombre del elemento que se est\u00e1 se\u00f1alando.</p>"},{"location":"ud9/18xmlfiles/#documento-xml-valido","title":"Documento XML v\u00e1lido","text":"<p>Los documentos denominados como \u00abbien formados\u00bb (del ingl\u00e9s well formed) son aquellos que cumplen con todas las definiciones b\u00e1sicas de formato y pueden, por lo tanto, analizarse correctamente por cualquier analizador sint\u00e1ctico (parser) que cumpla con la norma. Esto significa que debe aplicarse a las siguientes condiciones:</p> <ol> <li>Cada etiqueta de apertura tiene una etiqueta de cierre.</li> <li>Todas las etiquetas est\u00e1n completamente anidadas.</li> <li>Los documentos XML solamente permiten un elemento ra\u00edz del que todos los dem\u00e1s sean parte, es decir, solo pueden tener un elemento inicial.</li> <li>El XML es sensible a may\u00fasculas y min\u00fasculas.</li> </ol>"},{"location":"ud9/18xmlfiles/#partes-de-un-documento-xml","title":"Partes de un documento XML","text":""},{"location":"ud9/18xmlfiles/#prologo","title":"Pr\u00f3logo","text":"<p>Aunque no es obligatorio, los documentos XML pueden empezar con unas l\u00edneas que describen la versi\u00f3n XML, el tipo de documento y otras cosas.</p> <p>El pr\u00f3logo de un documento XML contiene:</p> <ul> <li>Una declaraci\u00f3n XML. Es la sentencia que declara al documento como un documento XML.</li> <li>Una declaraci\u00f3n de tipo de documento. Enlaza el documento con su DTD (definici\u00f3n de tipo de documento), o el DTD puede estar incluido en la propia declaraci\u00f3n o ambas cosas al mismo tiempo.</li> <li>Uno o m\u00e1s comentarios e instrucciones de procesamiento. Ejemplo:</li> </ul> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n</code></pre>"},{"location":"ud9/18xmlfiles/#cuerpo","title":"Cuerpo","text":"<p>A diferencia del pr\u00f3logo, el cuerpo no es opcional en un documento XML, el cuerpo debe contener solo un elemento ra\u00edz, caracter\u00edstica indispensable tambi\u00e9n para que el documento est\u00e9 bien formado. Sin embargo es necesaria la adquisici\u00f3n de datos para su buen funcionamiento.</p>"},{"location":"ud9/18xmlfiles/#elementos","title":"Elementos","text":"<p>Los elementos XML pueden tener contenido (m\u00e1s elementos, caracteres o ambos), o bien ser elementos vac\u00edos.</p>"},{"location":"ud9/18xmlfiles/#atributos","title":"Atributos","text":"<p>Los elementos pueden tener atributos, que son una manera de incorporar caracter\u00edsticas o propiedades a los elementos de un documento. Deben ir entre comillas.</p> <pre><code>&lt;person sex=\"female\"&gt;\n  &lt;firstname&gt;Patricia&lt;/firstname&gt;\n  &lt;lastname&gt;Marti&lt;/lastname&gt;\n&lt;/person&gt;\n</code></pre> <p>En el ejemplo, el elemento <code>person</code> tiene un atributo <code>sex</code>.</p>"},{"location":"ud9/18xmlfiles/#comentarios","title":"Comentarios","text":"<p>Comentarios a modo informativo para el programador que han de ser ignorados por el procesador. Los comentarios en XML tienen el siguiente formato:</p> <pre><code>  &lt;!-- Comment --&gt;\n</code></pre>"},{"location":"ud9/18xmlfiles/#ejemplo-de-un-documento-xml","title":"Ejemplo de un documento XML","text":"<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"&gt;\n\n&lt;!-- This is a comment --&gt;\n\n&lt;products&gt; \n    &lt;product&gt; \n        &lt;name&gt;Cereales&lt;/name&gt; \n        &lt;price&gt;3.45&lt;/price&gt; \n    &lt;/product&gt; \n    &lt;product&gt; \n        &lt;name&gt;Colacao&lt;/name&gt; \n        &lt;price&gt;1.45&lt;/price&gt; \n    &lt;/product&gt; \n    &lt;product&gt; \n        &lt;name&gt;Agua mineral&lt;/name&gt; \n        &lt;price&gt;1.00&lt;/price&gt; \n    &lt;/product&gt; \n&lt;/products&gt;\n</code></pre>"},{"location":"ud9/18xmlfiles/#url-xml","title":"Url XML","text":"<p>El est\u00e1ndar XML</p>"},{"location":"ud9/18xmlfiles/#java-xml","title":"Java XML","text":"<p>Java permite usar analizadores XML como DOM, SAX, StAX y JDOM para leer y escribir documentos XML; Adem\u00e1s, JAXB para convertir XML a/desde objetos.</p> <p>En general, existen dos modelos de programaci\u00f3n para trabajar con documentos XML: DOM y SAX (Streaming).</p>"},{"location":"ud9/18xmlfiles/#dom","title":"DOM","text":"<p>El modelo de objeto de documento (DOM) utiliza nodos para representar los documentos XML completos como una estructura de \u00e1rbol y almacenarlos en la memoria.</p> <p>DOM es bueno para manipular el archivo XML peque\u00f1o, como leer, escribir y modificar la estructura XML; DOM NO es para analizar o manipular archivos XML grandes porque construir la estructura XML completa en la memoria consume mucha memoria.</p>"},{"location":"ud9/18xmlfiles/#sax","title":"SAX","text":"<p>La API simple para XML (SAX) permite leer el archivo XML de principio a fin, es decir, de manera secuencial.</p> <p>El SAX es r\u00e1pido y eficiente, requiere mucha menos memoria que DOM porque SAX no crea una representaci\u00f3n interna (estructura de \u00e1rbol) de los datos XML, como lo hace un DOM.</p>"},{"location":"ud9/18xmlfiles/#stax","title":"StAX","text":"<p>Streaming API for XML (StAX) est\u00e1 basado en eventos, permite leer y escribir documentos XML. StAX ofrece un modelo de programaci\u00f3n m\u00e1s simple que SAX y una gesti\u00f3n de memoria m\u00e1s eficiente que DOM.</p>"},{"location":"ud9/18xmlfiles/#ejemplo-lectura-xml-desde-una-api","title":"Ejemplo lectura XML desde una API","text":"<pre><code>private static Document loadXMLDocument(String url)  {\n    try (InputStream input = new URL(url).openStream()) {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        DocumentBuilder builder = factory.newDocumentBuilder();\n        return builder.parse(input);\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n</code></pre>"},{"location":"ud9/18xmlfiles/#escritura-de-un-documento-xml","title":"Escritura de un documento XML","text":"<p>Crear un fichero XML en Java es un proceso sencillo que normalmente implica usar la biblioteca est\u00e1ndar javax.xml o una biblioteca externa como DOM o StAX</p> <p>Vamos a ver como generar el siguiente fichero xml que podr\u00eda venir de una lista o una b\u00fasqueda SQL en una base de datos</p> <p><pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?&gt;\n&lt;Personas&gt;\n    &lt;Persona genero=\"M\" id=\"1\"&gt;\n        &lt;Nombre&gt;Pedro P\u00f3mez&lt;/Nombre&gt;\n        &lt;Edad&gt;30&lt;/Edad&gt;\n    &lt;/Persona&gt;\n    &lt;Persona genero=\"F\" id=\"2\"&gt;\n        &lt;Nombre&gt;Maria Garc\u00eda&lt;/Nombre&gt;\n        &lt;Edad&gt;25&lt;/Edad&gt;\n    &lt;/Persona&gt;\n&lt;/Personas&gt;\n</code></pre> Crearemos un documento mediante la clase <code>DocumentBuilderFactory</code> y construiremos el \u00e1rbol XML sobre \u00e9l.</p> <p>Tenemos una clase principal <code>Element</code> que representa una etiqueta. A esta etiqueta podemos a\u00f1adir atributos o nuevos elementos hijos para construir el \u00e1rbol XML</p> <pre><code>public class CrearXML {\n    public static void main(String[] args) {\n        try {\n            // 1. Crear una instancia de DocumentBuilder\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = factory.newDocumentBuilder();\n\n            // 2. Crear un nuevo documento XML\n            Document doc = builder.newDocument();\n\n            // 3. Crear el elemento ra\u00edz y declaramos los elementos a crear\n            Element rootElement = doc.createElement(\"Personas\");\n            doc.appendChild(rootElement);\n\n            Element persona;\n            Element nombre;\n            Element edad;\n            // 4. A\u00f1adir un hijo al elemento ra\u00edz con  atributos\n            persona = doc.createElement(\"Persona\");\n            persona.setAttribute(\"id\", \"1\"); // Atributo \"id\"\n            persona.setAttribute(\"genero\", \"M\"); // Atributo \"genero\"\n            rootElement.appendChild(persona);\n\n\n            // 5. A\u00f1adir subelementos a \"Persona\"\n            nombre = doc.createElement(\"Nombre\");\n            nombre.appendChild(doc.createTextNode(\"Pedro P\u00f3mez\"));\n            persona.appendChild(nombre);\n\n            edad = doc.createElement(\"Edad\");\n            edad.appendChild(doc.createTextNode(\"30\"));\n            persona.appendChild(edad);\n\n            // 6. A\u00f1adir otro elemento con atributos\n            persona = doc.createElement(\"Persona\");\n            persona.setAttribute(\"id\", \"2\"); // Atributo \"id\"\n            persona.setAttribute(\"genero\", \"F\"); // Atributo \"genero\"\n            rootElement.appendChild(persona);\n\n            nombre = doc.createElement(\"Nombre\");\n            nombre.appendChild(doc.createTextNode(\"Maria Garc\u00eda\"));\n            persona.appendChild(nombre);\n\n            edad = doc.createElement(\"Edad\");\n            edad.appendChild(doc.createTextNode(\"25\"));\n            persona.appendChild(edad);\n\n            // 7. Escribir el contenido en un archivo XML\n            TransformerFactory transformerFactory = TransformerFactory.newInstance();\n            Transformer transformer = transformerFactory.newTransformer();\n            transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n            DOMSource source = new DOMSource(doc);\n            StreamResult result = new StreamResult(new File(\"personas.xml\"));\n\n            transformer.transform(source, result);\n\n            System.out.println(\"Archivo XML con atributos creado con \u00e9xito!\");\n\n        } catch (ParserConfigurationException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre>"},{"location":"ud9/19jsonfiles/","title":"Ficheros JSON","text":"<p>JSON (JavaScript Object Notation) es un formato ligero de intercambio de datos. Es un fichero f\u00e1cil de leer y escribir para los humanos y tambi\u00e9n f\u00e1cil de analizar y generar para las m\u00e1quinas. Se basa en un subconjunto del lenguaje de programaci\u00f3n JavaScript. Debido a su amplia adopci\u00f3n como alternativa a XML. JSON es un formato de texto que es completamente independiente del lenguaje pero utiliza convenciones que son ampliamente conocidos por los programadores de la familia de lenguajes C, incluyendo C, C++, C#, Java, JavaScript, Perl, Python, y muchos otros. Estas propiedades hacen que JSON sea un lenguaje ideal para el intercambio de datos.</p> <p>JSON se utiliza hoy en d\u00eda en cada API web \u00fanica.</p> <p>JSON se basa en dos estructuras que son universales; virtualmente todos los lenguajes de programaci\u00f3n las soportan de una forma u otra:</p> <ul> <li>Una colecci\u00f3n de pares de name/value. En varios lenguajes, esto se realiza como un objeto, registro, estructura, diccionario, tabla hash, lista con clave o matriz asociativa.</li> <li>Una lista ordenada de valores. En la mayor\u00eda de los lenguajes, esto se realiza como una matriz, vector, lista o secuencia.</li> </ul>"},{"location":"ud9/19jsonfiles/#tipos-de-datos-disponibles","title":"Tipos de datos disponibles","text":"<ol> <li>N\u00fameros: Se permiten n\u00fameros negativos y opcionalmente pueden contener parte fraccional separada por puntos. Ejemplo: 123.456</li> <li>Cadenas: Representan secuencias de cero o m\u00e1s caracteres. Se ponen entre doble comilla y se permiten cadenas de escape. Ejemplo: \"Hola\"</li> <li>Booleanos: Representan valores booleanos y pueden tener dos valores: true y false</li> <li>null: Representan el valor nulo.</li> <li>Array: Representa una lista ordenada de cero o m\u00e1s valores los cuales pueden ser de cualquier tipo. Los valores se separan por comas y el vector se mete entre corchetes.</li> <li>Objetos: Son colecciones no ordenadas de pares de la forma <code>nombre:valor</code> separados por comas y puestas entre llaves. El nombre tiene que ser una cadena entre comillas dobles. El valor puede ser de cualquier tipo.</li> </ol>"},{"location":"ud9/19jsonfiles/#ejemplo-de-fichero-json","title":"Ejemplo de fichero JSON","text":"<pre><code>{\n  \"departamentos\": [\n    {\n      \"id\": 8,\n      \"nombre\": \"Ventas\",\n      \"director\": \"Juan Rodr\u00edguez\",\n      \"empleados\": [\n        {\n          \"nombre\": \"Pedro\",\n          \"apellido\": \"Fern\u00e1ndez\"\n        },\n        {\n          \"nombre\": \"Jacinto\",\n          \"apellido\": \"Benavente\"\n        }\n      ]\n    },\n    {\n      \"id\": 9,\n      \"nombre\": \"Recursos Humanos\",\n      \"director\": \"Mar\u00eda P\u00e9rez\",\n      \"empleados\": [\n        {\n          \"nombre\": \"Laura\",\n          \"apellido\": \"Gonz\u00e1lez\"\n        },\n        {\n          \"nombre\": \"Roberto\",\n          \"apellido\": \"Mart\u00ednez\"\n        }\n      ]\n    },\n    {\n      \"id\": 10,\n      \"nombre\": \"Desarrollo\",\n      \"director\": \"Ana Garc\u00eda\",\n      \"empleados\": [\n        {\n          \"nombre\": \"Luis\",\n          \"apellido\": \"L\u00f3pez\"\n        },\n        {\n          \"nombre\": \"Elena\",\n          \"apellido\": \"S\u00e1nchez\"\n        }\n      ]\n    }\n  ]\n}\n</code></pre> <p>El fichero anterior se puede traducir como un array Departamentos donde cada Departamento:</p> <ul> <li>Campos: id, director, empleados</li> <li>empleados: Array de Empleado con campos: nombre, apellido</li> </ul>"},{"location":"ud9/19jsonfiles/#url-oficial","title":"URL oficial","text":"<p>The JSON Specification</p>"},{"location":"ud9/19jsonfiles/#json-vs-xml","title":"JSON vs XML","text":""},{"location":"ud9/19jsonfiles/#java-json","title":"Java JSON","text":"<p>Java por defecto no ofrece ninguna funcionalidad integrada para analizar o crear JSON, en lugar de eso, tendremos que confiar en una biblioteca/paquete de terceros.</p> <p>En la actualidad existen varias librer\u00edas para pasar transformar un objeto Java en una cadena JSON (serializaci\u00f3n) o viceversa (deserializaci\u00f3n).</p> <p>Desde la p\u00e1gina en donde se encuentra la especificaci\u00f3n de JSON se indican las librer\u00edas m\u00e1s conocidas para tratar/generar informaci\u00f3n relativa al formato JSON en los diferentes lenguajes de programaci\u00f3n.</p>"},{"location":"ud9/19jsonfiles/#libreria-jackson-databind","title":"Librer\u00eda jackson-databind","text":"<p>Jackson Databind es una biblioteca de Java que forma parte del proyecto Jackson, una de las bibliotecas de c\u00f3digo abierto m\u00e1s populares para el procesamiento de JSON en Java. Jackson Databind proporciona funcionalidades para mapear objetos Java a JSON (serializaci\u00f3n) y viceversa (deserializaci\u00f3n).</p> <p>Jackson Databind </p>"},{"location":"ud9/19jsonfiles/#agregar-libreria-al-proyecto","title":"Agregar librer\u00eda al proyecto","text":"<p>Para utilizar la librer\u00eda hay que a\u00f1adirla al proyecto en intelliJ</p> <p> </p> <p></p> <p>Nos habr\u00e1 agregado la librer\u00eda al proyecto</p> <p></p>"},{"location":"ud9/19jsonfiles/#crea-los-pojo-que-correspondan-al-fichero-json","title":"Crea los POJO que correspondan al fichero json","text":"<p>Tenemos que identificar las clases Java que corresponden al json. Por ejemplo,  <pre><code>{\n  \"noticias\": [\n    {\n      \"fecha\": \"2024-04-26\",\n      \"titulo\": \"Descubrimiento de nueva especie de planta en la selva amaz\u00f3nica\",\n      \"descripcion\": \"Investigadores han anunciado el descubrimiento de una nueva especie de planta en la selva amaz\u00f3nica. La planta, que ha sido bautizada como 'Amazoniaensis flore', se caracteriza por sus grandes hojas y flores de vivos colores.\"\n    },\n    {\n      \"fecha\": \"2024-04-25\",\n      \"titulo\": \"Avances en la lucha contra el cambio clim\u00e1tico\",\n      \"descripcion\": \"Cient\u00edficos han publicado un nuevo estudio que revela avances prometedores en la lucha contra el cambio clim\u00e1tico. Seg\u00fan el estudio, las medidas de reducci\u00f3n de emisiones implementadas en varios pa\u00edses est\u00e1n comenzando a dar resultados tangibles en la disminuci\u00f3n de la concentraci\u00f3n de gases de efecto invernadero en la atm\u00f3sfera.\"\n    }\n  ]\n}\n</code></pre></p> <p>Tendr\u00edamos que crear la clase con la lista de noticias. </p> <pre><code>public class Noticias {\n    private List&lt;Noticia&gt; noticias;\n\n    public List&lt;Noticia&gt; getNoticias() { return noticias; }\n    public void setNoticias(List&lt;Noticia&gt; value) { this.noticias = value; }\n\n     @Override\n    public String toString() {\n        return \"Noticias{\" +\n                \"noticias=\" + noticias +\n                '}';\n}\n</code></pre> <p>Importante</p> <p>La clase puede tener varios constructores, pero siempre tiene que tener el constructor por defecto sin par\u00e1metros</p> <p>Una clase para las Noticias</p> <p><pre><code>class Noticia {\n    private LocalDate fecha;\n    private String titulo;\n\n    private String descripcion;\n    //es obligatorio este constructor\n    public Noticia() {\n    }\n\n    public Noticia(String fecha, String titulo, String descripcion) {\n        setFecha(fecha);\n        this.titulo = titulo;\n        this.descripcion = descripcion;\n    }\n\n    public String getDescripcion() { return descripcion; }\n    public void setDescripcion(String value) { this.descripcion = value; }\n\n    public String getFecha() { return fecha.toString(); }\n    public void setFecha(LocalDate value) { this.fecha = value; }\n    //no existe el tipo fecha en json\n    public void setFecha(String value){\n        this.fecha=LocalDate.parse(value);\n    }\n\n    public String getTitulo() { return titulo; }\n    public void setTitulo(String value) { this.titulo = value; }\n\n    @Override\n    public String toString() {\n        return \"Noticia{\" +\n                fecha +\"\\n\"+\n                titulo+\"\\n\"+\n                descripcion+\n                \"}\\n\";\n    }\n}\n</code></pre> Para leer el Json y transformarlos a objetos Java, la clase principal es <code>ObjectMapper</code></p> <pre><code>public static void main(String[] args) {\n    // Lee los datos de un archivo json\n    try {\n\n        //Lectura del fichero\n        var objectMapper = new ObjectMapper();\n        // Convierte el json  en un objeto de tipo Noticias\n        Noticias noticias =  objectMapper.readValue(new File(\"noticias.json\"), Noticias.class);\n        System.out.println(noticias);\n\n        //Escritura fichero\n        //a\u00f1adimos una nueva noticia\n        noticias.getNoticias().add(new Noticia(\"2024-04-24\",\"Lanzamiento exitoso de la misi\u00f3n espacial a Marte\",\"La agencia espacial internacional ha anunciado el exitoso lanzamiento de una misi\u00f3n espacial con destino a Marte. Esta misi\u00f3n, denominada 'Explorador Rojo', tiene como objetivo buscar signos de vida pasada o presente en el planeta rojo y recopilar datos sobre su geolog\u00eda y atm\u00f3sfera.\"));\n\n        //Para que muestre el JSON tabulado\n        objectMapper.configure(SerializationFeature.INDENT_OUTPUT, true);\n        // Convertir objeto a un string json\n        String jsonString = objectMapper.writeValueAsString(noticias);\n        System.out.println(jsonString);\n\n        //Guardar el JSON en un fichero\n        objectMapper.writeValue(new File(\"noticias2.json\"), noticias);\n\n    } catch (IOException e) {\n        System.out.println(\"Error E/S: \"+e.getMessage());\n    } catch (Exception e){\n        System.out.println(\"Error parser json: \"+e.getMessage());\n    }\n\n}\n</code></pre>"},{"location":"ud9/19jsonfiles/#plugin-de-intellij-para-crear-las-clases-desde-un-json","title":"Plugin de IntelliJ para crear las clases desde un json","text":"<p>IntelliJ tiene varios plugin que permiten crear las clases a partir del Json. Uno de ellos es JsonToJava</p> <p>Podemos a\u00f1adir el plugin</p> <p></p> <p>Una vez a\u00f1adido(tendr\u00e1s que reiniciar IntelliJ), podemos crear una primera aproximaci\u00f3n a las clases necesarias mediante</p> <p></p> <p>Insertamos el json de muestra y le damos nombre a la clase superior, en nuestro caso Noticias</p> <p></p> <p>Nos genera las clases Java necesarias para parsear en Json.</p> <p>La librer\u00eda Jackson, tiene muchas utilidades. Deb\u00e9is consultar la documentaci\u00f3n t\u00e9cnica.</p>"},{"location":"ud9/19jsonfiles/#lectura-de-un-servicio-rest","title":"Lectura de un servicio Rest","text":"<p>Con esta librer\u00eda tenemos f\u00e1cil leer un servicio Web y convertirlo en objetos Java. Por ejemplo, vamos a leer un servicio de ejemplo disponible en la web</p> <p>jsonplaceholder</p> <p>Vamos a leer todos los posts disponibles y crear un ArrayList de Posts del servicio Web</p> <p>https://jsonplaceholder.typicode.com/posts</p> <p>Primero definimos el POJO para el Post que define la informaci\u00f3n</p> <pre><code>class Post {\n    private long id;\n    private String title;\n    private String body;\n    private long userId;\n\n    public long getid() { return id; }\n    public void setid(long value) { this.id = value; }\n\n    public String getTitle() { return title; }\n    public void setTitle(String value) { this.title = value; }\n\n    public String getBody() { return body; }\n    public void setBody(String value) { this.body = value; }\n\n    public long getUserId() { return userId; }\n    public void setUserId(long value) { this.userId = value; }\n\n    @Override\n    public String toString() {\n        return \"Post{\" +\n                \"id=\" + id +\n                \", title='\" + title + '\\'' +\n                \", body='\" + body + '\\'' +\n                \", userId=\" + userId +\n                \"}\\n\";\n    }\n}\n</code></pre> <p>Para solicitar al Web Service todos los Posts es necesario saber que informaci\u00f3n contiene el JSON, en nuestro caso es una lista de Posts. Creamos un objeto URL con el endpoint y le indicamos a Jackson que queremos una Lista de Posts</p> <pre><code> public static void main(String[] args) {\n    String url=\"https://jsonplaceholder.typicode.com/posts\";\n    List&lt;Post&gt; posts;\n    try {\n        ObjectMapper objectMapper = new ObjectMapper();\n        posts = objectMapper.readValue(new URL(url), new TypeReference&lt;List&lt;Post&gt;&gt;() {});\n        System.out.println(posts);\n\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}\n</code></pre>"},{"location":"ud9/1io/","title":"I/O Input/Output - Entrada/Salida de la informaci\u00f3n","text":"<p>Todo  dato tiene un origen de entrada o un destino de salida (convenientemente en ingl\u00e9s: I/O).</p> <ul> <li>Input o entrada implica leer datos de una fuente</li> <li>Output o salida implica escribirlos en un destino. </li> </ul> <p>Un programa trabaja con datos que provienen de una entrada la cual puede ser un teclado, un archivo en disco o un socket a trav\u00e9s de la red. As\u00ed mismo un programa genera resultados envi\u00e1ndolos a una salida la cual puede ser la pantalla, un archivo en disco o un socket a trav\u00e9s de la red. En Java, la conexi\u00f3n entre un programa y un origen o destino de datos se denomina flujo (en ingl\u00e9s: stream).</p> <p></p> <p>Un flujo de entrada (input stream) maneja los datos que fluyen hacia un programa. Un flujo de salida (output stream) maneja los datos que salen de un programa.</p> <p></p> <p>En las primeras versiones de Java el sistema de entrada/salida proporcionado en el paquete <code>java.io</code> era b\u00e1sico. En la versi\u00f3n 1.4 de Java se a\u00f1adi\u00f3 un nuevo sistema de entrada/salida llamado <code>java.NIO</code> (New IO) para suplir algunas de sus deficiencias que posteriormente en Java 7 se mejor\u00f3 a\u00fan m\u00e1s <code>java.NIO</code>. Entre las mejoras se incluyen permitir navegaci\u00f3n de directorios sencillo, soporte para reconocer enlaces simb\u00f3licos, leer atributos de ficheros como permisos e informaci\u00f3n como \u00faltima fecha de modificaci\u00f3n, soporte de entrada/salida as\u00edncrona y soporte para operaciones b\u00e1sicas sobre ficheros como copiar y mover ficheros.</p>"},{"location":"ud9/1io/#tipos-de-datos-caracteres-y-bytes","title":"Tipos de Datos - Caracteres y bytes","text":"<p>Existen dos tipos de flujos (streams) seg\u00fan el tipo de datos, flujos binarios y flujos de caracteres. Los tipos de datos que se pueden leer/escribir suelen ser bytes o caracteres y los m\u00e9todos que se utilizan son similares, pero se utilizan clases diferentes.</p>"},{"location":"ud9/1io/#byte-streams-flujos-de-bytes","title":"Byte Streams (Flujos de bytes):","text":"<ul> <li>Los byte streams operan a nivel de bytes, lo que significa que manejan datos de forma binaria, sin procesar.</li> <li>Son adecuados para leer y escribir datos binarios, como archivos de im\u00e1genes, archivos de audio, archivos ejecutables, etc.</li> <li>Los byte streams son m\u00e1s eficientes para leer y escribir datos binarios, ya que no realizan ninguna conversi\u00f3n de codificaci\u00f3n.</li> </ul> <p>Las clases principales</p> <p>Clases principales de InputStream:</p> <p></p> <p>Clases principales de OutputStream:</p> <p></p>"},{"location":"ud9/1io/#character-streams-flujos-de-caracteres","title":"Character Streams (Flujos de caracteres):","text":"<ul> <li>Los character streams operan a nivel de caracteres, lo que significa que manejan datos como secuencias de caracteres Unicode.</li> <li>Son adecuados para leer y escribir datos de texto, ya que manejan la conversi\u00f3n entre bytes y caracteres de manera autom\u00e1tica, utilizando la codificaci\u00f3n adecuada (como UTF-8, UTF-16, etc.).</li> <li>Los character streams son m\u00e1s adecuados para trabajar con texto porque se encargan autom\u00e1ticamente de la codificaci\u00f3n y decodificaci\u00f3n, lo que los hace portables entre diferentes plataformas.</li> <li>Las clases principales para manejar estos flujos son las clases abstractas Reader y Writer.</li> </ul> <p>Clases principales de Reader:</p> <p></p> <p>Clases principales de Writer:</p> <p></p> <p>La siguiente figura muestra la jerarqu\u00eda del paquete <code>java.io</code>. Los streams pueden estar orientados a bytes u orientados a caracteres. Cada tipo tiene flujos de entrada y flujos de salida.</p> <p></p>"},{"location":"ud9/1io/#flujos-orientados-a-bytes","title":"Flujos orientados a bytes","text":"<ul> <li>Dise\u00f1ado para entrada y salida de prop\u00f3sito general.</li> <li>Los datos pueden ser tipos de datos primitivos o bytes sin procesar.</li> </ul>"},{"location":"ud9/1io/#flujos-orientados-a-caracteres","title":"Flujos orientados a caracteres","text":"<ul> <li>Destinado a datos de caracteres.</li> <li>Los datos se transforman de/a caracteres Java de 16 bits utilizados dentro de los programas al formato utilizado externamente.</li> </ul>"},{"location":"ud9/1io/#ficheros","title":"Ficheros","text":"<p>Un fichero es un conjunto l\u00f3gico de informaci\u00f3n o de datos que se designa con un nombre y se configura como una unidad aut\u00f3noma completa para el sistema o el usuario. Un archivo o fichero inform\u00e1tico es un conjunto de bits que son almacenados en un dispositivo. Para poder acceder a ellos haremos uso de una ruta (path) ya sea relativa o absoluta.</p> <p></p>"},{"location":"ud9/1io/#tipos-de-acceso-a-ficheros","title":"Tipos de acceso a ficheros","text":"<ol> <li> <p>Acceso secuencial: Una lectura secuencial implica tener que acceder a un elemento antes de acceder al siguiente, es decir, de una manera lineal (sin saltos). Las clases <code>InputStream</code> y <code>OutputStream</code> son secuenciales.</p> </li> <li> <p>Acceso aleatorio: los ficheros de acceso aleatorio permiten acceder a sus datos de una forma aleatoria, esto es indicando una determinada posici\u00f3n desde la que leer/escribir. La clase <code>RandomAccessFile</code> permite el acceso aleatorio</p> </li> </ol>"},{"location":"ud9/20createjar/","title":"C\u00f3mo crear un jar en IntelliJ","text":"<ol> <li>Vamos a File \u2192 Project Structure</li> </ol> <ol> <li>En la secci\u00f3n Artifacts, seleccionamos el s\u00edmbolo \"+\" y seleccionamos el formato .jar \u2192 \"From modules with dependencies\"</li> </ol> <ol> <li>Le decimos cu\u00e1l es la clase main y aceptamos.</li> </ol> <ol> <li>Todav\u00eda no hemos construido el .jar. Para crearlo vamos al men\u00fa \"Build\" \u2192 \"Build Artifact\".</li> </ol> <ol> <li>Seleccionamos \"Build\".</li> </ol> <p>El .jar estar\u00e1 en la carpeta del proyecto dentro de /out/artifacts/...</p>"},{"location":"ud9/21tryresources/","title":"\ud83e\udd73 try-with-resources","text":"<p>La sentencia try-with-resources es una sentencia try que declara uno o m\u00e1s recursos (resources). Un recurso es un objeto que debe cerrarse despu\u00e9s de que el programa termine con \u00e9l. La instrucci\u00f3n try-with-resources garantiza que cada recurso se cierre al final de la instrucci\u00f3n. Cualquier objeto que implemente java.lang.AutoCloseable, que incluye todos los objetos que implementen java.io.Closeable, se puede utilizar como recurso, por lo que no ser\u00eda necesario realizar la sentencia <code>recurso.close()</code>.</p> <p>Antes de Java SE 7, se pod\u00eda usar un bloque <code>finally</code> para asegurarse de que un recurso se cerraba, independientemente de si el try generaba excepci\u00f3n o no.</p> <p>El siguiente ejemplo, creamos el objeto <code>FileWriter</code> en la l\u00ednea 2, en vez de hacerlo en la 4 porque el <code>finally</code> de la l\u00ednea 8 se encuentra en otro scope y la variable <code>fw</code> no existe.</p> <pre><code>public static void main(String[] args) {\n        FileWriter fw =null;\n        try {\n            fw = new FileWriter(\"prueba.txt\");\n            fw.write(\"texto de prueba\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (fw != null) {\n                    System.out.println(\"El fichero se cierra\");\n                    fw.close();\n                }\n            }catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n</code></pre> <p>Al hacer el <code>close()</code> manualmente, vemos que el c\u00f3digo queda bastante engorroso, ya que la sentencia close lanza una excepci\u00f3n que hay que capturar. Con try-with-resources el c\u00f3digo queda m\u00e1s limpio.</p> <p>Importante diferencia entre try-with-resources y try con finally \ud83e\udd14</p> <p>Existe una ligera mejora al usar try-with-resources. Si en el c\u00f3digo anterior se lanzara una excepci\u00f3n al escribir el fichero, \u00e9sta se capturar\u00eda y se ejecutar\u00eda el finally a continuaci\u00f3n. Si \u00e9ste a su vez, lanzara tambi\u00e9n una excepci\u00f3n al llamar al m\u00e9todo <code>close</code>, se reenviar\u00eda esta, NO la primera que se gener\u00f3. Esto cambia ligeramente en el try-with-resources, puesto que enviar\u00eda la primera excepci\u00f3n que se gener\u00f3. Lo cual tiene sentido, puesto que fue la causante del error.</p> <p>As\u00ed quedar\u00eda el c\u00f3digo usando try-with-resources:</p> <pre><code>public static void main (String[] args) throws IOException {\n    try(FileWriter fw = new FileWriter(\"prueba.txt\");\n        FileWriter fw2 = new FileWriter(\"prueba2.txt\");) {\n        //si quisiera poner un segundo writer quedar\u00eda as\u00ed\n\n        fw.write(\"texto de prueba\");\n    }\n}\n</code></pre> <p>Nota \ud83e\udd13</p> <p>Podemos declarar varios recursos dentro de un mismo try como se ve en el ejemplo.</p>"}]}